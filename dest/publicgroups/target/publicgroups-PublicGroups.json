{ "transpiled": true, "noir_version": "0.33.0+8ac81b15cd2a3b57493bfbfe444086deac8f3dc8", "name": "PublicGroups", "functions": [{ "name": "admin", "is_unconstrained": true, "custom_attributes": ["aztec(public)", "aztec(view)"], "abi": { "error_types": {}, "parameters": [{ "name": "inputs", "type": { "fields": [{ "name": "calldata_length", "type": { "kind": "field" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }], "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs" }, "visibility": "private" }], "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" } }, "bytecode": "H4sIAAAAAAAC/01RsU5DMQy8xEnspA8mJCqVHdTSdskTAwsSlA0WhJCY4Wf7VZyf+lQiJfIl9p3P2UFC3EPsFdhBYuaBcguuwp0Be155aC++3zFHDCJ3WCHMVyNzIaOjdM+3ixEkPniqHTz3ZqKdTn2cJdSfdwihNAQrugGuoIeA0/In4+U10v9LiamzkApIDoMSJoc6wdKRdEeF2mPVHpN1GLVEI1FR91k7al7jrkFydeEOXWPTg5HM6F1yzD3k4mXVIyfxKtmeklwxsZWQymqeGBJ1g9CepPbg7TZu8a4WAzkXA6WeMJztcFBqsvDRI1rmf3AU0ww/OM6C5rUu1fLQowyTQW+v6CVPFRK+Qc6EPTZv1XNKLHTPcahbZeKnMfgir1hZ43f0+ZdAycnNfgrsgj9nlqzu+b/BmjfUrFolwY9VppsntNGv1WGZYDS15tBoxNb4psJ2xPK4PP4BQmA/R2sCAAA=", "debug_symbols": "1ZrdbsIwDIXfJddcxPmzw6tM01Q2mCpVZQI2aUK8+wKjhXXIDDGQfQMNHMzXKM6xo67Ny3Ty/vpUt7P50owf1qaZP1eret6W0XozMpNF3TT169Pxx8ZuX8Dv9Mu3qt0Ol6tqsTJjOzLT9qW8l9/O6mZqxug2o1+y7HEvzBF7KUR/Qhuc7aKWy9yrczwhTtnBXpzKnxyLH0cGwhXMYCHslWB9uCN1vGam0Xcznc/NNDjK3R36EHlmgtiJyVk3ZE7/wlwm+if0NjTeLjTdLnS+WWhn/xx6q4aL1O4i9ck9gexhoeCZHAPbbQwA/rCoAOmEOuYcu7SxkPj1GjF2ocslDdarC2rJo1rypJYc1ZKTWvKsldxbteSgltypJVfroV6th3q1HurVemgQvStS6MkpDsklZyj1bWe5TENyyRnKk0vOUJ5ccoby5Peucsn25B54coD+xKSEPvSh3sIOndSiR9GVC7cvRtGVC0suunJhyUVXLiy56H2xP5+OFIbnsVFy90/OMeSSu3+eXHL3f8Ao5MSLsw+dVZSTfj+4zSS5KGaLhST5qIAnl2y4PLnaRiRJNlyeXG0jktQ2Ikm04bLkog2XJZdtuAw5qvVQVOuhqNZDUa2HoloPRbUeimo9FNV6KKr1UFTroaTUQzdl9FEt6mrSTPdPMM7e2+ejBxpXn2/f3xTxFw==", "brillig_names": ["admin"], "assert_messages": { "63": "Array index out of bounds", "76": "attempt to add with overflow", "22": "Function admin can only be called statically", "19": "Not initialized" } }, { "name": "add_to_group", "is_unconstrained": true, "custom_attributes": ["aztec(public)"], "abi": { "error_types": {}, "parameters": [{ "name": "inputs", "type": { "fields": [{ "name": "calldata_length", "type": { "kind": "field" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }], "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs" }, "visibility": "private" }, { "name": "member", "type": { "fields": [{ "name": "inner", "type": { "kind": "field" } }], "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress" }, "visibility": "private" }, { "name": "approve", "type": { "kind": "boolean" }, "visibility": "private" }], "return_type": null }, "bytecode": "H4sIAAAAAAAC/2VTy4rVQBA9/UqqO925k93AiFshOvduOigKbnRGceFWEPQD3Ikf4Ae4EhFc69/MV3mqM+HeYQLVqa6cOnW6q7KHM/YAJ2+APZzvuUAegY/Qer5eXaDj67Xae2weHUszFzBbaMVdqzXc9WqnuBZayAm3aJbneoWw6JfuCXGTEquYJsfE2nQ4RFTrRENuCzmGfAsJQ15DwiQDqVb8BvUrdE9tjhT+gVKva3zRfPVoianGJ5jk42NgRrwyuH1IZj3JkpL5pmzYuIdNqB/IT/OpIg38NFju4qA3ys+xn/E8wfWxaRtY4xv8jJeVFZlRmFFsqaZkej6qlx5q9ZzQpeyZ8Bb+VFRnsyorm7LSpDSyavNGaENR1PhuO2lBw2Mkb3FkN1kc2T/AHdlbM5vJqv1j056J+4w849PliuhVIIElJy0eats6hKalq8iB7QhNWCaD10pfTisRnXtXjQvPdBNWda4f0sg1BeK/IhzxPJ7KuX9tR0E8cGdGqhrL7qnm7NagM2eq4Wwi53dMR86FzRQ3UHcG1fKHgBGvA/mTs9lhp7kkdLt+qrZMTV9Wfa0vP077Uu3uzgSMHJWszSfwl4QZv0nppJvxb9Hr7QyrQdidQ3Ok8HcU8RIPHGYjSbUkiaJj+Vci4aKAtGi4123XtlZ6SboVnkFm/GGFywXnN+c3/wEpr6Az5wMAAA==", "debug_symbols": "5ZzdTuMwEIXfJde98HjGP8OrrFarAgVVqgqCstIK8e7rdhs3DcHGsKAZ5QYaOHG+yTg5tjPNc3e9uny6/bXe3tw9dhc/nrvN3dVyt77bpq3nl0V3+bDebNa3v4Z/7sz+B4SD/vF+ud1vPu6WD7vuwiy61fY6/U773qw3q+4i2Jefiw5ik5pb1NY0qaFJbZvU2KSmJrVrUvsmdVMubVMubVMusSmX2JRLbMolNuUSm3KJ78/l4pWMMRyF7EKWgsMJLVnTt5o+clazmxB7tnAU+3SQoXjP7D/BDAboqASD9I3U4TNnOmB/prl2psFG7iNEcmXmCK4XR2vsmDn+F+Z0os+h903zlzVN5uuahq9revKeAIQ5mTS4yKb7Npj+ggTAUzIhxAm1Y3Z9dzXgy/3EBdc3nT7GUT8hVMxOitmdYnavmD0oZo+K2VkvuzOK2UExu2JfdYp91Sn2VSf8Hhkps0c3Yvey+3vME6r00Y/ZZff3Mrvs/l5mlz2OLLN//zgymsyOUGYHyGsCqenTBBENHOCDZvg37pI+T3MpQhmeMIsJQwUnmGCP4mDieH3F18eGkYY0aZ9gPrAPfGCf6Xuyg9jv48hWFg8gr7X5wdqB56m8uT7HwCdrs0xT7ToyeRGPeZBjnlbnJYzBapENhyhxFlHSLKJ0s4jSzyLKMIso4yyi5DlEGc0sooRZRDmLsU/8/NgHDNl8gAHNdJzvfOaUBsr9kNm6s7nBHpo0QjuN0F4jdH3c4HwF2nKeQSKEsyNMPEDH0+QUufLkGnPLZGhwoR8uRzbfjk6Y0X0F3YPrU+kPz/DPJrJMstm5vxl7a8aTcHay2aMtsHvR7NZwZofxgjUHxexRMTvrZU+jGM3woBneaoZHzfCyzbUCL9tdK/CK7TU9YtEML9tgwccTfKXElon6SJnYvIpUth2/HekeHoTPWcrwsu24Ai/bjivwwmtAS7UqAMKLQMvwwqtAy/CKS5wAZNeBxvy9GBdpvMwAVnYhaLS2BC+7ErQCL700jk/wsTIQwtOjCwz4KlLFhXQw/W1ELfCKS+nAyrbjCrxsO67Ay7bjCrxwOy7Co3A7LsMLt+MyvOJKdUDNDouaHRY1OyxqdljU7LCo2WFRs8OSZoclzQ4r/J0CBfiXtPV7+bBeXm5WxxcA3TxtrwbvA9r9uf/3nyT+Cw==", "brillig_names": ["add_to_group"], "assert_messages": { "112": "attempt to add with overflow", "126": "Array index out of bounds", "138": "attempt to add with overflow", "71": "caller is not admin", "41": "Not initialized", "86": "Storage slot 0 not allowed. Storage slots must start from 1.", "105": "Array index out of bounds" } }, { "name": "constructor", "is_unconstrained": true, "custom_attributes": ["aztec(public)", "aztec(initializer)"], "abi": { "error_types": {}, "parameters": [{ "name": "inputs", "type": { "fields": [{ "name": "calldata_length", "type": { "kind": "field" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }], "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs" }, "visibility": "private" }, { "name": "admin", "type": { "fields": [{ "name": "inner", "type": { "kind": "field" } }], "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress" }, "visibility": "private" }], "return_type": null }, "bytecode": "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", "debug_symbols": "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", "brillig_names": ["constructor"], "assert_messages": { "1018": "Array index out of bounds", "1719": "Array index out of bounds", "756": "attempt to add with overflow", "1061": "Array index out of bounds", "866": "Array index out of bounds", "1055": "Array index out of bounds", "860": "attempt to add with overflow", "1939": "attempt to add with overflow", "592": "Array index out of bounds", "1933": "attempt to add with overflow", "1482": "attempt to add with overflow", "836": "Array index out of bounds", "1025": "Array index out of bounds", "1726": "Array index out of bounds", "440": "Array index out of bounds", "1909": "Array index out of bounds", "1458": "Array index out of bounds", "105": "attempt to add with overflow", "678": "attempt to add with overflow", "1757": "Array index out of bounds", "666": "Array index out of bounds", "1623": "invalid admin", "1684": "Array index out of bounds", "1300": "attempt to add with overflow", "1306": "Array index out of bounds", "843": "Array index out of bounds", "1276": "Array index out of bounds", "1209": "Array index out of bounds", "1465": "Array index out of bounds", "1916": "Array index out of bounds", "1008": "Array index out of bounds", "1709": "Array index out of bounds", "990": "attempt to add with overflow", "1691": "attempt to add with overflow", "1283": "Array index out of bounds", "826": "Array index out of bounds", "247": "Args length exceeds maximum", "1643": "Storage slot 0 not allowed. Storage slots must start from 1.", "168": "attempt to add with overflow", "808": "attempt to add with overflow", "1448": "Array index out of bounds", "1899": "Array index out of bounds", "156": "Array index out of bounds", "1052": "Index out of bounds", "150": "Array index out of bounds", "1619": "Initializer address is not the contract deployer", "784": "Array index out of bounds", "912": "attempt to add with overflow", "1430": "attempt to add with overflow", "1613": "Initialization hash does not match", "900": "Array index out of bounds", "1881": "attempt to add with overflow", "1985": "attempt to add with overflow", "632": "Array index out of bounds", "626": "attempt to add with overflow", "1266": "Array index out of bounds", "1248": "attempt to add with overflow", "602": "Array index out of bounds", "791": "Array index out of bounds", "1803": "attempt to add with overflow", "1352": "attempt to add with overflow", "1663": "Array index out of bounds", "1340": "Array index out of bounds", "1791": "Array index out of bounds", "1078": "attempt to add with overflow", "609": "Array index out of bounds", "146": "attempt to add with overflow", "1042": "attempt to add with overflow", "1743": "attempt to add with overflow", "774": "Array index out of bounds", "1670": "attempt to add with overflow" } }, { "name": "in_group", "is_unconstrained": true, "custom_attributes": ["aztec(public)", "aztec(view)"], "abi": { "error_types": {}, "parameters": [{ "name": "inputs", "type": { "fields": [{ "name": "calldata_length", "type": { "kind": "field" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }], "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs" }, "visibility": "private" }, { "name": "group_member", "type": { "fields": [{ "name": "inner", "type": { "kind": "field" } }], "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress" }, "visibility": "private" }], "return_type": { "abi_type": { "kind": "boolean" }, "visibility": "public" } }, "bytecode": "H4sIAAAAAAAC/1VSy24UMRAsv9v2Tm5IK4U70kB2LzNCCG6QICHElR/ghBBSzskX5qtS5dlVNiO1x92u7uou+4Dg/BHBvgMHhJC5oLwDv0LLgH29Hr9vsl8477jxNHcNdw6txCKs8iLXW6QPRFytYPk7JdidMt6O4mO1z2cio9UDnLMGV628B96g3DqcPh1VBveIl8HsmRR8WYAIda4hnC2IZfGVhUPhoU9ljCVo/xFPlA0jCZ1lkBpyS0YaRHZgUWQz6iVZ8HEZnQbmiaefaftwK2k7yWiRLVjnUff0KoElz/jUEHJR5Z+oM74szjJxKhFZ28UEAbSzIfqQJUl0pJO9iL6FNpy2ZdsONUeKnewiZYRIScFKuCF/fc2/lcibMrnF8FGFgnxNuNuxv93EAX5jepGGN1wtdOISvCU+Jymoy//Ld5ARhljQ85qozSR3jJrqFdcaWfDP5cUuPqhLYZJPi+9pQZWABP6zNOM/6wZj5HHVRNmpRw1yHBub+OTMotUjx+abUkPNqkn7B6uEmwBtVbjIzcP1VqzJNQ5iM+7JcLNi/7R/egbuvOVyKgMAAA==", "debug_symbols": "5ZvRbuowDIbfpddc2EmcxLzK0dEEG0yVEEzAjnSEePcFRtNSqnQTY4qVG2jhJ/0cFf+O2x6ql8X8/fWpXi83u2r651CtNs+zfb1Zh73DcVLNt/VqVb8+dT+u4PSC5qzfvc3Wp93dfrbdV1OYVIv1S3gPv13Wq0U1deo4uZGxdhchk4tSJD2gNQqaUcMmRzXTgNiywovYhoN0xX8nFdIdzAhoLkoEbX6R2t4z0043M81jM43KcxOhNpRm9kiN2CtQfWb3I8xhoq+hT0P7xw3NDxtaweOGxi8PfVKrb6n1t9SDOYFdPKsA9EikGBOD7QRqeeh0pYYD2UetYjM0LhmIGYfbv6MGHla3xO2prdw5SCohSFtCkK6EIH0JQXIBQWooIUgsIUhVQpC6hCBNCUGWUPHouyseBKOiuAMzHOYXS38H/iJ0ql2RofNnZieQ2QtkZnnMBgQyo0DmUS9XaoQZocmOiFpdHeBWHdIcNb0iQJtu0pCjZuiw6Y/XTRqj5aIbuegkF93KRXdy0b1cdBaLTiAXHeWiy3VTkuumJNdNKe+87k1E99RDt1lnGB+vX4ZN20fPOsOk0bPOMGn0rDNMGv3XM4yHiK5xBF03GGS6HadzX8iSWHIrg5zsDTlLJXcgljzvtV3KSJ3cGsDlvbZLoue9tkuh+7wrr3hzHHnTvxnM5115KZVAz7zy4hbdp8Ws28tO2ul+nHLLNG/komfdVk2jZ229afSsrTeNnrX1ptGztt4kOstterDcpgfLbXqwXDdluW7Kct2U5bopy3VTluumLNdNEeTaKYJcPw1ogtmlOuox7P2bbevZfLW4PJ+4fF8/dx5X3P9/+/wmiD8A", "brillig_names": ["in_group"], "assert_messages": { "23": "Function in_group can only be called statically", "20": "Not initialized", "41": "Storage slot 0 not allowed. Storage slots must start from 1.", "86": "Array index out of bounds", "99": "attempt to add with overflow" } }, { "name": "compute_note_hash_and_optionally_a_nullifier", "is_unconstrained": true, "custom_attributes": [], "abi": { "error_types": {}, "parameters": [{ "name": "contract_address", "type": { "fields": [{ "name": "inner", "type": { "kind": "field" } }], "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress" }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "compute_nullifier", "type": { "kind": "boolean" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 3, "type": { "kind": "field" } }, "visibility": "private" }], "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" } }, "bytecode": "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", "debug_symbols": "7b3djvS4mp15L/u4D0TqFSX1rQwGg7bdNjbQ6Dbc7QEGhu99sr6sUESmfviVg0ku8X1OBtvTqii+z6oMrrUkMf7X3/7LP/+n//nf/p+//+t//bd//9s//l//62//8m//+Z/+4+//9q8f/6//9b//4W//6X/8/V/+5e//7f95/f/9t+GP/884/Lr+3//7P/3rH//Pf/+Pf/of//G3f5yG+R/+9s//+l8+/tcyf/zz//Xv//LPf/vHOf7v//sf/jaGv/pPTOPRP7GE8Oc/sQ7T93/C/vI/MR/9EyHM6c9/JIQlfP9nlv+Df2b96//MPB39M2uctn8krK//yD/srk1heoyewjpuFy/DwcUWpscnW5ifF0f7tZiktJhZaTGL0mJWocUsg9JigtJiotJiRqXFmNJilL6BF6Vv4EXpG3hR+gZelL6BV6Vv4FXpG3hV+gZe637PTPPTdD8/N378Y3+spe4fUxqGx7VD2q1l1VlLGAalxQSlxUSlxRRwM+PLYux6Mc9rgz0/d7TwuRhTWsxUdzFzfHzwOuwXk5QWM1ddTAzjn9fGMewXsygtZv3BxfzxLwjDT/8Lwk//C+JP/wvGn/4X2E//C6af/hekn/4XzD/9L1h++l/w03/J8af/kuNP/yXHn/5Ljj/9lxx/+i85/vRfcvzpv+T403/J8af/kuNP/yWP7/8lx6dHj2F6JxuHMUitJkqtZpRajUmtZpJaTZJazftfgmNcHqsZpyWTMYbwaJziYOlLyjhY+xC2tQ8vHx3ng4vn9Lh2fu2yxkMmjxXbS9I5vHQc5kcqGofXz7X/A9YLrKuxXmFdi7UNsK7GOsC6GusI6+elv4iMHomkR0SyFHdEDCLfiEwQ+UYkQeQbEZepY32kNlv336wus8ElEZcO/orI5NJnXxLx6Ian7WOnkHZEPHrWayIePes1EYPINyIe/cg02oPIuCOSPO41yR6LSGnYEfG411wTkd5rPqqyZ7ezvhL5tXbpXeHjltXV2qW/v8N29UeVNOzWLt0OZNYuneMza6+9wy0P2x5DsFbZoU1vnBZYV2O9wroW63mAdTXWAdbVWEdYf3X28+iRyNUdi9kg8o3IBJFvRBJEvhFxmTqu7ljMLrPBJRGXDv6KyOLSZ18S8eiGL+9YLB496zURj571mohB5BsRj37k8j7f6nGvubyrtXrca66JSO811/f5Vuld4fo+3yr9/X19v2mVbgcya5fO8Zm1V97hgi3b2pfYKju06Y3XBdbVWK+wrsQ6DgOsq7EOsK7GOsL6i7OPw+iRyMUdizgYRL4RmSDyjUiCyDciLlPHxR2LOLjMBpdEXDr4KyLBpc++JOLRDV/dsYjBo2e9JuLRs14TMYh8I+LRj1zd54vR415zdVcrRo97zTUR6b3m8j5fjNK7wuV9vhilv78v7zfFKN0OZNYuneMza6+8w32Elcfa4zS2yg5teuO4wLoa6xXWtViPA6yrsQ6wrsY6wvqrsx9Hj0Su7lgUOKG+NyITRL4RSRD5RsRl6ri6YzG6zAaXRFw6+Csi5tJnXxLx6IYv71iYR896TcSjZ70mYhD5RsSjH7m8zzd53Gsu72pNHveaayLSe831fb5Jele4vs83SX9/X99vmqTbgczapXN8Zu2Vd7gpbT8CPofcPcrx+bc6hmV+rj1+rn258drX+6699tndRdcebrz2eOO1jzdeu9147dON155uvPYb76vpxvtquvG+Ot94X51vvK/ON95X5xvvq7XPvC269hvvq/ON99X5xvvqfON9db7xvrrceF9dbryvLjfeV5cb76u1z+UsuvYb76vLjffV5cb76nLjfXW58b663nhfXW+8r6433lfXG++rtc9LLbr2G++r64331fXG++p64311ve++Og733VfH4b776jjcd18dh/vuq+Nw3311HO67r47DfffVcbjvvjoO991Xx+HG+2q48b4abryvhhvvq+HG+2rtc9uKrv3G+2q48b4abryvhhvvq0F6X43bM+RjfD394XPtUXpfzay9wL66PoRNZtP12sM6PNYe1vl58YevOrp6COPjUf+P/z0PX67/tfx47+WP916+3Xv5072Xn+69/Pney1/uvfz11ssvcbRay+Xfe9cd773rjuK77pyey395Efnk+jRtn55ezmobP/1diXO4bjOr+H5edFbxzb/orOJOoeis4rai6KziHqTkrCZuWIrOKu5uis4qboWKzurIN5U4C+o2szryTebIN5kj32SOfJM58k2TI980OfJNkyPfNDnyTSXOYLvNrI580+TIN02OfNPkyDdNjnxTcuSbkiPflBz5puTIN5U4Y+82szryEsmRl0iOvERy5CVmR15iduQlZkdeYnbkJWbt/TW+PJ4VLX65/tfytb9a4/pc/jjYW9f/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", "brillig_names": ["compute_note_hash_and_optionally_a_nullifier"] }, { "name": "set_balance", "is_unconstrained": true, "custom_attributes": ["aztec(public)"], "abi": { "error_types": {}, "parameters": [{ "name": "inputs", "type": { "fields": [{ "name": "calldata_length", "type": { "kind": "field" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }], "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs" }, "visibility": "private" }, { "name": "creditor", "type": { "fields": [{ "name": "inner", "type": { "kind": "field" } }], "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress" }, "visibility": "private" }, { "name": "debtor", "type": { "fields": [{ "name": "inner", "type": { "kind": "field" } }], "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress" }, "visibility": "private" }, { "name": "amount", "type": { "kind": "field" }, "visibility": "private" }], "return_type": null }, "bytecode": "H4sIAAAAAAAC/41US24UMRAtf9pT/vS4OxmhiCC2SEMy2fQIpCxYQACxgBNwAyRuwDUQEhyAHWLPAciGPQdghRASaxCv3N3TMwMSjGKny36uevWq7BUZpc/I8EOiFZmKMZG/Qfh5DMbf3WNy+HdPxmMav/ChMdQxqXFpDSyZtVgW8wVVmO+Tw/yAZidAZzkmoYiulRBlDudjuIARV6SUD6SiDzeJrlC4UDT8rhdgIFf5iL2rFKe9QhyTTh2cEKwkayp0FNOKnK47XSesJyB0lQQ6f2SHyInKIZoDSQERUhAiNBci84xgJ5R3guk8xsklTgszi9kWs+kot50OGDmCQoutVsNqAPS8pPMA1b0VrIH7T2SXdKdTkQEWPxkBVAY/oOQrljIUkixlkNqUMZWhX+px8mn7T8kxliNxGFtH4ii5BYkne4Lu51i4QcaRn3ZZUM1Gxjx4bKBgDgzxeC6VerrvGJIIRQP0oFYfpylmjTgNxMMQPbjBVqNh1QD6tKRnEC/5Gp7fU72k551ilJ0n3cRZKrpt6ZGKCGkYWyKUpR5XGuF/pUb8F2j0PzKzU2agbyP6TQhFbGoXS5NuJItDhUpDVqMsVTlskVOFjjQO5yqsV0DoWO16qMb05GKEWDpWrs7L7asD3SDUK+hW+4TNNwQZX5/2mdZ94q5KceAspoHX4QYl7vRM3gblEjw4aZa3ZCf3IndtO2X59iiYZFwbnmNm6YF32z2AxIQO6lZv1Vc1caoCFl1u2lsCb8WW8IcInw4XcPeBFpO7NXJgE4vqmis8aOg8K0/OV7w+jlo5eyBXMC1wBRdC1zSglhqh9nGHmm6l5zYFO0BFG+k5XE4rjbkhm6fWErLpb2S5kP28R9b2ZPM/yPJIlk0GWc6i+5dt3UFWXhcDjNEGZA3eHXldAPzG1ZK+w6Vht6Rfa6HqFKIRo3XOygfXcMts2Z+hrRUH4RLYs4eDn+yVxAYgrGV5JqYrpuYZBzEZOSDgD0Q4XdPR5dHlbzifO0FUBgAA", "debug_symbols": "5Z3dbts4EIXfxde54Ax/J6+yWBRJmxYGDKdI3AUWQd59aa9FO5ZKFrblzilvEjsZit+RLR5q+KO3xZenxx/fPi3XX59fF/d/vS1Wz58fNsvndX739n63eHxZrlbLb5+O/7ww2x/kd/Gv3x/W27evm4eXzeLe3C2e1l/y71z263L1tLiP/H43ChMb94HiYwklbydiHZvhqPmllGjxE8FBmPbBIVdyHPz33YLCBcxkyO0jyVh3Q+p4yZmOdjjT0jrTxEkGhdb5OnMiPwQnNnzKnK7CnE/0R+jtoWW2Q7OZ79A036F56tAUTSkUmeoVOBuGYGcj1T/5aCLvg6NJp99WtpM0QehAY49ptmXcGWX8GWXC9JlKpUwyvvFRUGm5wtEnEWTqevLD50uSSiyLmzqud6Y0iXJoL6yR6ejyhTi69jjuVMYuVKYuVEoPKq3pQiV1oZK7UGm7UOm6UOm7UNlF38d20fexl/d9yDguFRzRTOv8xfuUfDsw3Bjwof7MtYMWQGhnEKEJEZoRoS0itGtCcysXRmZoJIksf6hhHJ1bOz+ktwyFenbBRz8cOr9MJ9kF54HZAzB7BGZPwOyCy+4NMDsBszMwuwVmB/ZVD+yrHthXvfL2PbnCnvwJe9B9raYyAJtfhlN23ddqnV33tVpn132t1tlv3wdOprDbxqist8NwvHfHqahdwigkXHQBQffhFD0yLrrFRW83MfYD+rZMPKNMOqPM9Jc5xVDSyKY1F0R/ejqZLlRSFyq5C5W2C5WuC5W+C5WhC5WxC5WpC5WX931uP1YmBhGaEKEZEbrdbyD7+9IZ1dSjOGB2D8wegNkjMHsCZhdc9twVQIYnZHhGhgf21twTQYYHdlcyypv52ogqke7Wpjo8RqS7tWnA625tGvC6W5sG/O1bm2uNTRIFYPYIwj4e4iM2wOwEzN5uaEaLron9OYUmryw2JXfJ1JpZz6msU2eh03QkTS+TvmoNafYaZO4appfmXrUGmr0Gnr0GO3sNbvYa/Ow1TF/TuQdQanD44xw0vQbxz5OZ+pApXcicXuj458mkPmRyHzJtHzJdHzJ9HzL76AW5y3tBtx/PJ5cgqQWR2htI6rbn+MZue/m2vcwRtxQ/VDGODtYNe/MFGxq7MgbywwkJu00eD8E7+KgbXoZ2LbAZbYPpk274xDV4UQ3PRgo8jcbUgkGGJ2R4RobX3VQ24B0yvEeGD8jwuh22Aa/bYRvwyA4bkR026nbY/LU+wEs9WJwblIoTM1Kq245/rnQHr/zOpQ6v244b8LrtuAGPPKEuKp84XYVPyidO1+GVT5yuwyufylgen+KTG6UakvKpjMw1eKd8KqMc4FOjL2EP2XQbR7m4pHuWdX3SZtK9iKkBr3sVUwNetx034HXbcR1edNtxAx55ZYEgryxQvka4Aa/djqvwyA6rfJlwAx7ZYZUvFG7AAzssK18p3IAHdlhWvlK4AQ/ssGyAHZaN8scC1JI8bJQ/F6AOD7xxNJPyJwPU4XU/GqCaG2TS/WyAam6QSfuG49fKDfJPFnRDbJPNBLw/ORPwBuVMuu24Aa/bjhvwuu24Ds+67bgBr9yO6/DK7bgOD/z8D2Zkh2Vkh2Vkh2Vkh2Vkh2Vkh7XIDmuRHdYiO6yFddj3/O6fh5flw+Pq6TWX2f7zx/rzZvm83r/d/Pv9///k4P8A", "brillig_names": ["set_balance"], "assert_messages": { "150": "Storage slot 0 not allowed. Storage slots must start from 1.", "92": "Storage slot 0 not allowed. Storage slots must start from 1.", "125": "Debtor is not in group", "78": "Creditor is not in group", "43": "Storage slot 0 not allowed. Storage slots must start from 1.", "168": "Array index out of bounds", "21": "Not initialized", "229": "attempt to add with overflow", "200": "attempt to add with overflow", "175": "attempt to add with overflow", "25": "cannot adjust someone elses balances", "188": "Array index out of bounds", "217": "Array index out of bounds" } }, { "name": "balance", "is_unconstrained": true, "custom_attributes": ["aztec(public)", "aztec(view)"], "abi": { "error_types": {}, "parameters": [{ "name": "inputs", "type": { "fields": [{ "name": "calldata_length", "type": { "kind": "field" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }], "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs" }, "visibility": "private" }, { "name": "creditor", "type": { "fields": [{ "name": "inner", "type": { "kind": "field" } }], "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress" }, "visibility": "private" }, { "name": "debtor", "type": { "fields": [{ "name": "inner", "type": { "kind": "field" } }], "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress" }, "visibility": "private" }], "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" } }, "bytecode": "H4sIAAAAAAAC/1VSu04kMRAsu9uetr1zl504cflJe8du4hEBIY9FBIicHyBCCIkYvo+votraFTCSPW53uara7Q0kxC3EroENRCdOsL/gZxwTf+fHyPxd+LjFYcVF5AjHCIethVjI4pFyvkTifIX8n7ifCyiy82O283N/hsSYy9lBrnDUDUIoFaEW+wf8IlHA/vNU5eZv6NdNiaUDSgUyMAy1Q0uPiXxSmIy5eF0+xXajeyVX9HXbIEvyXCZNdZo8aLSjZtKwfMlMRsvfGTIGfjBAK3JWtw9z+5bodEH67pTWXFh4ziXaQbGNMFGx9agc1TqsMdUio0Rgmda4qJCpOPMd0hq7HmwiLhGXYupheCWAKz/PeylyQhCJTZiSKD2IjpZ6d6lM11JPsS9F3MZqRZLVTJV7zJ/+2cNk0nhGES3x2SCYensf2ensrWNF5KjT3KPM4w7dj6YfnJOQ8AHySbiv0jEatcfGG09eJYFPxvqeySuW13hbvGE5uF/Hb8fCZj4qM7Wy5a0Hq26oWrFCglcrhJsD6uLbk4d5hNEmqx4aC7E1XqhwsuDo/ej9Ax+7YEsSAwAA", "debug_symbols": "5ZvdbuJADIXfJddc2J4/m1dZrSpooUJCUAFdaYV49w1sMkkhO7RipxorN20Ch/HnSPHxmHCsXhbz99en1Wa53VfTH8dqvX2eHVbbTX12PE2q+W61Xq9en/ovV3D+g+6i37/NNufT/WG2O1RTmFSLzUv9v/7scrVeVNNAp8mNTExohOJClKIzA1pL0K5aH0pUixsQeyFsxL4O0hf/nFToH2BGQNsoEYz9RurwyJUOpr3Scu9KI7G0GRrr0syMrhUzAV0z839hri/0R+jz0pJtaYJ8S2O+penTS5/V5ktq+yX1YE1AgvZuR/KUTpU4UCMmwU5M4RLA5w4Qcgfg3AEkcwADuQNg7gCUO4DJHcDmDpD7Tjb/uJPjZ5B6fjVcFTE2Eb5XFL0MWZtraxYKdyhih9Z1FmJ3Ip11G5BhdazNcJNlGEWWPIosZQxZWhhFljiKLGkUWZpRZGlHkaUbRZaj6H3s470Pgo1i6NEM5/nJzXQAboSBuhkHBr5As0ZoUQjtQCM0aoQmjdB3Xd3APWjsdqto6EOEW3Vd7Vw7gwX0p+Tw0wXXLl0fcl98ZreK2Z1idq+YPShmZ8Xsopfdg2J2VMxOitkV+6pX7Ktesa/6wus728jO7oo9lF1nOD4lUB/6a/ay60yavew6k2Yvu86k2b+/zjBEdoNpdhTr4yzKud4w6jIyCl4xPBfejaWqJBfejSXZC+/GkuyFd2NJ9sKrZHzE0LG9fqSOy+7GmCjBXvaUg0E6dk6LxXTfNphgrhMteySStGEuu2VOs5c9EkmyS9kmnGZXvFURxVsVUbxVkcJNOMleuAkn2Us34RS7Yl8Vxb4qin0VQbGxIih2VgTF1oqg2FsRFJsrgmJ3RVBsr3VcrfCn+uzXbLeazdeL5gegy/fNc+/3oIffb3/fqcV/AA==", "brillig_names": ["balance"], "assert_messages": { "24": "Function balance can only be called statically", "21": "Not initialized", "90": "Array index out of bounds", "103": "attempt to add with overflow", "52": "Storage slot 0 not allowed. Storage slots must start from 1." } }], "outputs": { "globals": { "notes": [{ "fields": [{ "kind": "integer", "sign": false, "value": "000000000000000000000000000000000000000000000000000000006827b230" }, { "kind": "string", "value": "AddressNote" }], "kind": "tuple" }, { "fields": [{ "kind": "integer", "sign": false, "value": "0000000000000000000000000000000000000000000000000000000071421477" }, { "kind": "string", "value": "ValueNote" }], "kind": "tuple" }], "storage": [{ "fields": [{ "name": "admin", "value": { "fields": [{ "name": "slot", "value": { "kind": "integer", "sign": false, "value": "0000000000000000000000000000000000000000000000000000000000000001" } }], "kind": "struct" } }, { "name": "group_members", "value": { "fields": [{ "name": "slot", "value": { "kind": "integer", "sign": false, "value": "0000000000000000000000000000000000000000000000000000000000000002" } }], "kind": "struct" } }, { "name": "group_balances", "value": { "fields": [{ "name": "slot", "value": { "kind": "integer", "sign": false, "value": "0000000000000000000000000000000000000000000000000000000000000003" } }], "kind": "struct" } }], "kind": "struct" }] }, "structs": { "functions": [{ "fields": [{ "name": "parameters", "type": { "fields": [{ "name": "creditor", "type": { "fields": [{ "name": "inner", "type": { "kind": "field" } }], "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress" } }, { "name": "debtor", "type": { "fields": [{ "name": "inner", "type": { "kind": "field" } }], "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress" } }, { "name": "amount", "type": { "kind": "field" } }], "kind": "struct", "path": "PublicGroups::set_balance_parameters" } }], "kind": "struct", "path": "PublicGroups::set_balance_abi" }, { "fields": [{ "name": "parameters", "type": { "fields": [{ "name": "admin", "type": { "fields": [{ "name": "inner", "type": { "kind": "field" } }], "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress" } }], "kind": "struct", "path": "PublicGroups::constructor_parameters" } }], "kind": "struct", "path": "PublicGroups::constructor_abi" }, { "fields": [{ "name": "parameters", "type": { "fields": [{ "name": "group_member", "type": { "fields": [{ "name": "inner", "type": { "kind": "field" } }], "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress" } }], "kind": "struct", "path": "PublicGroups::in_group_parameters" } }, { "name": "return_type", "type": { "kind": "boolean" } }], "kind": "struct", "path": "PublicGroups::in_group_abi" }, { "fields": [{ "name": "parameters", "type": { "fields": [{ "name": "creditor", "type": { "fields": [{ "name": "inner", "type": { "kind": "field" } }], "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress" } }, { "name": "debtor", "type": { "fields": [{ "name": "inner", "type": { "kind": "field" } }], "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress" } }], "kind": "struct", "path": "PublicGroups::balance_parameters" } }, { "name": "return_type", "type": { "kind": "field" } }], "kind": "struct", "path": "PublicGroups::balance_abi" }, { "fields": [{ "name": "parameters", "type": { "fields": [{ "name": "member", "type": { "fields": [{ "name": "inner", "type": { "kind": "field" } }], "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress" } }, { "name": "approve", "type": { "kind": "boolean" } }], "kind": "struct", "path": "PublicGroups::add_to_group_parameters" } }], "kind": "struct", "path": "PublicGroups::add_to_group_abi" }, { "fields": [{ "name": "return_type", "type": { "kind": "field" } }], "kind": "struct", "path": "PublicGroups::admin_abi" }] } }, "file_map": { "123": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr", "source": "use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n" }, "136": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr", "source": "use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n" }, "153": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/initializer.nr", "source": "use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n" }, "154": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/hash.nr", "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    point::Point, traits::Hash, hash::{sha256_to_field, poseidon2_hash_with_separator}\n};\nuse crate::oracle::logs_traits::ToBytesForUnencryptedLog;\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (n as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        poseidon2_hash_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x1cce4dbf69f14c44865919991ee1057922e34d7310ba237d71759aa422621ca9);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n" }, "160": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr", "source": "use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{\n    public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys,\n    constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}\n},\n    state_vars::{\n    shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter,\n    public_mutable::PublicMutable, map::Map\n}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n" }, "169": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr", "source": "use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n\n" }, "178": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr", "source": "use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n" }, "219": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr", "source": "use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n" }, "22": { "path": "std/embedded_curve_ops.nr", "source": "use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n" }, "228": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr", "source": "use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n" }, "23": { "path": "std/field/bn254.nr", "source": "use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n" }, "24": { "path": "std/field/mod.nr", "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n" }, "27": { "path": "std/hash/mod.nr", "source": "mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n" }, "291": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr", "source": "struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n" }, "293": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr", "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n" }, "294": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr", "source": "use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n" }, "296": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr", "source": "use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n" }, "297": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr", "source": "use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n" }, "300": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr", "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n" }, "301": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr", "source": "use crate::{\n    crate::address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n" }, "309": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr", "source": "use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n" }, "32": { "path": "std/hash/poseidon2.nr", "source": "use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n" }, "341": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/value-note/src/value_note.nr", "source": "use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH}\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul, hash::from_field_unsafe};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.value);\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> ValueNoteHidingPoint {\n        ValueNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    /// The following method needed to be implemented because the note is passed as an argument to a contract function\n    /// --> the serialize method is called by aztec-nr when computing an arguments hash.\n    /// Note that when the note is about to be encrypted and emitted as a log the to_be_bytes function auto-implemented\n    /// by aztec macros is called instead.\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n\nstruct ValueNoteHidingPoint {\n  inner: Point\n}\n\nimpl ValueNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_value(&mut self, value: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(value.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for ValueNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n" }, "55": { "path": "std/option.nr", "source": "use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n" }, "72": { "path": "/Users/niallcheetham/Dev/aztec/publicgroups/PublicGroupsRoot/publicgroups/src/main.nr", "source": "// mod test;\n\n//this will be a little test to make public groups in noir\n\ncontract PublicGroups {\n\n    use dep::aztec::{prelude::{Map, PublicMutable, AztecAddress}};\n    use dep::std::hash::pedersen_hash;\n\n    #[aztec(storage)]\n    struct Storage {\n        admin: PublicMutable<AztecAddress>,\n        group_members: Map<AztecAddress, PublicMutable<bool>>,\n        group_balances: Map<Field, PublicMutable<Field>>,\n    }\n\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.group_members.at(admin).write(true);\n    }\n\n\n    //helper functions to read variables when testing\n\n    //read the admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    //read the group members\n    #[aztec(public)]\n    #[aztec(view)]\n    fn in_group(group_member: AztecAddress) -> bool {\n        storage.group_members.at(group_member).read()\n    }\n\n    //read the balance between two addresses\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance(creditor: AztecAddress, debtor: AztecAddress) -> Field {\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        storage.group_balances.at(key).read()\n    }\n\n\n    //functional methods\n\n    #[aztec(public)]\n    fn add_to_group(member: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        storage.group_members.at(member).write(approve)\n    }\n\n    #[aztec(public)]\n    fn set_balance(creditor: AztecAddress, debtor: AztecAddress, amount: Field) {\n        assert(creditor == context.msg_sender(), \"cannot adjust someone elses balances\");\n        assert(storage.group_members.at(creditor).read() == true, \"Creditor is not in group\");\n        assert(storage.group_members.at(debtor).read() == true, \"Debtor is not in group\");\n\n        //cant store the addresses in a tuple in storage so hash them together\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        storage.group_balances.at(key).write(amount);\n    }\n}\n" }, "74": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/address-note/src/address_note.nr", "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: Field = 3;\n// ADDRESS_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[aztec(note)]\nstruct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n" }, "80": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/note/utils.nr", "source": "use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n" }, "95": { "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr", "source": "use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\nuse crate::hash::ArgsHasher;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    args_hash: Option<Field>\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs, args_hash: Option::none() }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            let mut hasher = ArgsHasher::new();\n\n            // TODO: this should be replaced with the compile-time calldata size.\n            for i in 0..self.inputs.calldata_length as u32 {\n                let argn: [Field; 1] = calldata_copy((2 + i) as u32, 1);\n                hasher.add(argn[0]);\n            }\n\n            self.args_hash = Option::some(hasher.hash());\n        }\n\n        self.args_hash.unwrap()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n" } } }
