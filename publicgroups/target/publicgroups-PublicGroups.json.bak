{"noir_version":"0.33.0+cb20e078dd909656110d133339b2b425e6c3ebb0","name":"PublicGroups","functions":[{"name":"add_to_group","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"member","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"approve","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VazY4bRRBu78zYHu+Obf4kkDjMBY7R2KxEDkg4Igm38BOkiKOJxzDI3onG402CgAeAG4gbnEHiAeAG4ghnkDggJK4oeYa4vVXrb8o93vVPR5uWVt3TXV31VXV1dXV7K+qkOLO/CrU9ql21XJimR3W0XenskFdkE2flCcG594TgdGzgrIDTugK8NoyjlsuBUFCXl6DdovpGmofJUZIn/VHySTxA8teh/QzVt/ujUZyFySQ8mk3sD8bJEU55G9qvUX0zT7P+h3E4Gc1mRCfzRqP0bjy4FOLYJBxPJ3k4yftZHg6zdBx2LiHvKbRfpLqf5/H4Th7m6QzLILyb5B+F6XGcDWf8ce4X0H6B6itZ1r8/030Q3wvTaR6mw/CDdHo0mODEr7YQ+u2mQr/fQuhPmwr9ZQuhv28q9M81hZ6680OqfXWyBXThbdKj72i70vEB3E55Xz58VfOu2cF9qHnX7fCONOY3iDnjZ1k6DF2lD64r9KfHrlPfdTEWqEUIY96BWoS6q9DHZ/g16KuqIt869eui49abDJCKT38W7NMJ1MIeCmRgcQUWXdqqaEcecy4ITseA0wWc7gXBWYZpl3lOmQ0u2lohJmVJf+av0402tfvH47fu3E4H8ZXBIIsnhYCPcWlVOS8/fw1+z0t+N6ajUTJM4uzavWSSF/g2DHw53dpTy/ogFhxXYtwXvHr0HW1X5nk8+uQe6MAyPaB5meqnS3Ci/rv2ZV/IW+XLqIOlM60bgJzzYKoDNlt2wvVk+SyL/Uvj3heY2tCHMdsHzGxPS9gjjasm5Okz+hDkoa+6Bnof9Ni1bXEf/Ab4LlO7BXhwv/KVSgnMmH8GguZA6NUCnkx7oBbXsdPYdDOeZc4ZuiGmi2cVFuuBuBr08XiP6rIwUINvpo22K11fFW+nO1zaV9YNL7g8tlJCk+vIoyJQRXfQpQ19uPbSxQLBC+d5K+ZJDPq7accG3afIxoyB5TSEzqgr+immVviMVwF6F+YxzTtUm/zbgTlV6Md0C8PXe4DBB5mugR733Y/A4xaMs8z3Yfwzalu8Hq6dTmIorNrB1MUj4zyYGEfDop0qqugXppCPV1KmbUOf6dpUg7nyWNY8hqAP+rarzMc4YuztRvdDD2R/A9g+pjYekZiWeYCl7IiU1zVP6NRSy9crB+ikPEcVY4aCOdLmPMc39PXoO9qudKQdvBIcGHuQxoOaaY6pLotjJv3L/Os+YJBpmKRHXJ8Dj0+hzTFrXxVtLs9hxMY+i7SWnhC6mz4hNJS1K0fHtA9YFsYWR2BqQx/GZVtPD5i7sD/yujrQzzRfUm3yU1MeJHWuqOKTBabQLLelinFBEc1z1F6k0Cc/LtzKkjxWouAdXQYtOS6VkPQMTN5XdKkKGtPm/ppqk9ECw1zcxKZAjMFSbkLTIcq02ojPUlsa8d24X/htCBNLLBWDLEljMZHooANJh0V9meY7qsts74i37nmgqlvB3tVs/wbZpwktyJObQ/qrKWnB90Bd2mp57THZ4Hkmv0YfRBo8gJjmB6pNtjW9oQYGfpgQOTAuAzpilwHDV0U9d324rHPhxGTH5oWzLEaZLpxMixdHfNcOLOJsAgY8EBAb0/xMddnh0jxDZ9MlmOew3JZa2AMv5BsfLuiYnmFcKiEXjoHhJsTNgTR4uDDNr1SXBTg5F2+6mInjqc8bDHVDR9GlR3W0XZn/I01TYFaAYZ1Dy/Q/EfK7WUJjeyPwAyBvBLwlcj/T/EH1WYdWIbt+TIfW6YYGeS3Ah5tu1cbkOWwHDE64jmWPsrhf2A5VQYOZLdP8RXXZocX7gHUIDPzwsVvrUSXmDtikVl9gdoFmDzAxzT/A91+Q6wm+evyBYZzLylsP0c5/pLLjK5Hm16gv9HNBlgv6M00DcHjw/T/os18v6sO2YL7zGEbt/Xr5PE/MawNNHeb5Yp4v1k2vwX/UbqjiPthlzMC11r7+CIWXJobxKAAA","debug_symbols":"5Z3hTtswEMffpZ/54Dvb5zteZZqmssFUqSoTsEkT4t2Xdo0b2mDXpZQ75QukcHZ+Fzv523eO+zz7cXvz++e3xeru/nF2/eV5trz/Pn9a3K+6T88vV7Obh8Vyufj5bfjnmVv/AL+xf/w1X60/Pj7NH55m1+5qdrv60f3uyt4tlrez6xRevl7NIDRZxyZrarJOTdbcZC0t1uiarKHJGpusm9oSm9oSm9oSm9oSm9oSm9oSm9rSN7WlP74trw7MxKetocSUTSHGEduArq+1O5RsLWnEmARha0zdSYbGa2Z8BzM4CFtLcD5ckNq/50on319pqV1pQJbeQx9imZkh9saMDveZw1mYuwv9Gnpddfy4qunjqk4fV/XoMwGIciFiqPVtivkMsqMBdiPWUaS3JgdU7icxxf5e7w55v5+IXfbgDLODYXY0zO4NswfD7NEwOxlmT4bZDetqVP6M5JDZOe6z6+7vnAf23SHts1++v7PL7B7K7F19eYAPbtdnvPMbeLYML4bh6Y2hJPe3OCQXy/DBZ0+DTxWc5BJujZPj/QknVQeHaeDC/3AA4Qll/AllwmiZFDCXIarMpiAHH2gwmVpfs8OKY9/GIDsUFBqrNwaXoxqym/J7gHHr3NcG02eUjZdxEl7SJLxMk/CSJ+GlTMHL5CbhJUzCS5yEl34SXoZJeDmJsU+axNgnvX/sA25n7AY0434emVAhon7qxv7VPG8NzRahxSA0O4vQ9XED11LJGHI0AFN8dYYRGr8LNHippGW99Jnk4MLgbtzcjhwujh58RqcKOkHsObpDvxeU4PEOzjEHCzjxeeM7Z4vGijPMDobZ0TC7N8weDLNHw+xkmD0ZZmfD7IZ1FZzyB3wpzdmdWDV8Mc8J7vK3a0u6zaecOfNM++PgLgNnml4s04MzQy/+kB5M06Np+vqQmMOQflMonFIonlKITimUTin0xuMLKReK+GkhCECf4wk4WEbeNyPCxenPFoUAJN3w0t9BhC4dwCfd8IwleFYNj04yPBwMVFEMw3tnGV7306YCj5bhvWX4YBk+WobXrbAVeN0KW4G3rLDessIGywobLCts0K2wQLyDr7xFLCFzSBjMzHtPdcvx255u4HXLcQVetxxX4JVPeMvwypMbxfxA1L1qgPMeDpHDwWw96l42wIgleN1pJc6K1sFzRRT8bjGfTwfhrKh7lUE5BxWDZXjd6wwq8JZTl1H3SoMKvO6lBhV43XJchiflclyGVy7HZXjtclyEt6ywZFlhybLCkmWFJcsKS5YVNl3+5YTzpaePeFfxU+GL6ekjXkH8TPhyFPSINwsVw0fL8GQZPlmGZ8vwYhj+iNf+FMPrVtgKvG6FrcBbVljlr15W4C0rLFtWWNatsGdMT7NuOS7nGVm3HJfhRbccV+CVT3jL8MHuLp0gurfULaenRfkeo8X0tOjeVLcCr3tX3TPm1kX33vbFQCI63ZvbV+B1725fgde9dXMFXvf+9hV43XJcgVcux2V4w1t+o1Mux2V47XJchLessGBZYcGywoJlhQXLCgtmFfal+/Rn/rCY3yxvt98refd79X3wNZNPf3/9/09n/A8=","brillig_names":["add_to_group"]},{"name":"remove_from_group","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"member","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"approve","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"5Z3bbuMgEIbfxde9YAYYmL7KarVKtwdFitKqh5VWVd99STYmbuJCSNN0Rr5pnXbA3xjsn2Ewee2ub65e7n7Nl7f3T93lj9ducf979jy/X6ZPr28X3dXjfLGY3/0a/rkzqx9g1/ZPD7Pl6uPT8+zxubs0F93N8jr9TmVv54ub7jK4t58XHbgma99kTU3Wock6NllzizWaJmtossYm66a2xKa2xKa2xKa2xKa2xKa2xKa2tE1taQ9vy4s9M7ZhY8g+ZFPwfsTWoelrTYecrTmMGBMjbIwpnWRovGLGTzCDAbexBGPdGantZ650sP2V5tqVBozce2idLzNH8L1xRIO7zO4kzOlCv4deVe2/rmr6uqrD11U9+kxI/c9vCqXmsbW+TT6fgbc0EM2ItWfurckAlfuJD76/19Nh3O0nrJfdGcXsoJgdFbNbxexOMbtXzE6K2YNidsW66oU/I6PL7NHvssvu7zEP7NMh7bKfv79Hk9ktlNlTfXmAD2bbZ6yxa/ioGZ4Vw9MHQ0nkDO9CGd5Z6oMEZ0MFJ5iAG+Ng4m7ASfXBod+dDiA8oow9oowbL5MfKDi8vOPRFOTJBxoEU6trtt9uvm9j4G21yDRWr3cmz2rwNuS3AOPWua8NwmfktZd+El7SJLwMk/AyTsJLnoKXwUzCS5iElzgJL+0kvHST8HISY58wibFP+PzYB4zDbVDGFT8PTKgQUR+6RfsuzltBR43QrBA6Go3Q9XEDYgUaXZ4NwODfnWGExm4nGixX0rKW+0yyM25wN65vx+jOju5sRqcKOoHvmzId2p1JiTjewSFP3SFiNYP/TbOxbBSzg2J2VMxuFbM7xexeMTspZg+K2aNidsW6Ckb4A76U5kwnFg1fzHOCOf/t2pJus6HvNmAj7Y6DU1Shmp4104NRQ892nx5U06Nq+gOGxDSkXxdyxxTyxxSiYwqFYwp98PiimON4dt82BQFo85QMDpaR982IcHb6k81CAJJseO7vIEIT9uCDbPiIJfgoGh4NZ3jYG6giK4a3RjO87KdNBR41w1vN8E4zvNcML1thK/CyFbYCr1lhrWaFdZoV1mlWWCdbYbccCb7yFjG7zMFuEJn3nsqW4489XcPLluMKvGw5rsALD3jL8MKTG8X8gJe9aiDmPRx8dHvRupe9bCAiluBlp5ViVrQEHyuiYLeL+WzYm87yslcZlHNQ3mmGl73OoAKvOXXpZa80qMDLXmpQgZctx2V4Ei7HZXjhclyGly7HRXjNCkuaFZY0KyxpVljSrLCkWWHD+V9OOF16+oB3Fb8VvpiePuAVxO+EL8+CHvBmoWB4rxmeNMMHzfBRMzwrhj/gtT/B8LIVtgIvW2Er8JoVVvirlxV4zQobNStslK2wJ0xPR9lyXM4zRtlyXIZn2XJcgRce8Jbhnd5dOoFlb6lbTk+z8D1Gi+lplr2pbgVe9q66J8yts+y97YsTiYlSM7zs3e0r8LK3bq7Ay97fvgIvW44r8MLluAyveMtvNMLluAwvXY6L8JoVFjQrLGhWWNCssKBZYUGtwr6lT39mj/PZ1eJm872Sty/L34OvmXz++/D/P8n4Hw==","brillig_names":["remove_from_group"]},{"name":"set_balance","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"creditor","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debtor","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["set_balance"]},{"name":"admin","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/7VX32/TMBB22qR1U6KVXxJIPPgBiReE0gkNHjvG9oDQJsELgqesSSFSmkypu6389cSZb/li0g3U5KTorvH5u8/n88W12I30isfStgPvTCGfmdb+bjJtEcvvkqfVIk8LePaIrI0vjEWg3QNfHH8I9p7Wp5kUcRrLOEji31GI7k/Afq31yTqdyzhLRRAu41TMg1RkabIR51FhJ0kUipUMZKzsDWIdgP1c68M8DzZF8DC6FtlaimwhzrN1Gq5w4gewX2gdSBktL6SQWUEjFFex/CWyyyhfJNnV7YJ/aD1iVcIoiTP9299NpiMg1yr2+7cHCtvphve+wh50g+0PC4wjfoNF/ClWv3g+6jHSln48Pc5gvseqQiZ/pcasGj/mFbaSx/COauFB8Uy0HVwuzy7mWRgdhmEerWrFhjm5S/4Vb/gfeM9MvNN1ksSLOMqPr+OVrOHyBlxl91i9OQwauDR1bCVmTSi/mf7t7yZlZ6T4tsbmBkcHfB4Z2uSJ62+x604dVtXb03s4YINts6d4sD4GMVDsBrvDM73vGTHv40Q83A7zZLF6fdvs7w+k4j00OI30QzJrh48/gViEr95xIz8Yv+3eq9brGBzUul9CvKGRL9Mfz+EbwHil7T0Yx3No7oXZbyyIRT64J4TNgYcSD8Y5vOsbc8dbuPVZvccwmIc1O9Pa302mDLgxiEEcVK+nm9Vtr/8qszz4GX2JgtoNrOkSZ/7ub/HpsB+UZ89lVU6xjjDX5PNO66ZeWu6l3iw8PzbvhPu+gj3B2MQX4rnAzwYfrGWz3jEfSibgg2cf7wRt74n5XSAuGJN4DgwfG/iTz5HWTfuGvY3y4zXgYf9R53NA9zXI95BXc2zw6QEn8vkEuJ8xroGrxr83jJPc+U3VvmWv7qYOy394LtyTbYhlw/rJxwUeDvz+BusZ8/p6KBeEW/ZXbY/59nmOMW8CPhzmjYx5I2Pf1B6cadtl9TPWZu3jXqvvwB9bvN5ashAAAA==","debug_symbols":"1ZrfboIwFMbfpddc9H/P8VWWxaCiISFoFJcsxndfcVAZI3XGaXpuoIWPw68N7XfacGKrYnHczMt6vT2w2duJVdtl3pTb2tdO54wt9mVVlZv58DLj7UGIi/6wy+u2emjyfcNmPGNFvfJn/+y6rAo2c/qc/ZKhcp0QjQtSYcyEVkveR/VFDGp0E2KLUnRi618yFL9nTMgHmAUXulMKrvQLqdUjPe1U39N4q6eFBOxbqLSJM4MwvRgkl2Nm/S/MvqN/QrehzfNC2+eFds8LDX8O3arxHrXkd6kn5wTAXo8cbo0xa0JL8RpeAJ9QG8Rebbmw8e/VONPPOb4Io+9VSrLkiiy5JktuyJJbsuSOLDmQJUeq5IqTJSfroYqsh6qkZ0XQgRzMmDzlEQphCeSLdkSuXz1CgQdyJeLkPl5YCIkBh+Lqgi7ooku66GQHqU45dYGwFWNAj7cedMqpC0gZIU96YoyRm5RTF+B4JYe4GJUOzMqpcTNTznOizmVSznPi5CnvFcTJNVnylPcK4uQpG26cPGnDjZInbbhRcrIrEZu24cbIyXqoJeuhlqyHWrIeasl6qCXroZaoh5597SPfl/miKrqfGNbHejn4p6H53H3f8eIv","brillig_names":["admin"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"member_count","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/7VX32/TMBB22qRNW6KVXxJIPPgBidd0TAh46gSdxAObNB4RoLRxIVKaTKm7rfz1xJlv+WLSDdTkpOgu8fm7z2f77FjsRjr5Y2nbgW+mkM9Ua38/mTSI5bfJ02qQpwU8O0TWxg/GINDugC+2PwT7QOvTVPIoiWQUxNFvEaL7E7Bfa32ySRYyShO+Equ5yH4s0k0i+SJIeJrEWz4XuR3HIuRrGchI2VuEfAf2c62PsyzY5hxCcc3TjeTpks9z1HCNHWdgv9A6kFKsLiSXKQ/CkF9F8hdPL0W2jNOr23F/13rAyrxRLqf63d9PJgMg1yj226M3Cttph/ehwu61g+33c4wP7g0W8adY3fz5qNtIW/rxdDuD/h4r1zP5KzViZfvMLbGVPIZvtBYe5M9Y28Hl6uxikYbiOAwzsa4sNszJXfKveP3/wHtm4p1u4jhaRiKbXUdrWcF1a3CV3WHVGtGr4VJXuJWYa0L5TfW7v58UBZLi2xrbNTg64PPI0CZPHH+DxXfisHK9Pb2HA9bZJmuKB+NjEAPFrrFb3NOHnhHzPk7EY9hinixWXd82+/ucVLz7BqeBfkimzfDxxxCL8NU318gPxm+69qrxOgYHNe6XEK9v5Mv0x304AYxX2j6AdtyH5lyY9caCWOSDc0LYLvBQ0t0Rz9Ft1LcP2F3wHRh9PPhGPnj2UNtox1i7rFqzGPTDPTDV2t9PjhhwYxCDOKizgy5st2fHF5lmwU9xLoLKxa7ubmi+d3f4tFhfir08ZGVOcV1irsnnvdZ1tbmYSz1ZuB9ttxXuhwr2E8YmvhBvCPxs8MG9Ye4fzIeSMfhgLcE7RtNzYp4zxAVjEs+e4WMDf/I50bpu3rBWUn68GjysZ2p/9uj+B/nuu2UfG3w6wIl8PgPuGcY1cFX7t5p2kjvPaO1b1P521mHx4ziEe7cNsWwYP/kMgYcD719hPCO3Oh7KBeEW9VrbI3d3P8foNwYfF/oNjH4DY97UHJxre8iqe6zJtY9zrc6BP/U5UxQJEQAA","debug_symbols":"1ZrdbsIwDIXfJddcxEmc2LzKNE1lA1SpKoifSRPi3RcYDaygMMRA8Q00cOp+iZIcx+pGfYxH6+lb3U5mSzV82ahm9l6t6lkbW5vtQI0WddPU07fTn5XefQDs9ct51e6ay1W1WKmhHqhx+xG/472TuhmrYXDbwZmMbTgIGUOSAuIFrTO6ixovOak5XBB7NnAQ+/iQU/HrQIG5gxk0uIMStHVPpLb3jHSw3UjztZEGQ9z10DrMMxNgJyajTZ/Z/QtzHOjf0LvQ+LjQ/nGhw+NC059D79R8i9rom9QX9wQwaXaDcf7aKvOY+srHBwDpC2pk7tReg8/PWAzY7Trxknoz1hjB7FYwuxPMjoLZvWD2IJidBLOzXHarBbML9lUr2Fdt4XskucRO2Gcve61SOh7FS99jd89fq6QTu4U8O9gQ0jGJjhyGeQ8PkuGNZHgrBp7tGbyTDI+S4QvPanK7PJad1VCq8yG5fl0Ly85qyJgMe9lZTZ697GoBaT6yU17M1nXbQKyb2n5HndwUCMsuLeTZy06b8+xllxby7GWXFvLsgo8rvnATzrIXbsJZ9sJNOMteugnn2AX7qhfsq16wr3rBvuoF+6oX7KtBrK9uY+uzWtTVqBkf3qSZrNv3kxdrVl/zn3+i+Bs=","brillig_names":["member_count"]},{"name":"in_group","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"group_member","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VXz2/TMBR2mmRNWqaVDRBIHHyFw0gH0hDisIltF9CQ4AAShylb0hEpjavE3Q/+euLOb/nqpeumJYdZap9jv/e9z8/vOY7Frppd/izdd2HMbKSzo2XwsDZsECtok6f1SHh2GuRpAU+byDo4AIvo1CxK6bjGmGrr0F/T8lBInmSJTMI0+RdHqP4c+u+0PJhmJzIRWWlzdJqL6YSfhBkXWXrJj+Oyn6ZxxAsZykT1LxHuDfQ/a/lTijw8jXmRljQCnpX/pZk4j6NNjnMFH08LqYBzyUe5GPPhJmJ/hf4rLXfzPLwseUbxBRdTycWIH4tpFhVo+Av6r7UMpYzHE8ml4GEU8fNE/uXiLM5HJbHreE609Fm1B7RPO/o5eFgb+kCuUeyPH7YV9ko7vN8r7G472IHC/eJdYRF/8qXyfk/PkbT0b5VVtUP2q6yqqz0Yo9rZ12NKPGHV/IFX+VNtA8YoP5T+QPfDs/H3yYmI4t0oyuNiLgExTre1u+J598B7aeIdTtM0GSVxvn+RFHIO16/BpfOnU7Me5ILzzMD0DKwd/Rw8rM1eHMTF0di+wcsFnQ0t1xfwxPU3+FIauqzKwRd35MCa879l7kGT5wDWFwMf2HCeePRgvOkz1QI/5J98UZ4q3l2D0wDGMBe6BlbXwEI7F+xbivns8tBbsj7lv9+O/62n2j9x6BtxxBi6wLMh/wGD9boLYt9SLc9i34e4473NBx6k81bLu5w5TdbAfevSB9lW3qyy+fNtGSfi0WsxTrif5J984Vlh5voAxlwYM3NB2dIdhupDPW/Delzw7dTou6CzBxifdF/d8/E9SLiEQ+PmuYW+2QLfa2y+1lSzF/iz9Jx5DpCNY2Djvc0z8PAuR3N9zcc1dG3QxTWrhvmGd0jV1P3ome5f34/0J8mPOIxufKSxm/m67P5E4z2Yayt/6Z5BMcD8JJ1vWtadR7OYe5UNcXe8VrhvKdg/4Pv6/AR/y2qz7l1INhQHrFUb1oXfz03viW1wIi7oE3mijg26pPNby7p9W3buYG3QuaPqaIW+cSDeXa/i7IBOBziRzhHghuDXNXDVvKiZp3bbO4Byb/aubCcPr+5TkPcO+HJg/aTTAx4uPI9hPX1vfj0UC8JV8fd0v+8ttnMNuwHoeGDnG3a+sW9qDyLd77H5Gmsy93GvVe7+B9kHes8FFQAA","debug_symbols":"5ZvfbqpAEMbfhWsvZvbvrK9yctJgqw0JwUbtSU4M797VyoJIljbWZid7o6Cfw+/b4MzsAsfiZb16f32qms12Xyz/HIt6+1weqm3j947toljtqrquXp+GHxdwekFx1u/fyua0uz+Uu0OxhEWxbl78u//tpqrXxdKqdnEjc9JehE7bIEWtJ7RKQBfVb7qgdnZCbJzAi9j4gwzFfxcFyjuYEVBdlAhS/SK1umekrexG2s2NNApynUOpdJyZUHdiEiDGzPpHmP1AX0OfQpvHhbaPC02PC+2+HNqrBXxLjd9ST+YEBAMBn9SMVQyZwQycWpw6X3WI6yhohTNTcbWCkHJc/3+UiNPqQDw4t4U7u5RZuFRZuNRZuDRZuLRZuKQsXLocXErIwiVm4TKL3kdm0ftIlYXLLHofeX/vg6BEEA9opn1+cU5njOmm/CT7kARnaMsRmjhCO4bQCjhCI0fo2aruV2TmoI3uoeHqCLdqn+06tQE0bXQNTlvd5V+/Se31GpySjNkVY3bNmN0wZreM2Ykxu+PLroExOzJmZ1xXdeL5nVRgJz1mTzvPULho6jfNmP338wxBYJc4wy67y6FaDae350moAb7oyBddMEHX5gZd8kVXfNET78Jimd2k3YVRuONHkxrf4WLT7sJIiAh72l0YgevZKS52sl91lVaOjabdskVbB5v2UkicXTFmT7tVjrOnvRQSZ097KSTOzniKYhMvwjF2SrwIR9lTL8IxdsZ1lRjXVWJcV4lxXSXGdZUY11ViW1dbv/ev3FXlql5fnkvZvDfPg8dUDv/fPr/x4g8=","brillig_names":["in_group"]},{"name":"make_payment","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"creditor","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debtor","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"5Z3bTiM5EIbfJddcuKpcPvAqq9UIZphRJAQjYFZaobz7dhjaBNKxZ5N0Uj++gTT48P2t2H/50O3nxbeb618/vizvvt8/Li7/el7c3n+9elre3w1Xz6uLxfXD8vZ2+ePL5p8Xbv2D/Ev6x59Xd+vLx6erh6fFpbtY3Nx9G34Peb8vb28Wl9GvLraSZYmvCbPGkpRUJ9J6dmOpw8dcUuc4kThkptfEYahkM/HfFwvSA5jJkX9NSU78CanDIXc6yninc+tOE6c8KhSvdeZEOiZO7PgjczwK83Cj30Ovi07zFZ1nK5rdfEXTVNHqNLxmUpdaFVBpj2Gj/EhT3xIdqSmnkpZzmCpXvSsNPb+1AiGaTl1kbnyjOL+o5C5UShcqfRcqtQuVoQuVsQuVqQuVuQeV4rpQ2UXsI13EPtJF7CO+C5WHxz7kPJcKNmimdf7hSCqEESAkeStyYFlDB0ToiAidEKEzILR3iNBtV8/agg76Bu3e1bCdeujtxtTBUVhVZ7406tj/Dh/T6v3Ml2dgdgFm98DsCswegNkjMHsCZs+47OqA2YF9VY3378kX9qQf2W231VSWKoeP4SP76dtqcoVdqMEu4yKk+s3h7csgNDhcdMJFZxB0DVvogovucdGb0S+5d+jrPGGPPHGPPNM9NymVPLFxWwFm60LuQWV0XaikLlRyFyqlC5W+C5XahcrQhcrYhcouYp/YReyTDo99Tr8MlAgRmhGhBRHaN6FTOu6Q92izmUmB2QMwewRmT8DsGZc9O2B2AmZnYHYBZgf21Wy8f6+tEg5hu2n46jIhudP3NMdasSLHwOwCzO5B2LcXrYalImD2AMze7uHzO/aXTGmfTNMxq9AoXCU2xq+c4jgo5kwfJ2WI3Ow10Ow18Ow1yOw1+Nlr0NlrCLPXEGevIc1ew+xtmmdv0zue95dcYktPeYU+Y007Hvj/dDKlD5m+D5nah8zQh8zYh8zUh8zchcwdD/5/Opl9REHSRxQkfURBcngUdPp1dhKFpA6Q1BGSuh1BcJP6TEtGJBkY3jtkeEKGZ2R4QYb3yPCKDB+Q4SMyPLLDqvF+vrorQ233NvVdGXr63uZ/rPRS9qXoYeC0MVr6PVzSAE0foenbHY5sLZlr3iNTcPtkmu5SvJZlNh95KxPvk0n2yeT3yTTdWIMrfWtg2coU9skU98mU9sk0/Y0IIiWTJvyJnR3PFn86mdSHTO5DpvQh0/chU/uQGfqQGfuQmfqQ2UcUlPqIgtLhUdAZ1mgSQ1ILJLWHpN4RQcQywxSyb1CnMhFIaWOfKw8N9KWKdn8fWnMi7MspZbzxVPr0nEgQPxYdJDTONAuk4z0fPspm4jV8Ztvwebz1gd3WIXJZbMMnrsF70/DscoGnrdnvrMjwARk+IsPb7iob8BkXnp1DhidkeNsO24C37bANeGCHZQfssOyAHZYdsMOyMz4YCekNvnGCdPaFI/uNheJRqW073q10DU+27bgBb9uOG/DGB7x1eOMb7Wqbjphsb7RLUtb8k49b8LY32iXmGrztjXapONoAnxqmIG9z3hJlS6ntfe/VjW3Mtve9N+Bt74dswNve996At73vvQHvkeFt23ED3rgd1+GN23Ed3rodV+GRHVaQHVaQHVaQHVaQHfYPns82DA/87lMW2y+3rg94xfbbresDXm/9rbNHG/B62y/Drrdub/tt2A1426/DbsB7ZHjbB0004G2fNNGAt23HDXjjdlyHN27HVXgFfgk8K7LDKrLDKrLDKrLDKrLDKrLDnuFo+uMNeM9wOP3xBrxnOJ7+eAPeMxxQf6YB7xnOsz9e6z7DifZHhFdk+IAMH5HhEzK8bTuuw0fjdlyHN27HdXjrdlyFR3bYiOywEdlhI7LDRmSHjbAOuxqu/rl6WF5d3948DnnW//x19/VpeX/3evn078/f/xkS/wc=","brillig_names":["make_payment"]},{"name":"balance","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"creditor","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debtor","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VYW0/bMBR2aNLmsopuTLtIe/AvQCmgjYc9gMbljUmbtve0SbdoaYJSFyi/fnHxab6YlItINmGpHMc+/s53js+xEwx208ziZ6i+BWN6I50DJf2ntWGDWH6bPI1nwnPjmfDsNMjTAJ4mkTVxAJyQAerUOCb1LG1Mti3obyp5lgkep7GIgyS+jkJUfwP9bSVP5ulYxFnKR0ESpOOIj4OUZ2my4CPZT5Io5DMRiFj2F4j2Efqflfwusjz4FfFZUrDweVr8LZZll1G4zXFuxqfzmZDAueCTPJvy4TZi/4D+eyUP8zxYFK6F0RXP5oJnEz7K5mk4w4UB9D/QmBDR9FxwkfEgDPllLH7z7CLKJwWxVTivlXTYzTbIRlt1oJ79p7WhA+Qaxd7f25fYvXZ470lsux1sX3L+osCJP9mSpXCkHkga6tdnZanQ+j4rS+oIxqh0jmGsq8ZO7NJmn5Xzp3bJQbYtGKOceVH8BqofXEy/no+zMDoMwzyaVZISY3dXeyie8wi8dzre2TxJ4kkc5cdX8UxUcN0aXDqWNthtf5ALzjNt3tGwDtSz/7S2vPeIi6mwXY2XBTqvlXy1hif63+CdOrRYmZdvH8GhwTrbxdpgYAMbzrsgzXY4LffP1eyTLcqnPiv3knQHrLq/xM3RsPTcxHVU/y3G3Mf8XOeftO+1Y3/npfKNOHhaHB2QFvBsyP6uA3H+3/ncBd/bzOeuZr8unz2N0wDGMJ89DcvTsHCdc8e6upxr6T5f5RxxIDuu5rPDqvvTkH2fsCmWXYgDzWGMm/x20u8jg90+p/A++qTkursA97TJPMV3IgY2sJkaF5Jt5Q2e8w/hhHnVVpzqzm/9TsF6Jl2sSxPGLIgjre2BH7LJfD0CfxzAMWv0LdA5A4xT1d9k9XflfX4ZYIt09FreBMwe+ITcaKyjrfXWcOuAHbRPHKhRXZOufNel97vVu6765PwWBeFD3sdvfavX6Dis9KWNfMN7APe7A+Ok81PJuvNjGXO75EzStFvhviNhI7BN8bPA3n33ksGq//7AO4/iMAAdG/z6l2dAD+zqvnU1HVqL+zZSsm7f8Jyg+PRr8PCckHXUpe9ViHfPLnFM0NkATqQTA+4fsGtpuHJ+UTNP7a4z24R8dNrJw+Ud7NqlfybYMsF/0nGBhwXPl+CPZ1f9WdWVkjL+tup79vp1lrZuADo2rHO0dY62b3IPUtV3WbXGmsx93GuZu38BMhoJeZAXAAA=","debug_symbols":"5Zttb+IwDMe/S1/zIk6cxOarnE4TbDBVQjABO+mE+O6XcvRhpRc2cZli5Q208K/9c9TYTtSeqpfV8v31qd6ud4dq/uNUbXbPi2O924az03lWLff1ZlO/Pg1/rlTzAeaiP7wtts3p4bjYH6u5mlWr7Uv4Dteu682qmns8z25kbPxVyNZ3UrB2QotatVbDIXdq9hNixxquYhecDMU/ZxXgA8ygAK9KUAa/kdo+MtLetCPN90YaNHEboUEbZyawrZi00mNm91+Yw0B/hG5M+3SmKZ1pTmZaq0+bbtTwJbX+knoyJwCa9u4GJBcPVZPXV7Fm6G8rzRcHmNqBTe3ApXbgUzug1A44sQOjUjuA1A50agepZ7JJPZNN6pls/jGT2bUOrIY7eR26NsgN0rqHqeJs26wLTAMUN2XXour6K+6bDwMwre6qi7qJ0hcRJRURJZcQJaoiooQiotRFRGmKiBKLiNIWEWURvQ8W0ftgEb0PPt77gELdORjQTMf5ya0d51oAR6Y3SaqBtkoiNEiE1hKhjURolAh9v6qbu9DO9tDqg4dbdch2rdop6PcpJrfirbdt/g2HNBQ37E4wuxfMToLZWS67U4LZQTC7FsxuBLOjYHbBddVlnt8JO3ayI3afd56h7tmJcOjG7N+fZ0h17APTk+zA2JkOC9LBKvSyDPVGMjxKhpc8XfNux6h7mssSjp9eorzbMdI6wp57muSeneJiNv1WmvFmHGjevVu0HlDevVucPe/eLc6ed+8WZ897TyTOnveeSJw97yIcZ8+8CMfYOfMiHGUXvFZhwXWVBddVFlxXWXBdZcF1lQXXVRZbV8/h7NdiXy+Wm9X1naP1+/Z58ArS8ffb33+C+A8=","brillig_names":["balance"]},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"admin","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"PublicGroups::balance_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::balance_parameters","fields":[{"name":"creditor","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debtor","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"PublicGroups::add_to_group_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::add_to_group_parameters","fields":[{"name":"member","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"approve","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"PublicGroups::in_group_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::in_group_parameters","fields":[{"name":"group_member","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"boolean"}}]},{"kind":"struct","path":"PublicGroups::admin_abi","fields":[{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"PublicGroups::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::constructor_parameters","fields":[{"name":"admin","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"PublicGroups::set_balance_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::set_balance_parameters","fields":[{"name":"creditor","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debtor","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"PublicGroups::make_payment_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::make_payment_parameters","fields":[{"name":"creditor","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debtor","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}}]}}]},{"kind":"struct","path":"PublicGroups::remove_from_group_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::remove_from_group_parameters","fields":[{"name":"member","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"approve","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"PublicGroups::member_count_abi","fields":[{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":64}}]}]},"globals":{"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}]}],"storage":[{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"group_members","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"group_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"member_count","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}}]}]}},"file_map":{"24":{"source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n","path":"std/embedded_curve_ops.nr"},"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"29":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"34":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"57":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"74":{"source":"// mod test;\n\n//this will be a little test to make public groups in noir\n\n\ncontract PublicGroups {\n\n    use dep::aztec::{prelude::{Map, PublicMutable, AztecAddress}};\n    use dep::std::hash::pedersen_hash;\n\n\n    #[aztec(storage)]\n    struct Storage {\n        admin: PublicMutable<AztecAddress>,\n        group_members: Map<AztecAddress, PublicMutable<bool>>,\n        group_balances: Map<Field, PublicMutable<Field>>,\n        member_count: PublicMutable<u64>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.group_members.at(admin).write(true);\n        storage.member_count.write(1);\n    }\n\n    //helper functions to read variables when testing\n\n    //read the admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    //read the group members\n    #[aztec(public)]\n    #[aztec(view)]\n    fn in_group(group_member: AztecAddress) -> bool {\n        storage.group_members.at(group_member).read()\n    }\n\n\n    //read the member count\n    #[aztec(public)]\n    #[aztec(view)]\n    fn member_count() -> u64 {\n        storage.member_count.read()\n    }\n\n    //read the balance between two addresses\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance(creditor: AztecAddress, debtor: AztecAddress) -> Field {\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        storage.group_balances.at(key).read()\n    }\n\n    //functional methods\n\n     #[aztec(public)]\n    fn add_to_group(member: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        storage.group_members.at(member).write(approve);\n        if (approve) {\n            storage.member_count.write(storage.member_count.read() + 1);\n        }\n    }\n\n     #[aztec(public)]\n    fn remove_from_group(member: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        storage.group_members.at(member).write(approve);\n        if (approve) {\n            storage.member_count.write(storage.member_count.read() - 1);\n        }\n    }\n\n    //this set balances but only between two people\n    #[aztec(public)]\n    fn set_balance(creditor: AztecAddress, debtor: AztecAddress, amount: Field) {\n        assert(creditor == context.msg_sender(), \"cannot adjust someone elses balances\");\n        assert(storage.group_members.at(creditor).read() == true, \"Creditor is not in group\");\n        assert(storage.group_members.at(debtor).read() == true, \"Debtor is not in group\");\n\n        //cant store the addresses in a tuple in storage so hash them together,\n        //easy to know who owes who as hash a,b is different from hash b,a\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance = storage.group_balances.at(pedersen_hash([creditor.to_field(), debtor.to_field()])).read();\n        let amount_to_write = amount + balance;\n        storage.group_balances.at(key).write(amount_to_write);\n\n        //adjust the balances\n        //balance between creditor and debtor\n        let creditor_debtor_hash = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance_creditor_debtor = storage.group_balances.at(creditor_debtor_hash).read() as u64;\n\n        //balance between debtor and creditor\n        let debtor_creditor_hash = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let balance_debtor_creditor = storage.group_balances.at(debtor_creditor_hash).read() as u64;\n\n        //if the balance is greater than 0, then the creditor owes the debtor that amount\n        if (balance_creditor_debtor > balance_debtor_creditor) {\n            let difference = balance_creditor_debtor - balance_debtor_creditor;\n            storage.group_balances.at(creditor_debtor_hash).write(difference.to_field());\n            storage.group_balances.at(debtor_creditor_hash).write(0.to_field());\n        }\n\n        //if the balance is less than 0, then the debtor owes the creditor that amount\n        if (balance_debtor_creditor > balance_creditor_debtor) {\n            let difference = balance_debtor_creditor - balance_creditor_debtor;\n            storage.group_balances.at(debtor_creditor_hash).write(difference.to_field());\n            storage.group_balances.at(creditor_debtor_hash).write(0.to_field());\n        }\n\n        if (balance_creditor_debtor == balance_debtor_creditor) {\n            storage.group_balances.at(creditor_debtor_hash).write(0.to_field());\n            storage.group_balances.at(debtor_creditor_hash).write(0.to_field());\n            //this is not setting them to 0\n        }\n        //if the balance is 0, then the creditor and debtor are even\n        //the values should never go below 0 as as you are subtracting a larger number from a smaller one.\n    }\n\n    #[aztec(public)]\n    fn make_payment(creditor: AztecAddress, debtor: AztecAddress, amount: u64) {\n        assert(storage.group_members.at(creditor).read() == true, \"Creditor is not in group\");\n        assert(storage.group_members.at(debtor).read() == true, \"Debtor is not in group\");\n        //make sure the payment is less than  or equal to the balance\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance = storage.group_balances.at(key).read() as u64;\n        assert(balance >= amount, \"Insufficient balance, or paying more than is owed\");\n\n        //subtract the amount from the creditor\n        let amount_to_write = balance - amount;\n        storage.group_balances.at(key).write(amount_to_write.to_field());\n    }\n\n    \n}\n","path":"/Users/niallcheetham/dev/aztec/publicgroups/PublicGroupsRoot/publicgroups/src/main.nr"},"76":{"source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: Field = 3;\n// ADDRESS_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[aztec(note)]\nstruct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/address-note/src/address_note.nr"},"82":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"97":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\nuse crate::hash::ArgsHasher;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    args_hash: Option<Field>\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs, args_hash: Option::none() }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            let mut hasher = ArgsHasher::new();\n\n            // TODO: this should be replaced with the compile-time calldata size.\n            for i in 0..self.inputs.calldata_length as u32 {\n                let argn: [Field; 1] = calldata_copy((2 + i) as u32, 1);\n                hasher.add(argn[0]);\n            }\n\n            self.args_hash = Option::some(hasher.hash());\n        }\n\n        self.args_hash.unwrap()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"125":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"138":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"155":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"156":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    point::Point, traits::Hash, hash::{sha256_to_field, poseidon2_hash_with_separator}\n};\nuse crate::oracle::logs_traits::ToBytesForUnencryptedLog;\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (n as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        poseidon2_hash_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x1cce4dbf69f14c44865919991ee1057922e34d7310ba237d71759aa422621ca9);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"162":{"source":"use dep::protocol_types::{\n    header::Header, address::AztecAddress, constants::CANONICAL_KEY_REGISTRY_ADDRESS,\n    storage::map::derive_storage_slot_in_map\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys, constants::NULLIFIER_INDEX},\n    state_vars::{public_mutable::PublicMutable, map::Map}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"171":{"source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"180":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"221":{"source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"230":{"source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"293":{"source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"295":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"296":{"source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"298":{"source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"299":{"source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"302":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"303":{"source":"use crate::{\n    crate::address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"311":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"343":{"source":"use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    protocol_types::{\n    traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    point::{Point, POINT_LENGTH}\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul};\nuse std::hash::from_field_unsafe;\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.value);\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> ValueNoteHidingPoint {\n        ValueNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    /// The following method needed to be implemented because the note is passed as an argument to a contract function\n    /// --> the serialize method is called by aztec-nr when computing an arguments hash.\n    /// Note that when the note is about to be encrypted and emitted as a log the to_be_bytes function auto-implemented\n    /// by aztec macros is called instead.\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n\nstruct ValueNoteHidingPoint {\n  inner: Point\n}\n\nimpl ValueNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_value(&mut self, value: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(value.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for ValueNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}