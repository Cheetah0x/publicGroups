{"noir_version":"0.33.0+cb20e078dd909656110d133339b2b425e6c3ebb0","name":"PublicGroups","functions":[{"name":"admin","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/7VX32/TMBB22qR1U6KVXxJIPPgBiReE0gkNHjvG9oDQJsELgqesSSFSmkypu6389cSZb/li0g3U5KTorvH5u8/n88W12I30isfStgPvTCGfmdb+bjJtEcvvkqfVIk8LePaIrI0vjEWg3QNfHH8I9p7Wp5kUcRrLOEji31GI7k/Afq31yTqdyzhLRRAu41TMg1RkabIR51FhJ0kUipUMZKzsDWIdgP1c68M8DzZF8DC6FtlaimwhzrN1Gq5w4gewX2gdSBktL6SQWUEjFFex/CWyyyhfJNnV7YJ/aD1iVcIoiTP9299NpiMg1yr2+7cHCtvphve+wh50g+0PC4wjfoNF/ClWv3g+6jHSln48Pc5gvseqQiZ/pcasGj/mFbaSx/COauFB8Uy0HVwuzy7mWRgdhmEerWrFhjm5S/4Vb/gfeM9MvNN1ksSLOMqPr+OVrOHyBlxl91i9OQwauDR1bCVmTSi/mf7t7yZlZ6T4tsbmBkcHfB4Z2uSJ62+x604dVtXb03s4YINts6d4sD4GMVDsBrvDM73vGTHv40Q83A7zZLF6fdvs7w+k4j00OI30QzJrh48/gViEr95xIz8Yv+3eq9brGBzUul9CvKGRL9Mfz+EbwHil7T0Yx3No7oXZbyyIRT64J4TNgYcSD8Y5vOsbc8dbuPVZvccwmIc1O9Pa302mDLgxiEEcVK+nm9Vtr/8qszz4GX2JgtoNrOkSZ/7ub/HpsB+UZ89lVU6xjjDX5PNO66ZeWu6l3iw8PzbvhPu+gj3B2MQX4rnAzwYfrGWz3jEfSibgg2cf7wRt74n5XSAuGJN4DgwfG/iTz5HWTfuGvY3y4zXgYf9R53NA9zXI95BXc2zw6QEn8vkEuJ8xroGrxr83jJPc+U3VvmWv7qYOy394LtyTbYhlw/rJxwUeDvz+BusZ8/p6KBeEW/ZXbY/59nmOMW8CPhzmjYx5I2Pf1B6cadtl9TPWZu3jXqvvwB9bvN5ashAAAA==","debug_symbols":"1ZrdbsIwDIXfJde9iPPjxrzKNE0FCqpUFQRl0oR496WsDaygMMRA8Q0kcOp+jZIcx+pezMvpbvlRNYvVVkze9qJezYq2WjW+tz9kYrqp6rpafpz/LGT3AXDUb9dF03W3bbFpxURmomzm/ttfu6jqUkxyPGQXMtJ5LySbByl07QutUXKI6psU1ERXxEgKejH6m5yL3zMB6gFmkGB6JUhtXkitHxnpXA8jTbdGGpSj4Qm1sXFmB3YQOyXVmNn8C7Mf6N/QXWj7vND4vND580K7P4fu1HSPWsm71Ff3BJAIAT+nW6sMbRDT6Qbg1BW1JRrUKAHjM9bmdth1fNONZqxSjNk1Y3bDmN0yZkfG7DljdseYnfiya8mYnbGvasa+qhPfI50J7M6O2dNeqy4cj3wTR+zm9WvVycCuIc7u44VjEsjTnNHSHuGBM7ziDM94uZq0UxoXCjbWmXGBwqSd0jilIuyJb5Mxdpt2SuMkndhdXEzaDNuAL4Dp8YOmnf9Evcymnf/E2dOuK8TZDWP2tOsKcfa0TTjOnrgJR9kTN+EoO+OzCqZuwjF2xr6KjH0VGfsqMvZVZOyryNhXka2vHnzvs9hUxbQu+1ciFrtmdvaGRPu1/vnHi78B","brillig_names":["admin"]},{"name":"balance","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VYW0/bMBR2aNLmsopuTLtIe/AvQCmgjYc9gMbljUmbtve0SbdoaYJSFyi/fnHxab6YlItINmGpHMc+/s53js+xEwx208ziZ6i+BWN6I50DJf2ntWGDWH6bPI1nwnPjmfDsNMjTAJ4mkTVxAJyQAerUOCb1LG1Mti3obyp5lgkep7GIgyS+jkJUfwP9bSVP5ulYxFnKR0ESpOOIj4OUZ2my4CPZT5Io5DMRiFj2F4j2Efqflfwusjz4FfFZUrDweVr8LZZll1G4zXFuxqfzmZDAueCTPJvy4TZi/4D+eyUP8zxYFK6F0RXP5oJnEz7K5mk4w4UB9D/QmBDR9FxwkfEgDPllLH7z7CLKJwWxVTivlXTYzTbIRlt1oJ79p7WhA+Qaxd7f25fYvXZ470lsux1sX3L+osCJP9mSpXCkHkga6tdnZanQ+j4rS+oIxqh0jmGsq8ZO7NJmn5Xzp3bJQbYtGKOceVH8BqofXEy/no+zMDoMwzyaVZISY3dXeyie8wi8dzre2TxJ4kkc5cdX8UxUcN0aXDqWNthtf5ALzjNt3tGwDtSz/7S2vPeIi6mwXY2XBTqvlXy1hif63+CdOrRYmZdvH8GhwTrbxdpgYAMbzrsgzXY4LffP1eyTLcqnPiv3knQHrLq/xM3RsPTcxHVU/y3G3Mf8XOeftO+1Y3/npfKNOHhaHB2QFvBsyP6uA3H+3/ncBd/bzOeuZr8unz2N0wDGMJ89DcvTsHCdc8e6upxr6T5f5RxxIDuu5rPDqvvTkH2fsCmWXYgDzWGMm/x20u8jg90+p/A++qTkursA97TJPMV3IgY2sJkaF5Jt5Q2e8w/hhHnVVpzqzm/9TsF6Jl2sSxPGLIgjre2BH7LJfD0CfxzAMWv0LdA5A4xT1d9k9XflfX4ZYIt09FreBMwe+ITcaKyjrfXWcOuAHbRPHKhRXZOufNel97vVu6765PwWBeFD3sdvfavX6Dis9KWNfMN7APe7A+Ok81PJuvNjGXO75EzStFvhviNhI7BN8bPA3n33ksGq//7AO4/iMAAdG/z6l2dAD+zqvnU1HVqL+zZSsm7f8Jyg+PRr8PCckHXUpe9ViHfPLnFM0NkATqQTA+4fsGtpuHJ+UTNP7a4z24R8dNrJw+Ud7NqlfybYMsF/0nGBhwXPl+CPZ1f9WdWVkjL+tup79vp1lrZuADo2rHO0dY62b3IPUtV3WbXGmsx93GuZu38BMhoJeZAXAAA=","debug_symbols":"5Zttb+IwDMe/S1/zIs6jzVc5nSbYYKpUlQnYSSfEd7+Uo2lXemETlylW3kAKf+yfI2I7UXuqXjbr99enut3uDtXyx6lqds+rY71r/dXpvKjW+7pp6ten8ceV6F5AXfSHt1XbXR6Oq/2xWopFtWlf/Lv/7bZuNtXS2fPiRkbKXYVkXJBCN77Rail6q35IQU00I7Yk4Sq23slY/HNRgX6AGQToqxKE0t9IbR6Zaaf6maZ7Mw0SqY9QaRNnRjC9GKWQU2b7X5j9RH+E7ky7dKYxnWlKZlqKT5vu1PAltfySejYngBWyx7ej5T4bqkTXiyXB8LeSl7+V1KkdmNQObGoHLrUDTO2AEjtQIrUDSO1ApnaQeiWr1CtZpV7J6h8r2brggOSdvA6hDbKjtO7UXHE2fdYFwhEKztk1WoT+iobmQ4GaV4fqIm6idEVEiUVESSVEqUURUUIRUcoiolRFRKmLiNIUEWURvY8uovfRRfQ++vHeB4QOewcxopmP85NHO9ba/uQP1WASZQdtBEdo4AgtOUIrjtCaI/Tdqu7EXWhrBmjxwcOt2me7Xm0F2PPodH1G7EzP4Yc4FnfsljG7Y8yOjNmJL7sVjNmBMbtkzK4Ys2vG7Izrqs08v6MO7Ggm7C7vPIPh3gk/tFP2788zKAK7gjg7kA6m/YZ02LIKuMArzvCaMzzn5Zp3O4bhbi6Denr3EubdjqGUEfbc0yQN7BgXkxqO0pRT00Dz7t2i9QDz7t3i7Hn3bnH2vHu3OHveZyJx9rzPROLseRfhOHvmRTjGTpkX4Sg7470KMa6rxLiuEuO6SozrKjGuq8S4rhLbunr2V79W+3q1bjbXZ4627+3z6BGk4++3v9948R8=","brillig_names":["balance"]},{"name":"split_group_balance","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debtors","type":{"kind":"array","length":10,"type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"participants","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1a647bRBQeb+zEuW2cpK1A3MwPbhJUyW65iIu0Fbs/abetRIWEBNnG2w3KrpfE2xYeAF4AiZ/wIPACSPyGNwAJCQnEA5Bx5yRfTsZOsvEgUnWkyM74XL45c86Z4/FY4mHbHP0sde+oa17MNqLZUdfWaq2doayWSZzWmuDcyBCnxFYSZuc/Z8CuWWO01wCjswYY82uAsbAGGN01wFhcA4ylNcBYXgOMFQMYTeCsrgnOTRM4JUhb3dcYeFk05NRzuZDIRC0ToUw0MpBloEhHlBMtjbgpZttFZgzZXoV70nktjPzeSS/qdfq9L4MukqNRX1DXO52TkxFHp/vZ2TDyh+FxEJ4EftAfBi8N/YNOv3NyJxiikF24f1ddb0XhoHM38If9kaiWHwvs98P7Qfeyj8+G/nGsJeoMIv9wEB777cso+xO4f1JdP5AcB4F/KnnCQz86Cvy7g/DsFBm7cP+0unaiKDg+jfwoHI2u69/vRUd+eC8YHI6AIe+pRunVwaDzxciM3eCBH57Feg/Cs5PulCW+MmiJ7+D+OXXdDQ5GEvzeMBabao8fDEL7RZzf1r8ZxPXXCrgwqpbyAdc6v9LGeZU+s4LSl8+rdHsFpW+vwLt7XsDXl1Q69oEjdSMz84bqo+y+o/63Vmtx+SZMyH7r9a2iwm4A9yGtVgZkt+SK+L47sb0AXXL13FXP6Gqpn3y2r/r24Zmjnt1QfTfYs6p6LkBvVUxW8V3ooy2bPcCXNzJ/V94wOH8dKbdsRvZBVSRvZ1Cz4Z5wlIQxn4q3lcpMP+mi2I79QM1rHvpsdxpn7AfMP+Xfp+B5HsZEfQV1vw/+pG7HPikvL6q+5uh3kwjERF/BNWKjeBvKVbIdJZt00Xg3gMZlcUT/qaSU/UXAL+WRfUmurFbzZEs3mc9mfB7Q5IGvwPgKgDumFZNFgCptT/3v3Du+fnon7AZXu91BMJxaRNAv09qi8spLyHuCy7t21u/3DnvBYO9BbxhNya1o5NKbx4aYHQ9iwefYeK7IcOuzjVuftpJdYbgcoHlNXRsanJKP3n7GtroVjKqDwTwTJTWE4DB+B563U2AZTLXbVcAjQAe2pFRbMYNJm2pJF6baEsNUVP3UdrLBs+WJ6TRMYy4xjHw5QD4HMBqayzj9bs6xm9RfM6N/q67GSxhqbH5KgAF9LiP9LdSJIV8BvZsw9iy/FElZHtjdAiybgIlo9tQ1Kd49wJllbFXF9KYS6cCG8e4BproZTFtV0LMIJsJRMmgnC/SQftKFOajBMHnQV4G+GtwTL5V+FB+ytLjJxkO6bQ29/J8zNH4H9L9nTfB9qPpqgKemwSwYZnz99RiNzcZVE7P2yonZTVF8bSuCPAE8RFtkPEVN347631qtxbYjvZ+qa1Kc41gy/DLY5nMhZRc09iP75hmNDXxEE6SMBfNdTvG5TJZuzZZ6j8AeLsjL8nU1Lu1hTLheuxobHQO+PmAuAo0JjHYCRo5dts/VNWk+eCzSKyXGYoHREA/prYF9OC3hoecVDcY3IXfcV30G17dt3HZBWwgNdgE4StBvYi1Jynm4ltQZJg/6sO7k61KdyUI+N4WPY5Dz0jBjg3FtSBhITxkwIzbZMPfgu0YD6NDPsc4imq+ZPmwGx9te1g8bgMlkndVYAhPWWabspPNL0oWx0WSYPOjDOstm9sRtM1xzvoHx1EG3raF3gOZ5yGffqr6amK79uVzq5/Uj+jLR1JnumpgdU45hJllUC5Ee1I/1k8d4MF9/z3Rhe5y3l8/bDmB7lPM21m4iO/3bBse2fd4cbdrneE5I87kGzMMivpPmc14Kn87nmmZsMONzpKfMxizEdK3A37st4E2rFYjmR418YX68S9cKTcBkslZoLoEJawVTdtL5JenC2LjAMHnQp6sVmsCrqxV+gvEsUyuUoVb4WfXVhH7tTqoDsFZoMhqei2uaMeXEdL1MsuiTNs8jxEO0dcbD5wBrh5pmPHlGg+si0fyqwUDtcf7X5/8mw4T1MOZ/7jM8XpDPS+HT5f8LZmwwzv+EgfTo8j/u3ejyP+6hWkCP+Z9oftfIp5YDXvT/pJzxB2BYJmf8AzL+BBlYW+G+EO7/FoB33v7W3+qqG2tVw4v7dJg3CowX62W+N14UxuJmC2siATqw2Zp7rDNMxDLXyfM6xjK+n/FYNll/SHkUY+NjG+p/E/rH8a4Mm7TveGHOmHX5hXhwj5qvZTKu6fDy5PP8w4Odtwe9KBCsbcC9boMp6byC7sWPgPEPLrLlGQ3xYnIpphitquHFJKIrGiQOMgwPQpwA0odGpOfciDeDztQxb3Q4bJZGF6eRDosnzbN22EtKFnfYi9BPNM05tqczRVOJyswZqS0p9pY10T0OPNB3CfBhcGAAXWQ0xIN+RDQ4j7yA1vk10XO/xuKNaJ5NsS0W2TSGqkYeFtlJvt5g4xNsbKQPsSzj61hkYlskHgwWQ22ca+7rmLSJ5pX/sa+PFxPQx/2YF6i6BYV40NeJBueRF9I6X0cfRBrixeLsyoK+rnuhxBci3HzOurB7Z878pxV2uOjix1zc5MOGuYTk4gebRWMPXzywWRpdutgz+XECCyBbTGyA/kE0ewvG3rgmEP9d7I1zN+jjRZiuUOMxhJtPsuGBF/5xAPmIHv0aax2kwU09otmfE3vkr/jBlMvDAzZ4bjinOf9LL2t5dv7XAZrbsMHzEdjaYXLl87ua59RSX1TgnHjR4LntEju3TbpsGD/RlNi5bfofWJP+csK57SKc26bz3mU3mc9hfB7QuCnnvYuac9sfK3wlMR0HWeYMnGv5gv8viOPd4LdDAAA=","debug_symbols":"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","brillig_names":["split_group_balance"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2dCZSlSVWg/1e5Z1V2ZlV112ZW1p9ZmVm5VGW9NRcW6VGkoRtxQRgVRXNtGpuqhq6m7UEdjx7nePQoCqicGRwEgQEEGVGZQbDVGRYVFQcGPKKoR6VdkUUUm22m/qz/5vvyvvvHv7yMl1VN/+dUvZfx7hY3Im7cuHEj/lJw7Tl49V8p/t4Tf/YGrY/A3Bp/ltt7KntIq+xTztINIueBG0TOrhtEzu49lDOSrSvY/ey1vD0e9LrXMvbeADL27XG7i4zd8ff+q/8Grv4bDK7Z3pYfWbEDcceJfo8aOFJgH2CSiP6xUk70PBnfb44/n3Hpuy5dvv9SeOnylc3wygP3bIZPeSJxFtBrT8af/+4FL1h9ILzr0sbmd4eX77sSXt4K1y7fd2njXiIuFkX8yqKIdwBxNP5cvXJl83n3XAmvXA5XNzbC+++68pzw8gs3X7B19+X7ifutRZneXRTx/jakfVUbuG8uKvCvFkX89aKIv9tGNc93F2RaL4r4uKKIT+kuXs1vLsr0uUUR72tD2le2gfsLRQX+5aKI7yiK+NttVPO+noJMv7co4g8VRXxJT/Fqvqoo018uivhgG9L+bRu4nykq8BeKInb3FkQ83Fu8mqeLMp0qinihKOJj2qjmU4oyfVZRxK02pP2JNnBfUVTg1xRFfFNRxLe3Uc3FvoJMv7Io4pOKIj69r3g114oyvVIU8T+2Ie0b2sD91aIC/3pRxHcXRfxAG9X846JMH2qD6d8XZfpwG0y5JM7FdKi/ONPDRZmGbTA9V5RpvQ2my0WZ3tYG06cVZfqsNph+R1Gml9pg+h+KMv2Boog/UhTxZ9qo5uuKMv2fRRH/dxvSfrwN3IeLClwaKIg4UBTx2EDxak4UZTpXFLFaFPEJbVTzaUWZfmdRxO9qQ9qfagP3VUUFfkNRxF8qivhgG9V8d1GmH2iD6YeLMv1YG0z/sSjTh9tg+sWiTA8NFmd6dLAg07ANppNFmdbaYPqYokxva4PpHUWZfmsbTFeLMn1OUcR725D214D72Pjz6Vcuv2D1zs3w3rsvXwmfd9+9V8K1q39sRh9bl1+wGa5fft49912569Kd1/bWnnPXRvT9nst3XbpC0p846I30hw8VVNWfFUV8qCjiPwMxb+McGCrI9OaiiGeGikv7lDZwn1FU4G8virhZFPEFbVTz/xZl+qdFEf+6KOKn2qhmcFNBpkeKIp6+qbi0t7WB+/SiAj+rKOJ6UcR72qjm6eGCTKeKIl4oiviY4eLVfEpRps8qirjVhrQ/0QbuK4oK/JqiiG8qivj2Nqr57qJMf78o4oeKIv5lG9X8VFGmXSMFEW8aKS7tchu4Tywq8FOLIn5TUcTVNqr550WZ/k1RxE8URfxCG9U8eLgg09NFEWcOF5f2G9vAfXZRgbeKIl4qiviiNqr5A0WZvrgNpi8tyvTVbTD9xaJM31YU8cGiiO9ro5ofKcr0H4sifrYNacePFMe9cKSgwI2iiI8vinh7G9V8ZlGmzy6KuFUU8d42qvkDRZm+rCjiK9uQ9nfawP1QUYE/WhTxY0URP91GNR8uyrT3aHGmg0cLMj3ZBtOwKNNzRRGrOaXdOXpxR4wYbZ0ciMui3/bwfFEF2zJ7S3u5vjUQy+5B7mU5suKBdjnKOfrq/qbuA/CKThZIAot8luJ/Q0HzrJbgDwXNozZPRJnk6H4NyiQb8Ukok/yn2yBPv5/2WvbYXrWI7kE/tOtDaJ8APPggs35HjsHAWx/aPvt5UPEXXjKWt/tL3Jj9KOvu3y3ndn9R/TH6M8Tv/aiT/D6v6kZZupQsEd0eH7pYrq9FtHt90I7bXnTYbeiwx9Bhr6HDyNTeoehEcvf1e5F7+3xfP2TsBi+R8wBg+iFHD/6eC5rlA8gw6oZehG4UxuqVftSfjNet8EYA0wu8PoXXB7m3Ya/+G4+/HwyaxwzluTX+LBd8FperS2vVWlnob+suaLav8NprvvGzbdMO7T3d7Tl5aO/p1iO6N7VPt6YLIroSIpW5cI9k3qY9Yslcr1SrtUp9aW1xubzcKG+sL1c3l1cbjdWVRnWjvrFVLVcbi1ub5cZKbWOlvnK1uF5ZXy2Xt8qra1uVRkT3MGTes7FduSbzER+0y+XtXLejfmhv97ubLV239dS2dX2Ln/6xLfMxS+bV5fWl6uZieaN89b+txsZyud6or2zUl7dq5Xp9o7xYqZfXVpY3N5YqS6sra41adXVrsVZerzRq5aWVbbrH/eh5226cCPZaz9f63cn8dCtZ6J7yoovKNu2v8KPnbXs3utd6jsf3aT8yl6P5S+ay++NJK5rPvioui3iP7WGdlir16lUruhTROBPT4hw6hjL5/ZuDplxPgh5kvHTHf8uccAtoCMxT4k/EHXYePZ/soX4bQ5AnAA8+9JVFjsFgtw3b67XCsOIvvLhWOK5kGkHZCch2XNE6rmhdD3hRfaSfS12j/jQfL3ijPnAGPPZS3xFvjiHhEah6yCNyRDKFfmTaXsecySFTGH8OetRTCXyEv/BivxxXMo2gjP1kXNEaV7T2Ei8qkzYWmYfxnTGUM4r+GYN+v6LFeI3MBdHfdxt0ZX0n8MdRLjDfDlt/2ZB3DGVjRh3G8L0bf1t1GDPwgsCuu9UHBOc0ZBLaoQPPoq3bVnCOgrbwG3fgWbQnFIzgHAHtMP4usAOKz17bnTxjfBwyTXiUaTyHTNTTWY8yTeSQ6SxkmvQo09kcMk1CpimPMk3mkGkKMk17lGkqh0zTkOmcR5mmc8gkckQ2U88XnGvGUCb9NUSZ9JculE0qflGZ6KsHZSKv2NhIPzOQfe/0U93Wj9Q5AA8+1I/IMRj4a7MS+Ah/4SU2PorfRL5jP4QWnFDKhkGIwmriM4r4CODlt6gRZj1VeEjJJDwCJac8s5BT8E5AzjmPcs7mkHMOcs4acs57lHMuh5zzkFPwJLib5Oy9BXQFXzt7p1AuMItw9t4alw0DZwZl8p06l+9RXz2pcIJgd717HfjbGwkKpwe/vz3+TFqk++lj1wxSv+KXpY8NBp42R2ODNKf4Cy9tkMYgtOCEUjYMQhRWE59TxOnBy2++DVKeAUSDJHidGuh5DBIHumWQznuUcz6HnOchp+DRIMnkRIP0h6Ar+GKQBJ4GSWCGYZA+KGVBa39j300zSOw7rHe/Az+SaUzh0CB9JP5MMkh6FXxr/He5raeau+1EjsHAX7+3Vu/CSxukEEILzk4Zl9gUVhO3QgrzqsK+DVKesB0NkuB1aqDnMUgc6JZBuuBRzvM55LwAOQUvzSB9CnQF32WQBOZvB5o0PhOXRf1U9zf23TSDxL7Des878COZQoVDg/T5+DPJIAmuD4OUp+3C+HMw8NfvrZCf8NIGqQdCh0rGXXE5CquJh4o4O6b85tsgUSbhESg55aFBErxODfQ8BokD3TJICx7lvJBDzgXIKXhpBulIqUlX8F0GSWB+CwbplpjGMHDCoFkm39MMUojfOZjPOfB7gubgsQzSaCxbkkHykuNXLq/kNUgih2+D1KP4a4PEscH4m5Qxb3FW0ZpVtIg3UxCvvyDeXEG8+YJ4YwXxzhXEC+NP9uHouTX+rFRqlcbianlxeWuxXCtXa9V6eX1lca2+sdqoL9UXF5c21mpry0uVynqjWllfqi9XK9XVSmNtvVyrb64uDih5hG51udpYX1pZX19cbayvrW1ubi1tLK4ub1XWFlcr1bXaVSKrtdpyvV5e3dzaXKvXVhYr9eX15ZVKfWm9XF+hXd8lb3VlbWujEkm3tlRerG4srjXq9c2lzdri2kp5qbZYa5S3FrfWVsuVanV5vX5V5Gp5ZaVRXtlqLJUrm7TDpFve3FirbFZXauu19c2VytrWVSE2r35dXW2UN6rrjXpla3Vlo7wS0bsqbrm2ubVWWd9ara6v1WqNpe2c/YuWvLV6ZWNxqbG1elW7m+ubtasKX91o1NZXa/Wr9aitVVbWFjdXlhar5fri0tWy+lU1VOvr9ava2ti8lgNWQdvv4TjfiMZwOdj9uGyPyDEIPB+2p6L4Cy/anqqSKdJTLWjVf61cry5uLtZXNzev6n9lZXm9UltfXt/cXN9Yra0uLS2Xr3bwzastUl1br27V1rbKm6uby43K2tXuVSmvV0bAq4Y6V5WMVSUj8XoK4g0XxJstiHehw3IuFMS72GE5RwriHWtTzgGU7fE4286b4TgTHoGSUx6RYzDwZo8qlp702I90UvfDfz2i11D8zxv8F/3wX47oLSn+FcU/WggehJ5EFyK3yCZ0ZA+V2yRsv17Fr1fxGwE8fbpyipzWulNwThsyCexA4G9uydvny5Ap9ChTnjk4hEx+orb51+cMYvrcrcgTxJyHTJ62dOt5o9vcbvMZ3dY7Yjq6zTU+t5nPQT6R7ZyipXMJiHeiTTzamg60X+OR2n7ttkOn8G5CmdhA7jKG8fejKGMAO3qi+ePH4kbjuoCxqxcjdqV39wT+CMoF5qsQu3oJYlfyO+3vPOpMPsOgKzA/7Yg1JdXh5RnqcNyow0nU4b+gDoLDOc5TPKmRd94VOXz7mucVf+2Te5zP6tY4t3y9o5BTZJkDTvTIOSC2K/WWZe0h8NWMtEo5aHF8V1Am44fnQ7L4lUlrBPqVY0Z9ykZ9tK9ZdtSHY+V69FE9rRVz+6hVyOQzna6aQyZm/lxvqXMebW9uH5W216ePo22v5ePMKJmYsjkE2bKkpOpUz6J4ST6qz7nzkdh+7bZDp/DSfFSxQfRRmfUVPZHv9SfwUUUf9O8+Cv9Op8QKPH1UgfnPuJvjL+DfaV+B9e5WfOijCsxfp/ioVh0eylCH40Ydno86/B3qYM27nvp0I+8+rMjhex92XvHX/pC/8w3XfFS9nrMSU45CTn1kwPJRpQ7UWyWlnsxRqWSkVcpBi+Ob9krGj8tH1Tpx7WHRR50z6lM26pPFRxV4+S0aX3IHVncMGI2vA/F3+k9iG6PfR/taZbHOgY6jTL5PoEy+n0WZfJ9EmXyfQpl85xknP2OsmvuME+dXX2fBrPlVeOmEsDKE1jlcu4IVFFYT1x2YB6nkN9+OcxHjy47PRCtPBjF3OvMM5Jw35PR5cC/PmSge3BO8Q/EnF6Sc7CcONOkKvkz2As+EMIG5HZP9VEyD53UYONOBD35nQpiVBBaApoUfyVRWOHRKzseyJSWE+Wm7au7FNoP2PpMytCOgJyExSGcgtE7y25X5R2GzRI11Y/k2SHlOdtIg6ai471PDeQzSNOS0DFLoUc48s2wIOQUvzSB9NQyS4LsMksCchUF6EgyS7m/su2kGiX2H9S478HmrxTTK5PevTTFIfsZCfg+JKyOfHpJeGSV5SOMQWnBCKeNSmcJq4jq8wY7JMFDoqcJ5B3oIOa2B7uu0Z97UAV4PEBpy9nmUM89J2T7IKXhpBmkDBknwXQZJYL7Q16RxJwyS7m/su2HQfOQ7DZJ1kDAATQs/kmlc4dBwXkoxSH76WDX31Su84nfci0zXDFK/4i+8tEGahND6+p/tRj0cf6ewhxXxw4r4CODlN98DnTIJj0DJKQ8HuuB1yvPIM9BDyNlvyOnTIIU55KRBErw0g/RDMEgC6zJIAvMhGKQfhkHS/Y19lzrncf+TCicIdt+9Oe7Aj2SaVDi8iuHFKQZJcPe47bbz6E8qfq62EzkGgefDIE0q/sKLezT9Sib2e+a7a+Omr3AgXk9BvOGCeLMF8S50WM6FgngXOyznSEG8Y23K6XG+Wsl75xedBk92w3QaJpWeOC9YzvIMZAsVrVDRIl7e88FSVi6Id64g3nRBvPmCeOMF8ehzhaCx17kcRXwZ39f7hIq/nmcinYz64b99ZuOU4j9p8D/kh/8yF3fC37re6CD0JLoQuUU2ocMzG9ofKgXZ7nUVePbn8ylyRjBJe5unDZloC/qBE/2bUngHQIt1Ya7q78cVj/zMD8VC8VylD587T6hd5PB9lv9iDpkWIJPPexAWcsh0ATL5vCzmQg6ZOrCNWb9RckhcZ/mtW754HmRW0XKdPT/RJp6Vk/FoDlD+9mu3HTqFx1w7sYHMxREbxFw7sQHMtfsSclysPDWZYKnbLLl2T8P81NXV5Cu/0/7Oos7kw1w7genr2s2TT1IdBjLUwcq1m0IdDqEOMs44x/nMac0znzDnxte8a/lH1tljn+dB9FhZUPyTzoOwr0UPc+2kDtRbOaWeHGvljLRKOWhxfFt3ETHX7qKSVevEqo/g0Ge9YNTnolEf7WtedNRHfmO8VfhE4+v9ho0gL96fw3Fr3eA4i3H7ZIPuRdRrVpV5TDXa7rfTCfVgWo3AXHTYOtIKAnu+KAWt2SI6Vc26upp6KfvXS43xV5deBGYpRS+TQX69TBp6mVYyBMFuuyN6Y+6lz/ziJB3NoFxgnpAyT8p7G7khL+9k3Os5LCK7eLTJe2cMgJ9uM52hUApazyLoNmNK3izKZGwLTdoFl8/Id+Dxrq40+/PUjD7KPGiKj8I7ovZ6nOVNjOCaxuf5GD2Xu87HsF2ljO8IyXNeZTz+9Dhuq7Q1rnErMM9KsW3abmldWToQHNo2fYdckm/OswlJvrnArDlkT5rXSZ/1OW7QfxHm9S1jXqe/MqN4MSONcSBP+xU1xnr13Y+04wLzvOvHXtez2OsQ8iXZa23TBYcp1AJDm6ftsbSlyx7r9GXa4+926JZxE2Z8Lih6EZ//GtOhHeU683sxp3BsJ/VrgXkN+vX3Z+zX9Fc9ZQ428mb2ihy+39mi/V5t4z2O67rV9613xhyFnCJLCJzo4dpT++BZ5zL9+hjSmjdolRy05h20zuWkpeXabxu2Mx4dNkzXw2XDTqOu2obRpvBYi4xZ2j8dp6Od8eGbvrqAbxrAJul51fJvdD/iHP562Lr3GnS5Nj+nyjo1rnU9rPn6F1P8tBB/WzbC1bfoY2kbYp0K8e3HjGbQi8C8LUUvowX0MmroJVQyBIF9kkDgPM6TdZeOGO8RmAcz+nozkL1Ta/NQ5AU/3WYCwzbTc7JuMx4CoP2TsR3Gn7QL1hwo9Gj/zgE3zf68L0X3Gpd+HWOX4/j9/ZD3ImSN/ll7+1LG+GkPyt/X3aT9QcQFHt1HT5bpy3QfvfBxYI9xpvojNc60n/foyPhk+1GevV735Wk/kcN3+w0p/lb7zSqZbvS9fR2H4N4f9/YZ24ueaO74Qkq84ktdrfJp/4V7+zvxbcxPpe4m353j4EErXVf8cId3926efJLOafR1N3npvX2Bt/b2z6IOg6iD4HRgjmvknXdFjsHAX55fKdg9x1GP+7W3r/eVJb4icmbZ25c6UG9Z7tER+EpGWqUctKz9cY5l7u0vKFm1Tqz6CA739q17gRaM+mhfc8FRH/mNOaLCJxpfv9nb5OXK/9Hj1opfnMO4fZJhexjvn1Vlnd7bl3pYe/sXHLbOWk/l2dtn27r29juQ87AdP5jKoBeBaaToZSrIr5cpQy/X295+ko64hhWYx6fMk9fb3r5usyx7+7rNkvb2ZWxzb/9Jhk8gdIWeK37qsj+3Z/RRGD8VH8VjH6rR9w3AI1D1l0fkGAz8vbvQalc9XrnHxFi5lE1Atjz3pfNdR55sW9Wy+dLuls3/Fo82n361y+afN/iJbz4LeC37dzpkJ/0LCfRZn+MG/Qcwr290t9K19gWYzzytynzHxM+iDmwHxsQF5rsy2utZyN6pfbGdeQf8zkI+2mJXjF5wuIcuMLR52reXtqQ9ZuyVMPQTBeaFDt3SR51C2QVFL+LzipgO7SjXmS/CnKL3u6x+LTCvRr/+voz9mv6qyO1j7Ul7Izz4cL4QOXzfVKR9BW3jfe8B6r5v3ZR0FHKKLGeBEz1ce0odqLcsc5n2UUlr1qBVctCaddCazklLy7XfNmxnPDpsWJZ9RsGx9vaz7uPT/uk4He2MKx7tsoU61kFb+HMp84zGZQzQmlct/0b3I87hr4Ote3d3K12uzadVWafGta6HNV+/KcVPS7MRrr5FH0vbEOqlAzkP237MeJCuF4H5lRS9jAf59TJu6EXffRwEu+cq0ZvADQS7c4D3uu8k6Yh9SmDemdHX482cnVqbW76ebjPL19P9XbfZSGD7fzK2hSbtgjUHCj3aP67r0+zP76ToXuPSrwuC3e9ql/qcQJn8/s7eJv4fYG3/6F54skxfpnvhuS+jpP/kK974SI0V7ee7GGV8sv086Wp77TYY7H6y5lcM+pHJzK8YVLpLy6+4Ed9zwz1ZKdM5usyt5v78Z1NiDg93t8qnfRDuzwvM4zE/fcGIOVh54a4Y4I5uenbz5JO0P3+gp8kraZ+PcROBuRl16OlpyqTPDnuc426Ys/fW/ryv3C5rrKSdvddnzawYic67yLo/L/CVjLRKOWhxfPPsvYwf7s/rnAnr7L2uj+Bwf37eqM8Foz7a17zgqA/HyvXoo/p6b2leH5V7Rp58r9zvrGQOuE8fdSaHTPRxfL6LMY+PStvr00fVttflo/JcOmOlItv14KP6zCHN037MIfXZfkOKv9V+55VM9OnYDlleDbVfeJaPSp9b50HQv6WP+jWx75V0t9JtDv/Ouh9KYH6qp0njdvh3+vwF6YqP6sohfVqKj2rV4etRhzz3Q92NOjz9UR911zjL4qPeaPdD3Ug+qowfHz7qjFGfvfJRmRPNva8HjRxS6ivJ9lg5XPdg3L7YsD3MK9F5LVG/9XmOcCqhHtyHE5gXOmwdaQVBkJhPpHOOBIfnCfQ+cVJurSe9OO+Hol4E5vtS9DIZ5NfLpKGXKSVDEOy2O6I3gfOdf5ykI+sOrf+UMk/uZw6ptU+l28zap0q704t+MX0hGdvcp3qx4RMI3XbP4L80o4/CHFLxUXzmauf12Rl39+mzJ+0T0me3zhZL2QRk0+Na71ETj33fk22r5rX5r74ObP6Mwc8VPxaYNzhkJ/1KAn3W57hB/39hXn9zTytdK/+EPozOOfeYV2DmXui8hl25Fxnt9X7kX+3MO468AoHJklfAXE2Boc3Tvr20petOAIGhnygwv+HQLX3USZRVFL2Iz8ewVrb2c96FOSUpr8rKjf4H9Ov3ZuzXHciDbnCuDsCDD+cLkWMw8JbXar7LSdv4TuULCX/tq8jaU+QUWcaBEz1ce0odqLcsc5n2UUlr1qBVctCaddCayklLy7XfNsw6t6Tb0cpnS7JhzCHVNiwtX5T2T8fpaGcsW2j5ptoW6n052sK/y+ib0u7dBpuk51XLv9H9iHP4J2Drbuptpcu1+ZQqu57yAP8lxU9LsxGuvkUfS9sQ6mXBv17Mey4tvQjMF1P0Egb59RIaehlXMgTB7rlK9CZwvvOPw6CpC+qIa/YdmLjfp/l6PJvaqbX5zhhw3KMnMK68X8HhOlxgaP9kbAtN2gVrDrRySLmuT7M/R1J0r3Hp1yWds9O5O9p3ZI7NCeS9LPW20qX9m1FlnY5NVpQuqMcxhx5JKwjsfCvXOpVrNmudqu8o7HRs0tKLwEyn6GWygF4mDb1o/yoIdu/xW7FJTz553aUj9imBWcho/zrgJzaynDXSbWadNdL9XbcZfWLmtsrYpg+3BPun/T/rfLs+Q+SyP49N0b217j3QodhknhwVxiZ95fLQtxb+erymxSbpl+WJTTJG1cnYpGvuvN2jzadv57L58wY/iU3q/AbK/g0O2Un/fAJ91seKTT4X8/ozelvpWjEca6+J5yjGIYtvn174cw0kMN+W0V4zl20/Y5Mh5EuKTY4rGMGhbyowtHm6j1uxSW2PdQyF9vhOh26TYpPnFb2IxI/FdGhHGZu82/Cppe2tfi0wL0W/vpyxXz8am2zyt2KTnsZ1Pcv6WscmRZYQONHjOzY5Y9ByxRNnHLT2Mja5HzbMik2GQfNJik0m2TDGJrUNyxOb1LFG2hnaOeFvrc11bFLvMTI2+ZMZ1+a0r3KGxppXLf9G9yPO4T8DW/e2ArHJToxrXQ9rvv7ZFD8txN9JMbikvkUfS9uQpNikTz9mNINeBOa1KXoZLaCXUUMvoZIhCOzYpMD5jk0m6YhrdoF583UcmwxFXvDLcne9npN1m6XFJsP4k3bBmgOFnis26bI/v5aie41Lv455lRX8/iB+L8flF/H7b8a/DwTe7pxt5D0TI3IMBv7ODpWC1vep6nzcQ0HTJ75z88odmw88c/XuuzZWr9x1+dI3bj7/vs17r5Qg3kVVFf6WVN0DKDuD7yeM3/kMA54qOqN4nFF0uOV4xpBd8LQqIpikK2qPGzLR/Pu6yrhotxoIHn3VgkumL9PrJerc/s4i043yyvubIZsOJ+v0wb28Fp+2hu1HefZ6msnTfiKH7/a7WfG32m9eycRjyGwH3Rf0KxL2E49H0sQGMjVbvwqNLhaPpP0LXBbrONdne1vlE9fWOpImMM/sa9L4HJZ3gkP7O486l4LW1y+Q7pdS3LayUYegr8nrvKqDwDMctyMj6tDV15RJX1nvcY5rsE4BePCx5rhB4PkYZ9o/sY6k+TrObI2VsuIvoTeRUx8DsEJvUgfqLcuRNIGvZKRVykGL47uMMhk/PJIm30VWrRPL9xQcHkkT2rxO9bRRn9OqPqeD5PrIb1F/rsbfhU80vkbj8TUQeOu3uZdGIofvpVFZ8df9gn4u+wCXliKbbt+LihbxxgrizRXEq6I+B+PvXD7P9zV/H4jLD+L3D45c+855hHZXz0+iK9r8neOOsO1f39dKl31/XpV5vNKizjCurocVxl2KZffxivMydKDDwdbRUY96qVlbaZZeBOYJKXqZLqCXaUMv+gq1INg9N4neeEWlp+NddZeOmJ4iMLc5dMTwI9cT+5kapNvMSg1KOs5Cu2mt3/Q1xLQL9BuFrtBj+JFHDNPszzel6F7j0o/12IdqXB8F4BGo+ssjclzvrxukT5HnejqJsXm0bVXL5ku7WzZ/3aPN59rLZfMvGPxk/WZdKSIwz3XITvoLCfRZH+sVAT+Ief1SXytd63VOTKvo4GsDzHRXnUrKVM77Mtrr/XglvLWtPgn5aIuzpHJyC12nrVn2wNoO0tvh2j6w33y/Q7eMrXEbX18BFfF5HXxY6zWRP4Q5RaeyW/1aYN6Efv3DGfs1/VVPaY0NztUBePDhfCFyDAbe0lsrru1Cxic6kaIt/LWvIvEJnVYzCZzoYXxC6kC9ZZnLtI+alOKp5zeL1ryD1rmctLRc+23Ddsajw4ZZabZJNoypQdqG0aZwa1z7oVYsl3bGioW1e6XGG1PmGetKjc860hUt/8b1Wvn/Dlv3/r5Wulybn1NlnT56IfWw5uu3pfhpaTbC1bfoY2kbQr1U/OvFfIWXpReBeTBFL1leN6P1ctbQy6SSIQh2z1WiN4HzfeQrSUdcswvMezL6eh1IoWxkSQPXbSYwruMIus14JIP2T8a20KRdsOZA69U/2hd02Z8Ppuhe49Kvi/rdobj8cPy53TaQZe/aplqO6HWhDowfd6NcYD6SMva68HeEPx5/P6DkJ4zg0Aftw+9BDCNwfcAnbKjoCl8Lj3IeUjhRnzms4Ibxvd9RF6nDKcAI/d4gWb8C8zcO/Q6gDj76QR3ydEO+PpQLzD+k9IN6sFsvVj/oUzB1fI8ejgWB7cLvh4BP2BDldfC18Pi9S+FE/aBfwSXx6QIf+X0UdEIFZ40V67hgUt/hmBWYz6XYHY27bXcONOslOqbvTHl99zerbgJT6k+um9XfrFiB1rfg0O7Q3sin7pcath/l7AcWHuXsUzhcH9XBR76HQXJdLLsj9F19R2BucujX9/zTgDycD2gfBeZISj9oBLv1YvUDbbMbSi9F5x/2gwb4Wnj8Xlc4tBd9KXxo3+R32p1+BWeNFcvuJPUdjlmBGXe0yZCBG9HcgN0J43Lxn3zPc+xXrFufKo+emZT+pvuSlTOh5znBod3pVzJwnmN7E5b+cB/4WniUM1Q4jKVw7pXv8466WHYnjL/rvkP9Ckwjxe5oX+vW+O9yW4/t9+rxRb93JaUfaHts9QPdHtoucCwIbFdg+7eEZT/g/GPhhUoG4nD+CVP40L+W32l3phWcy1em3Qnj7y5fWWCenNHudIPmV8Pu6D0r3/1N2xeRj/1NYL4upb/pcWjNc7q/CQ7tTqhkyNLfuF7uB18Lj3KeUzg8tmjNc7Q7ui6W3dFrdEu/AvNtKXYnBF3f84/IF6ry6PnOnPOP1Q9CBaPnB44Fge3C74x5JeWs0B5YePyufSvanXMpfDjPye+0OzMKzjVnueI71pwlMJcz2h36UBOwO1LXKvjrvTwrvi4w9/U36b6sv5Uu84t0/oK/vn0tRtmfUI8Q5QLzopS+rce8tXcSKhjBsa5PDg29VPzrpWaNeUsvAvODOcd8Fr10G3rRdicI7GupBM7f/Hit7yTpSPep6PnRlDG4n1fm7+xVKX7yJO1J6P6u24zrOe75ydimDXsZeGfZ32MsOs3+vDxF99b+3kOla9995njmzT0TOXznniXtLzD3TM91XJMxBndO0dL9iHiSn+3xKrAqbY0et9yzFZj/lmLbQlU/K/dM60BwaNt0TgHnxzmDX3eQnHsmML/okD1pXg9Bn/U5btB/L+b1txrzunXVYhVloSrzF7e7Nqfp+G2Iukq5wLz9+rHXLXkbO/ML+OkYGdc5lIkwOk47AhjavFDhSVu6coG1D8Nc4Hc5dMs8Ea67qopexOfvY4Ck3LPfgX44tpP6tcB8Ev369zL2a/qrnnyOBq+pCMCDD9tY5BgMvPmKFcsP0Dbe47iuW30/VPwl96wfMEHQut/B3DPdf7POZQJvrQvnDVolBy3XGjPMSStUtPbbhlk+p25Hy+dMsmHMPdM2jDaFeRYyZkOUiZ1h7tnfe/RN/6mAb/rReNBb86rl3+h+xDn8M7B1Rwda6XJtHqqyTo1rXQ9rvv5czv3WMP6epW/Rx9I2hHqp+NfLth/TyKCXnf28AbdeGgX00jD0Yu0dh/iu9/V8r82TdMS1ucAMOnREO8n9vk6tzXfGAPjpNuOeqsDoOVm3GdfmIcpkbHPvU+yCNQdauWchcNPsz/EU3Wtc+nU8vxqCvz4XK7bROpd2eqBJ93EDrXRp/3S8stPnYqUejL0KzNmUcZ7UblnOSHHNNqdk2I9zsf0Z9CIw8yl66S+gl35DL1bsn76C6I02hOt633HtqpKDOqpltH/Xy7nYtPVGCfUUGN1mI4ChTbRik4+D/dPnYrW/aK2FXfbn1hTda9yI5ssRm/QUB6zdyPdVWe06p2S2+sicokW8+LiHz3Fbpa1xjVuB+boU26btltaVpQPBoW3TcUjOj2MGP4lNWvcaCcwzHbInzeukz/pY5wcvY17/VmNeZwxnTvFiPFbKPPqrZmxS+NOOC8zq9WOv92xdr2264HANvzOnA0/bY2lLlz0WGMse3+3QbVIcIVT0Ij4viekk3TP2fMwpHNtJ/VpgXo5+fSVjv6a/6mlfpXGjvGJF23jf61Dd9/Xet8Qm9d61KzapffCsc5nAzxm0zhu0Sg5a5x20ZnLS0nLttw3bGY8OG6br4bJhjE1qG0abMocyfdcP7Qxjky/x6Jv+dAHf9MWITep51fJvdD/iHP4K2Lp3DLTSTcsb6sS4duV+CMyrU/y0NBvh6ltW3lC/oZeKf72YsUlLLwLzxpyxySx6aRh6qSsZgsDOG2Js0tM8WXfpiPEegXlrRl9vDrJf77FJPSfrNrPuSkiKTb7D8KOEbp69Gcv+/EaK7jUu/bqo38l9AGH86e+ux2t5uhXUgX52GeUC856UsafvAbXWjmUFo33jSAcXlQxdQet9shr2Asp5LsHCo5wLCodzpnVX6WyQXBepA/O1hb7OcaB+BeaDDv36u7f+Wj+oQp5uyHcR5QLzRyn9oBrs1ovVDy4qmKrSC8eCwHbhd96tS1j2gyr4Wnj8XlE4vANvIYUP7yKV35mvfUHBWWPFyo9J6jscswLzUIrd0bgRzSPwu0RG5tP57G/s/6wb+5vAfDylv+lxaMXjdX/TMdui/Y3+80XwtfAop74/OOonYwpuOGi9m9Kqi2V3eG9wkn4F5nMpdsfPvd32/CPyLaBcYL6Uc/6x+kHSndy8L+eCkqErsOcZwrIf0B5YeNZcxbusZxVcEh/Oc/I77Y7ej3TNWbQ7SX2HY1ZghgavfabZnTJofipo1kv7Q777G/s/68b+JjA3O+pmjUMrfzLpHTW0O0X6G/c0FsDXwqOc+k5o7ldwDMj3WUddLLvDdX2SfgVm3KHfgcDX+2fs+UfP65x/plL6gR5TVj+4oGD0/MCxILBdgT3PEJb9gPbAwrPmKuvO3/MpfDjPye+0O/oucNecRbuT1Hc4ZgWmntHuXATNPwya9dL3E/nub+z/3UFzb5D9TWAem9Lfksahq7/RlxQdFOlvXC9fAF8Lj3LqO3EZw7X861lHXaQOtDs6RmnpV2CenGJ3/OxF2/OPntc5/zw15/xj9QMd39XzA8eCwHYF9jxj7esGwW57YOFZcxX9Xn3XeBIfznPyO+3OnIKzxor0C1d8u1fRYd95Vord0bjR328JmvWSu7K5zhqHLHsdW51AHVi3cZQLzFpKf5vA30nz3LiCmYAeRAehksG3Ds5m0IHA3JXSvhI75Z3nndpj2mlL8NN3CgqMq00ER/QwErS+druE74JnjZ0zoEUYwe0BzBWHbrn+lToMGfSiv++Ovw8Eu3NJ9nIfmLwD8AiUTuTheD7jR6bt9wGO5ZBJ5Bj0qCf2AeEvvJhfFSqZGGfl+91CRStUtPYSLyqTNhaZh/Gde15jiv6YQb9f0eI7fJjH8aODrXTFNgk88zgEZvRok8aPD7bKSxvba9ShF985Vq069Bp4QWDX3eoDgsN3ZgntMw48i3aoYATnKGhrO2HhWbS1bRScI6At/Dhfkc9e2508YzyETJ7m0EreM4TU04RHmcZzyDQBmc56lGkih0xnIdOkR5nO5pBpEjJNeZRpModMU5Bp2qNMUzlk4jsu9HzBucbysTgHSn/h/WRnFb+oTPTVgzKRV2ws5eoBLOdJ3oFXAvww8ATmHSnrZD/5DtUK35USgAcftgXzAn31D+pO+Ot7qKK8vFuCpt4jIfTZ211JNxQ2y0FhffG3x0MzlbwvLWHSheCdgJyzHuXMk0TKl0vMGHJ6StSv8KXYWeRkYp/gHYo/kxzLD8Cx1AnCAn8K5QLzL0eaND4Ex1IfQEo6tMQkq5MKJ3qsQ00WPo2WdfD5T1MMkqeDLdsLrx7Fz9V2PNjS40cm82CL8OLCa0bJxH7PxYE++KET54jXWxCPQRM/bVVb9BfAvXbAKY+tETl8J6zrIK/uB/42N64F2HSQ1UpYZ7voIPGCgueii3rTi8UzCs/qaxFef4p81iJXcE4bMhGWSary+wkHXYt3j4LRgTbyJmxvCm/qh3qw8PoPNn/7EuYRX7rbS92wDaKHDuQZlMkc2I+yWdAR+Q4dbKVzwqBzwqBzi0HHd1Awj01iUNCnTdJjVbctL6XigoiLKJFN90G98UC8YwXxpP19JrsPBbv1IjwCJac8Isdg4K3/mJcxabvKYDjbR8roM+sxbQUZpYzrmF4/9auznwXgESg55RE5BgNv/aCSxfZFOvHkO9Ysn+GMwd+Tz1C1fAY9NiOf4WCwe64KglYfgklT0WMdasm6vhZ4BjbOpMjJtZbACM5pQ6Y5B55FW/vX+rBqkq80k4F2kt/G4LfeVO8KWg/fleJ/vFCb/LsA269wfF6Iknfsixy+x35a20R9P1rri+8h/ob4GNKXpN31mtrXWJhOkdvq04LjGgu+A7t5+sA0ZPIZC8oT4KSefPkBPMSaRSau5Q96lCmPv3QQMnmKN9bp/2eRSeQY9KinUtD6sm/hZcWCrBjoIGTLE9M50SYebU0H2q/xSG2/dtuhU3g3oUzPb0ziO4oysQFco1/CGl30wVj4PQdb5ZNYuMAfQbnAvBCx8HsPNvlacaWDqDP5cDNNYO4/uJsnn6Q6PJChDtZFNl+LOnwP6iC65Rznyfdq5N3voB3ytVfk8qe57vE0znddsib8ZxV/udxD5NQxK9GZdbkH9Zblcg+Bn8tIq5SDFsc37ZWMn1tAU/uVWidZ/cozRn2mjfpoX3PaUR+OFZ8+ap6xcr37qL7WTnl91H7I5NNHzbO+oI/jc92bx8eh7fXp42jba/k4vUomxguHIFueOOOJNvFoDzrQfo1Havu12w6dwivio+p9hIjWO+Gjij7o3z0I/07o68v86KMKzB8cbtL4Lfh32ldgvbsVH/qoAvPuFB/VqsN7M9ThuFGH16IOv4s6WPOupz6d+wI6kcP33tlBxV/7Qz73S6w9V2s//yjk1DF6y0eVOlBvsyn15LpxNiOtUg5aHN+0VzJ+XD6qtVet62P5qP1GfaaN+mTxUQWeSZ998fePYT//r2CHxHaJbYx+f9dIUxahaR2ICFEm38dRJt8nUCbfz6JMvk+iTL4zCXcK9Tqr5KaOxLZNgZ7gCcwnHbbNn29fLZxYPBj4S8C2+rPw0smsZyG04IRSNhwDBkrYw4r4YUWc2cvym+8FFmUSHoGSUx5mdwsek0R9LibyLLrolEwbcvZ5lDOPg9oHOQWPyaxW8KvvUJOuwOrgF5NZBeb74FgMxoXDgJX2ZN+lzmloTyqcAGXkb+HTaJ1Emfx+OJYtySB5OqWyvTg8qfi52k7kGASeD4OkT7IKLy4uppVM1gRuGTdr8pSysYJ4Yfzp0W7V8p7e4eTh65STpSfdVpFODnnSieUgn1X8D6t2EVnm40+9cOWNA9SbTrDWN0rxtA4TmsMU+azFtOCcNmQirMDxVgLXZozF+6SCEZyjBm/CzqTwpn6oBwvvcXGjRHa6Cls/nUH+UMFYjrbwDB14WXQjONSN8BNYzmEzKBMfZxplo6ATPVH9bz3USueEQeeEQecWg47H+aOW10fh/OHLv7PmD227eYqV84eU8TaZUNEKFS3i0X8N/dSvnnceCONP3/NAqPjr8URfI4TuTuK7yKbHnZ5TiHesIB6TfD35MnX2swA8AiWnPCLHYOCt/1QsPem26vScPW3w97ReqVoB4FDxl4RT0ZPoQuQW2YQOk+ykH4eQfyTYzW9E8aMN4Tg4nCJnBHNMwQjOaUOmYw680KB9SsEIDuc/4XfKgRcatLWNFhwmnAo/ge0CHOtSin8LlSyCI7ChwhlQcu/n2Bc5fI/9tLaRhFPxPcTf4O1aAhc9x5T8vsbCbIrc1njRsYRhQ37OXd3xv0mFdwC0QuD1oPy+eEcysgnfC9/rekwU8HmbQx5/kLc5+LyJI0/QlTdxhB5lKuLDRTKN+pEpt70SOXzbq1HFX3jRrzylZBoJdttTkU3bvlOKFvFOtInHRIEw/vTYfo1Havu12w6dwrMSBUKUiQ1iogA3wqInmjteh/W/4DMW/nrER0RfEgsXeCYKCMy/IsbyC4iFy++0v1KnbsWHm2kC8xZH7DqpDr+UoQ7HjTr8PurwK6iDlSgQoj57Pc7yzCdh/Ol7Ey9U/K1EAV9zhzVWrE3Eo5BTZGFfix4rUYB6y5IoIPCzGWmVctDi+J5CmYwfV6KA1olVHyt+edaoz7RRnyyJAlYcUuKUvA30/qEmr1GDF/fbOG45ngXm/2DcftKwPdOol95Hi/rtMVWvW+O/y+09da4ZdD2OoVxg/shh60grCOz5wrVeD6EDHduiXmb966XGdZpLLwLz5yl6GSmglxFDL3rNGQS77Y7eo/UZ23PpiHu8AvM3KfOk3CY8Ctk79Sa2nTEAfrrNdN6GFUfUbcZ46ymU7ex7x5+0Cy6fkbcNnwJumv35TEYfZRQ0fwlreE8xohr3bgLwCFT95eGaxtNcbsaIhJcVy2e7StkEZMsTk5f+43HcVmlrXONWYLrieTDJtmm7pXVl6UDHI2nfuT9h+ebHQCfJNxeYQYfsSfM66bM+xw36ZxHzusnwF+ivnFS8GN9lHKgT+w7S7sKfOUUCc4tDdx221/Us9lrvqVj2+pCCERzRwwhgaPO0PZa2dNljgbHscejQLeMmh1Gm49ARnyfFdGhHuc6cGmrKx7Gd1K8F5qno1zMZ+zX9VcaW93rtSXsjPPhwvhA5BgNvvmLF8ns7mANUt/r+McVf1p4ip97Ps9aeRfeXBf6kQWvUoFVy0Bp10DqWk5aWa79t2M54dNgwXQ+XDeNb0rUNo02hryFjlvZPx+loZ3z4prenzDMalzFAa161/BvdjziHfz1s3eWhVrpcmx9TZZ0a17oe1nz9zBQ/Lc1GuPoWfSxtQ6iXWf962fZj+jLoRWCenaKXviC/XvoMvehc7iDYPVeJ3nho0ufh+iQdsU8JzFZGX+8kZN/PtbluM8vX0/1dtxnz72n/rLX5ZcOPErpCj/bvGHDT7M+9KbrXuPTrGLscwe/3Q14eDEra25cyxk97UH7vTU3aL4ppX6/76JMeZcqz7zEJmXzu7U/mkIl7+xMeZcqztz8BmUI/MtXzvo0kjD8HPerJ2rMSXowzjSqZ6BcPQTbtl+k4DPFOtIlHO8n2ozx7ve7L034ih+/2G1L8rfYLlUzM79qvt33lxePevtjACZSJDUrb238N5i3BZ7zidUOt8on/IvDc2xeYz8CHfwN8eMGh/R2Pv0v8cELJ2QOYN6fMzdYlAG9BHSZUHaxLAATmfajDW1EHwenAHNfIO++KHL7PM0wq/tYFwZ7GeZ19RvjrfWWJr4icIgv7WvQwvqIPrJeCbJfH6TN+abRKOWhZ++NJe/tTSlatE6s++i1N3NtnfaaM+mhfc8pRH/mNOaLc238ODvlLW3FMSbvpccvxLDDvx7j9J8P2MN4/rso6lZOi62HFYT6Usk7We2JSF7a39iUEh20bKhmol2n/eqlZsXBLLwLz0RS9nCygl5OGXnQOYBDstjth/ClwPnP3XTpinxKYj2WMH9BX7FT8IBR5wS/pXCPbTPd33WbMfRxHmYztMP6kXaBPIHT1eVPan94g3f58OqOPMgGab8Ea3tc4e6Tm445Dtjz5sdIOHsdt1Rq30u7WuC3Fjn1W2xaq+rnGCf1qnevIeeCswU988xDwWvZ+h+ykP5lAn/Wx9kDHEfM6dFMrXStnbxJlJ1WZx31RM19N54IxF+uoQ3e01yFk79S+2M7ejSMXy4rR6z1YweF+l8BY+5CCJ21JexzG33sVDMeawIw5dJu05zap6EV8nhjTScohP3tTU76kXFT26539NvTr6Yz9mv6qp330BvdEA/Dgw/liJ8cn8HsXi85v0jbe47iuW31f7wnL2vMY/g6AZ609df/NOpfpnDfSCg1aJQet0EHrZE5aWq79tmE749Fhw6wc4CQbxr19bcNoU7jfL2OW9k/H6WhnaOeE/4SCp//Uq2AEl+dVnpwyz2hcxgCtedXybwTX8m+eBlv3vJta6XJtrvMIOjWudT2s+fqbUvy0NBvh6lshdKBtSIfzu7b9mKEMehGYb0vRy1ABvQwZetFnpoNg91zFuTx6fJ/ZSNIR814EZiOjr8e4QqfW5jtjAPx0m+nz8dacrNvMyveiTeRe+fMMP0rohvF32j/6aGn25/kpute49OuCYPeln2IrT6BMft8YaeK/MMZ/dC88+1546FGm6+yce6VoXMb3XSGPxHMgPHuf5xzIiTbxrHzxASXPXq/d8rTfID59tt+g4m+13ykl041+9l5sINcHYoO4Px/G37k//0rEHKzzBK9yxBwEnvvzAvOx4SaN18AP1/4/1xeu/XmBeX3K/Grtz78RdcizP/9O1OHNqIPgdGCOy332nvcN+jx7r++y6vT+vI7pJ529FzlFFva16LH256m3LPvzAj+TkVYpBy2Ob/qyYfyd+/OTSlbr7L2uj+Bwfz4MWuszadRH+5qTjvpwrFyPPqqvF1rk9VG5Z+TTH5zJIRP9CZ85pHn8Ce4r+7wrfCKHTLS9PnMQte21chBPKZnoOzBns9P3Q+lcwkdzSO32O6tkok/HdtB9Qd9rup94lo86gTKdB8G8Y/qoH4ePKrTp333C4d8JPH1UgXk8/LtPGz4q7e940Kxzko8qMP+a4qNadfi3DHWwfNSbUYfPP+qj7hpn++2jjiv+WX1U9rXouVF9VH1H+176qKNGffbKR2VONPe+towcUupL2k2PWyuH6wTG7dJwK91J1GtclXU6D1DqYcW7x2LZ28mVTMon4nmCUMmQlFvr694a7kG49LJzXjhFL8cK6OWYoRcdiwwCO4eU5zhD8NjrvpOkoxDlArPg0NF+55BaZ/V1m1l7i6GC0W3Gtfs4ymRsc69J7AJ9AqGr43u0P71Buv15bIruNS59FN/3Q+Xx2RnL9emz67Fo+eyufYFxyJYnvh/Gn52+H8p6d5fA3J7TtmldWTqwbJt1P5Tlm+v7oSzfXGC+wSF70ryu74cSGOt+qOdiXn+GMa9b+Sf0YY6psqjdRyDLXs9pOq9A5zXsyr24fux1pvuh9DrbujNA59EIDvUgMLR52h7nuR+K9lhg7nTolj4qc/2sPP8fi+kknbe8G3NKUt64lRv9UvTryxn7Nf3VR++HuvZw7elpXNetvp92P5TIMgSc6PF9P9SEQavkoDXhoLWX90Pthw2zfM4s+WxJNow5pNqGpeWL0v7pOB3tTFbfVNtCyzcVmJ8s4Jt+ArEvPa9a/o3uR5zDfwa27m3DrXS5Nj+myjo1rnU9rPn6Z1P8tDQb4epb9LG0DUm659KnH3Mog14E5rUpejlUQC+HDL0wdi+PdT+UwHncC6m7dMQ+JTBvzujrXS/3Q+k2s3w93d91m40Etv8nY5v3Q73N8KOErtBz3Q/lsj+/lqJ7jUu/LukODP3OCet8qcD8Juzfn6fEJkdVme/7x48l1MPS43tyrlPz3GNsneM+aehlyr9eavQ3XXoRmD9I0cvhAno5bOhF+1dBsHuPX/QmcL7j2kk6YvxWYD58HccmrfOSus2sOUvHsHSbcc+euYTaJ6RdsPw/63y7PkPksj9/laJ7a937RsQmfY0z5lUE4BGo+svDnGBP/dp8t6nOxWCfoa9/TOnRsom6HxGPMSpPa+mqNW6ln1jvK/l0TtuW530lzE3Qa86kc5GHQYdjcNiQ/eGU2KTO6dH0WZ/jBv0jODPyxeFWuozhWPHYw6qs03fX63toewDTHdftOjjzVM9y5knfVWqdeUq6m5frLYGhzUvyWWiP6csSxvIXhh26tc5YMQeIPmojBqAdZWzy5pGmfNrPs/q1wDwW/fo49uhd/boD6/UG1yoBePDhfCFyDAbe4qUVa+2qbXyn767XazWJTYqcWe6u1+dYs85l+v1KpHXKoFVy0DrloHU4Jy0t137bMMvnbOd+cevueuvcpmsdbp1zoZ2xfF7r7mZ9vlPfXcN9kJWUeUbj8gyNNa9a/o3uR7TFT4Cte/ZIK12uzQ+rsk7fXS/1sObrr3HoMYuNcPUt+ljahlAvU/71su3HDGbQi8B8bYpeBgvoZdDQi3V3Pecq0RvvrvcZ107SEeO3AvOMjL4e4wqdWpvvjAHw020mMK54sm4z7uHQ/snYFpq0C9YcaN11pH1Bl/1ZS9G9xqVfx7zKGfy+hd9n4/Jp/C53d3p8t3wj75kYkWMw8Hd2qBS0vk9V5+NG41d84js3r9yx+cAzV+++a2P1yl2XL33j5vPv27z3SgniTauq8Lek6h5A2Ri+nzB+5zMMeKpoTPEYU3S45ThmyC54WhURzJSCEZzjhkw0/76uMi7arR591YJbJro0X0avWqjnvV5C5Bj0qCdXCgBDkONKphGU3QzZxhWtcUWLeCfaxKOtYftRnr2eZvK0n8jhu/1uVvyt9ptQMjEdh+2g+4JO/9xPPB5JExvI1GyxQTySxiVV9EQuyc/CZbGOc71ypFW+LEfS/h+Wd6/G8k5waH8nUOdS0Pr6BdJ9XYrbNmvU4fWow1lVB4FnOE5gPow6/ALqoF07j3NcbndO5PDtzmn/RHTC0Juv48yurTodehM5daqVFXqT79TbVyg+X6H40O5mpVXKQYvj2zqm5jqSZvmV2vcUHB5JE5q8TvW0UZ/Tqj6ng+T6yG9Rf55Tskfj611YGnnqtw3ahwA8AqWTQNV1EHg+xpI+JqjHkrXcZL84B9l0++pXWxDvTEG8/oJ4c6jPQPxd6hr1gQ9iLhIeA8DpUvyjUAHnFNpgPVfpV2lwTvkI7PzDxlzFcTChynwfQxtLqEeIcoH5i5SQm16vav+iBLoCIzh8bfK4ksE6buJRL9uhyNEMehGYv03Ry2gBvVivkx5TMgTB7nlK9CZwA8Hu41R73XeSdDSOcoH5ZMZQJNcWnQpF7owB8NNtpmMv1jpKtxnXUVzLydgWmrQL9CGFrtBjKJIpPWn254sZfVq+Buj1mC899aHcRxhFDt9HGHW76vHKayIFlsdVOZeHilaoaBGP4zb0U7+qNW6to8c7rw2O49k+bBvXYS6bP2nwk7XcBOC17EcdsltHsjR91ue4Qf98TH87neJwK12meIaK136kvvJ6XLYDU1kEZsyhu/0+/mNdIX8C8nFrhv1Qp/sIDlM4rWPIei0Yxt9dR8oFhn6iwMw6dMs1jXUEiXb/62I6SUcYFw435QshR1K/FphnoF9XMvZr+queUjhzX6W6X1fhhvF3xip8pvrrvq/T0CVWodPvTwAnehhfCOPv1FsYuOs5ErS+kpe0JgxaJQetCQet0Zy0tFz7bcNEDpcN0/Vw2TCmCWkbRpsSokxf3WPFdWlnLFvY7vUaT0+ZZ6wjjK/EGjqMy605XNu6EOUC8y2wdd99uJUu1+ajqqxT49p1FFNgviPFT0uzEa6+RR/LdYRnxr9ezOuFLL0IzJ0pemnnaBP1ckLJEAT2ER6B832EJ0lH1hVMlzP6eiFk79TafGcMOK4X0vkV1pys2yzpCI+MbaFJu2DNgUKv6GuAvidF9xqXfl3U7yQtTdKOBmIYkWXv2qZaLsWySx0Yd+hFucD8YMrY68HfES2x4WzHXgUjOIyL9SkZugDXB3zCMm2yF3wtPH4/pHCYgtxn8Jl21EXqQDtwCPST9CswP+HQ70DQrIuPftANebqVfCyPnpel9INupRerH+i+0q30wrEgsF34nembhNXps8LXwuP3PoVD23EoBx/5nTZIp+9bOrJigkl9h20lMD+fYnc0bkSz71CzXiLjHPizD3B/kOnOAvMG+F2/fbiVLv2uXlU2ELTq5tb473J7z/bc2ZVQD+pRYN6S0re78DfHyQElP2EEh+vsHvyu9TLrXy/bftf5IF0vAvM/UvRyPsivl/OGXrrwuzy0s7QF0ePPLl7rO0k6ol0UmN/I6HcxtbxTftfOGAA/3WYC47LTus1GAMM5VMZ2F377bfhd2n5aR6d7gZtmf34vRfcaN8J7b/yHPx/r2p7IQSWPK8YlcgwCz0eMS/suOjU/kttqVz3+rD7So2gRT3IIPI7bquXPWONWYP4kpz9jHWNI8mdo27RPxfmx3+AneyIHAa9l/8uUPRFrXu9WcgrMcYP+5zGvP2TM6/TbexSvYdCRsqjdLyhZbo3/Lrf3bM9pC6oOwv8CygXm49ePvW6JJ+7MO+C3APloi9kPLyiYBXyPnhHA0OYlrctoj+k7Ekb7idHzbyl7ItJvzqNsTtGLPsdiArSj3BP5IuYUPbatfi0wk0fAK/6e1q/pr4rcPvZEaG+EBx/+LnIMBt58xYrlK2gb73Fc162+3634y56IyCmy6P7PPRHtg2edyzi3aFoHDVolB62DDlrdOWlpufbbhu2MR4cN0/Vw2TDuiWgbRpvSgzJ97ot2hnsiYmd8+KYTMe08vumD8R/WvGr5N7of0RbPwNbddqSVLtfm3aqsU+Na18OarxccesxiI1x9iz6WtiHUy6x/vWz7MReDdL0IzGKKXi4G+fVy0dDLgpIhCOy5SOA8zpN1l464ZheYr0wZg2IneyB7p9bmO2MA/HSbCQzbTM/Jus1GAGPFNYUm7YI1Bwo9ly/osj93pOhe49Kvi/qd2EfaP33lgoxLrvME5htg/+450kqX9k/HK33Hl7oT6mHp8d+njPN21qn0d7OsUz3qxYxNWnoRmO9I0cv5Ano5b+hF+1dBYO87CZzHuFLdpSO2n8DcmdH+cc+/U/ZvR6+O2KQ1Z+k1q26zEcDQJmqfkHahFCSfr6H9o6+WZn+upOhe40Y0H0Bs0lMcsJb3rKDI4fusYJL/zdik1a56/Fl9RO9LEE/ORXkct9Xce+4ptk3bLesMX5Y9d/ZnKRNaZwx+EptkfFPL/iMO2ZPmddJnfawYzs9jXv9xY17vB69exctaV3U6Nin8rbXOT10/9tp7bJLrdYGhzdP2WNrSZY8FxrLHP+fQbSSD9BsrNkkb/R7EJvW51ej312JOSdpLZ7/e2ctCv359xn7dqdgk7Y3w4JMUm/TkK1ay7D13OjapY1pFYpPaB886l+mYPGnNGLRKDlozDlo9OWlpufbbhu3Uw2HDrByGPLFJ+ib9qv70Q2n/rNjkezz6pr9bwDe9B7FJPa9a/o3uR5zD/xC27hNHWulybW7tw3QyNin1sObrD+eMTeaJe9PHsmKTQqvfv17M2KSlF4H5s5yxySx6uWjoxYpNcq6yYpML4OE7Njmj+FNHD2X09Xohe6fW5pavp9vM8vV0f9dtNhLY/p+MbaFJu2DNgdbeDOeaNPvzzxn3Zrjf81rYKbF7XDv68b+u5elyjCXFvAXmcyljT48r0b0rxqzntkgH80qGLsDNA5+wsyhn/7Hw+H1O4UR95pyCI58ZR130tbmlYHcOQpJ+BaYv7nRJ+dp+bPC1fqDnJj0vcG466JDTGqtWP0iam4Qvx4LAduH3OeATlv2AexwWHr/PKxz6q3M5+MjvzNeeVXCWjqw9kaS+w7YSmFOONhkycCOaHxhs1ot3TUSP7/tTxlEH1i1EucCMp/S3cfwd0RK/hf0tVDCCQ7tzRsngWwcTGXSwc6Y6pX1lTucdEZ1a++y0JfhNQD7q29UmgsN1jsAwZnhG4Vljh/2ZMILbA5iaQ7eM50odhgx6EcyPYjz1xrrogk76+psydwPmAGQSmMccbdJ9HHNgFN3o99uN3+VxxVOkf0R9ZcBPX9meWwaxF94NXt2ov8AMQo4e/P3ko83yg/276yO6ELqR/vslT6k/Ga9H4Y0Aph94AwpvQLVb1AZPiOUbDHaPg72MTbGto/73/wFFdhb7bLYCAA==","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"member_count","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/7VX32/TMBB22qRNW6KVXxJIPPgBidd0TAh46gSdxAObNB4RoLRxIVKaTKm7rfz1xJlv+WLSDdTkpOgu8fm7z2f77FjsRjr5Y2nbgW+mkM9Ua38/mTSI5bfJ02qQpwU8O0TWxg/GINDugC+2PwT7QOvTVPIoiWQUxNFvEaL7E7Bfa32ySRYyShO+Equ5yH4s0k0i+SJIeJrEWz4XuR3HIuRrGchI2VuEfAf2c62PsyzY5hxCcc3TjeTpks9z1HCNHWdgv9A6kFKsLiSXKQ/CkF9F8hdPL0W2jNOr23F/13rAyrxRLqf63d9PJgMg1yj226M3Cttph/ehwu61g+33c4wP7g0W8adY3fz5qNtIW/rxdDuD/h4r1zP5KzViZfvMLbGVPIZvtBYe5M9Y28Hl6uxikYbiOAwzsa4sNszJXfKveP3/wHtm4p1u4jhaRiKbXUdrWcF1a3CV3WHVGtGr4VJXuJWYa0L5TfW7v58UBZLi2xrbNTg64PPI0CZPHH+DxXfisHK9Pb2HA9bZJmuKB+NjEAPFrrFb3NOHnhHzPk7EY9hinixWXd82+/ucVLz7BqeBfkimzfDxxxCL8NU318gPxm+69qrxOgYHNe6XEK9v5Mv0x304AYxX2j6AdtyH5lyY9caCWOSDc0LYLvBQ0t0Rz9Ft1LcP2F3wHRh9PPhGPnj2UNtox1i7rFqzGPTDPTDV2t9PjhhwYxCDOKizgy5st2fHF5lmwU9xLoLKxa7ubmi+d3f4tFhfir08ZGVOcV1irsnnvdZ1tbmYSz1ZuB9ttxXuhwr2E8YmvhBvCPxs8MG9Ye4fzIeSMfhgLcE7RtNzYp4zxAVjEs+e4WMDf/I50bpu3rBWUn68GjysZ2p/9uj+B/nuu2UfG3w6wIl8PgPuGcY1cFX7t5p2kjvPaO1b1P521mHx4ziEe7cNsWwYP/kMgYcD719hPCO3Oh7KBeEW9VrbI3d3P8foNwYfF/oNjH4DY97UHJxre8iqe6zJtY9zrc6BP/U5UxQJEQAA","debug_symbols":"1ZrbbsIwDIbfJddcxHEONq8yTVM5qlJVEIdJE+LdlzJaWEFhiIHiG0jgr/slavI7VndqMh1t5x9lPVus1fBtp6rFuNiUizr2dvuBGq3KqirnH+c/K918ABz062VRN931plht1FAP1LSexO947ayspmoY/H5wIWMMRyG70EmhaV9ordFt1NjkTs18RezZwFHs403Oxe8DBeYBZtBgj0rQaF9IjY/MdMB2pvnWTIMhbkeI1qWZCVwrJqNNn9n+C3Oc6N/QTWj3vND+eaHD80LTn0M3ar5HbfRd6qt7AiCbFt9CuLXKvOvGyqcbAJkrasfcqr0Gn35iXXDtrhOb1HtijRHMjoLZrWB2J5jdC2YPgtlJMDvLZUctmF2wr6JgX8XM90iyHTu5Pnvea5W641Fs+h67ff1aJd2xI6TZAUPojkl0YkcNB3iQDG8kw6MYeMYLeCsZ3kmGzzyrSe3yLu+shro6nyPbr2u5vLMaMibBnndWk2bPu1pAmk/slBYz2nYbiHVT7A/Uyk2BXN6lhTR73mlzmj3v0kKaPe/SQppd8HHFZ27CSfbMTTjJnrkJJ9lzN+EUu2Bf9YJ91Qv2VS/YV71gX/WCfTWI9dV97H0Wq7IYVdPjmzSzbT0+e7Fm87X8+SeKvwE=","brillig_names":["member_count"]},{"name":"make_payment","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"5Z3bbts4EIbfxde5IGc4PORVFosiadPCQOAUSbrAIsi7r5xGtB3JYte27PkzN4mU8PD9gsifJ5Evi293t79+fFmuvj88La7/elncP3y9eV4+rLq7l9erxe3j8v5++ePL9p8Xbv3Dh7fwTz9vVuvbp+ebx+fFtbta3K2+db+7uN+X93eL6xRfrwbBCqf3gEVSDerX14OwgVyfandZauhSRgLHQv49cOwy2Q7899XCyxHM3vnwHtI7Dmekjsc86cT9ky6tJ+0pl14hB5lmzl76wJkcfWROJ2HuHvQu9DrpPF/SZbakyc2XtB9LWoj6MiYkvpGBr+UxbqWfeOwtkZ7al1zD0vp6mK4EVwt62ZQC9jweusrceqPo7Y0iMqGSTagMJlSKCZXRhMpkQmU2obJYUMnOhEoTbR820fZhE20fDiZUHt/28S5QzWCLZlznH/akYox9RzvzJslMb9ARETohQmdE6AIIHRwidNvVY2xBR9lAu50chqG72q4PHZ3fJD068iVJKkeS/Lo78hUImJ2B2QMwuwCzR2D2BMyegdkLLrs4YHZgXxXl9XsOlT3LR3bdZTXXqcruMn5kP39Zza6ys2+wcz8JKWHzxrDza/TocNE9LjqBoEscoDMuesBFb7d+0w76Ok48IE46IM54zc3U94iFQ+OxAozWxWJBZXImVHoTKsmESjahMphQKSZURhMqkwmVJto+yUTbJx/f9jn/NFD2iNCECM2I0KEJLeW0Xd6TjWZmAWaPwOwJmD0Dsxdc9uKA2T0wOwGzMzA7sK8W5fX71Cxh12xXDT85Tejd+WuaU81YeUfA7AzMHkDYh5NW3gkwewRmb9fwcYf9LVI+JNJ4mzXkWPFCY+ks5dTnQMV/HJTx3s2eg589B5o9B549hzB7DjJ7DnH2HNLsOeTZc5i9TNPsZXrP9/5SK2SR0tpQQP+Itd/zwf+nk8k2ZAYbMsWGzGhDZrIhM9uQWUzI3PPh/6eTaaMVxDZaQWyjFcTHt4LOP8/uWSCpIyR1gqRutiCia1JfaMrIcwGGDw4Z3iPDEzI8I8MHZHhBho/I8AkZHtlhRXk9P7kqQ3TXNtOrMuT8tc3/mOn1JdSku47Tpmv1PtcrEZo+QdP/QYUzmDKXckCk6A6JNF6lRKrTbDHwIBIdEokPiRQOiTReWFPKtXoqYRApHhIpHRIpHxJp/I3Irla5mQr+wM6eb4s/nUxvQybZkMk2ZAYbMsWGzGhDZrIhM9uQaaMVlG20gvLxraALzNFkgqRmSOoASb2nBRF8pY7SoM51INDn5LZGFdzvLNr1fWiNiVCop5RRkh0VI4o59GdnRY6NM82il/6Zd5e8HXgNX0g3fOkffSQ3OESusG74TFPwQTU8uVLh/WD0uwgyfESGT8jwuqvKBnzBhSfnkOE9Mrxuh23A63bYBjyww5IDdlhywA5LDthhySnvjMS8gS/TgUuoHCVsTRT3SnXb8X6la3iv244b8LrtuAGvvMM7Da98od3UoiPyuhfaZU6bNyAN4HUvtMubXR/G4HUvtMvV0Tr43DAF3ox5c+KBUt3r3icXthHpXvfegNe9HrIBr3vdewNe97r3BnxAhtdtxw145XY8Da/cjqfhtdvxJDyywzKywzKywzKywzKyw7a/z9YMD7z3KbHuza2nO7yse3fr6Q5v0L7r7Mk6vEH3ZtjTpTvo3g27Aa97O+wGfECG133QRANe90kTDXjddtyAV27H0/DK7XgSXoA3gSdBdlhBdlhBdlhBdlhBdlhBdtgLHE1/ug7vBQ6nP12H9wLH05+uw3uBA+ov1OG9wHn2pyvdFzjR/oTwggwfkeETMnxGhtdtx9PwSbkdT8Mrt+NpeO12PAmP7LAJ2WETssMmZIdNyA6bYB32tbv75+ZxeXN7f/fUxVn/89fq6/PyYfV++/zvz9//6QL/Bw==","brillig_names":["make_payment"]},{"name":"add_to_group","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"approve","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VazY4bRRBu78zYHu+Obf4kkDjMBY7R2KxEDkg4Igm38BOkiKOJxzDI3onG402CgAeAG4gbnEHiAeAG4ghnkDggJK4oeYa4vVXrb8o93vVPR5uWVt3TXV31VXV1dXV7K+qkOLO/CrU9ql21XJimR3W0XenskFdkE2flCcG594TgdGzgrIDTugK8NoyjlsuBUFCXl6DdovpGmofJUZIn/VHySTxA8teh/QzVt/ujUZyFySQ8mk3sD8bJEU55G9qvUX0zT7P+h3E4Gc1mRCfzRqP0bjy4FOLYJBxPJ3k4yftZHg6zdBx2LiHvKbRfpLqf5/H4Th7m6QzLILyb5B+F6XGcDWf8ce4X0H6B6itZ1r8/030Q3wvTaR6mw/CDdHo0mODEr7YQ+u2mQr/fQuhPmwr9ZQuhv28q9M81hZ6680OqfXWyBXThbdKj72i70vEB3E55Xz58VfOu2cF9qHnX7fCONOY3iDnjZ1k6DF2lD64r9KfHrlPfdTEWqEUIY96BWoS6q9DHZ/g16KuqIt869eui49abDJCKT38W7NMJ1MIeCmRgcQUWXdqqaEcecy4ITseA0wWc7gXBWYZpl3lOmQ0u2lohJmVJf+av0402tfvH47fu3E4H8ZXBIIsnhYCPcWlVOS8/fw1+z0t+N6ajUTJM4uzavWSSF/g2DHw53dpTy/ogFhxXYtwXvHr0HW1X5nk8+uQe6MAyPaB5meqnS3Ci/rv2ZV/IW+XLqIOlM60bgJzzYKoDNlt2wvVk+SyL/Uvj3heY2tCHMdsHzGxPS9gjjasm5Okz+hDkoa+6Bnof9Ni1bXEf/Ab4LlO7BXhwv/KVSgnMmH8GguZA6NUCnkx7oBbXsdPYdDOeZc4ZuiGmi2cVFuuBuBr08XiP6rIwUINvpo22K11fFW+nO1zaV9YNL7g8tlJCk+vIoyJQRXfQpQ19uPbSxQLBC+d5K+ZJDPq7accG3afIxoyB5TSEzqgr+immVviMVwF6F+YxzTtUm/zbgTlV6Md0C8PXe4DBB5mugR733Y/A4xaMs8z3Yfwzalu8Hq6dTmIorNrB1MUj4zyYGEfDop0qqugXppCPV1KmbUOf6dpUg7nyWNY8hqAP+rarzMc4YuztRvdDD2R/A9g+pjYekZiWeYCl7IiU1zVP6NRSy9crB+ikPEcVY4aCOdLmPMc39PXoO9qudKQdvBIcGHuQxoOaaY6pLotjJv3L/Os+YJBpmKRHXJ8Dj0+hzTFrXxVtLs9hxMY+i7SWnhC6mz4hNJS1K0fHtA9YFsYWR2BqQx/GZVtPD5i7sD/yujrQzzRfUm3yU1MeJHWuqOKTBabQLLelinFBEc1z1F6k0Cc/LtzKkjxWouAdXQYtOS6VkPQMTN5XdKkKGtPm/ppqk9ECw1zcxKZAjMFSbkLTIcq02ojPUlsa8d24X/htCBNLLBWDLEljMZHooANJh0V9meY7qsts74i37nmgqlvB3tVs/wbZpwktyJObQ/qrKWnB90Bd2mp57THZ4Hkmv0YfRBo8gJjmB6pNtjW9oQYGfpgQOTAuAzpilwHDV0U9d324rHPhxGTH5oWzLEaZLpxMixdHfNcOLOJsAgY8EBAb0/xMddnh0jxDZ9MlmOew3JZa2AMv5BsfLuiYnmFcKiEXjoHhJsTNgTR4uDDNr1SXBTg5F2+6mInjqc8bDHVDR9GlR3W0XZn/I01TYFaAYZ1Dy/Q/EfK7WUJjeyPwAyBvBLwlcj/T/EH1WYdWIbt+TIfW6YYGeS3Ah5tu1cbkOWwHDE64jmWPsrhf2A5VQYOZLdP8RXXZocX7gHUIDPzwsVvrUSXmDtikVl9gdoFmDzAxzT/A91+Q6wm+evyBYZzLylsP0c5/pLLjK5Hm16gv9HNBlgv6M00DcHjw/T/os18v6sO2YL7zGEbt/Xr5PE/MawNNHeb5Yp4v1k2vwX/UbqjiPthlzMC11r7+CIWXJobxKAAA","debug_symbols":"5Z3bbtswDIbfJde9EEkdyL7KMAzp1g4BgnRouwFD0Xefk8WKm7hSlKYpCd+0dkvJnyzFv0jKyvPsx+3N75/fFqu7+8fZ9Zfn2fL++/xpcb/qzp5frmY3D4vlcvHz2/DPM7f+AbSxf/w1X61PH5/mD0+za3c1u1396H53Ze8Wy9vZdYovX69m4JusQ5N1bLJOTdbcZC0t1uiarKHJGpusm/oSm/oSm/oSm/oSm/oSm/oSm/qSmvqSju/LqwMzobQ1lJCyKayPD2w9ur7W7lCytciIcRSErXHsLjI0XjPjO5jBgd9agiN/QWp6z51O1N9pqd1pQJa+heRDmZkh9MaMDveZ/VmYuxv9Gnpddfi4quPHVZ0+rurRZwIw5eHKAWtjO4Z8BdnRAOOIdRDpraODWB4nIYX+s94d8v44Ebvs3hlmB8PsaJidDLN7w+zBMHs0zJ4MsxvW1aD8Gck+s3PYZ9c93jlP7LvDuM9++fHOLrMTlNm7+vIEH9xuzJALG3i2DC+G4eMbU8nAGT7FMryn2DsJnlIFJ7mEW+PkeN/hjPXJYZKX1+GAiCeUoRPK+NEyAtlDGjrQ494U5OBDHDhTicb6Lbhc767XcH18WG/wLkc1ZAdOQOPWeawN3Gf83wNhEq2Mk2hlmkQreRKtlCm0MrlJtBIm0UqcRCtpEq30k2jlJOY+aRJzn/T+uQ84jzunTCrtPDKhEmPsXTemV37eGpotQotBaHYWoevzhgAVaPQ5GoApvLrCCA3tAg0klbQsSZ9J9s4PwgywQfcXR/eU0WMFPULou7I7pL2gBI8O8C7z3D9+0Hk5b3znbNFYcYbZwTA7GmYnw+zeMHswzB4NsyfD7GyY3bCuglP+gC+lObsLq4Yv5jnBXf7j2pJuo9QPGyCO+/PgLgNnml4s04MzQy90SA+m6dE0fX1KHMKQflPIn1IonFIonlIonVLojQiVpFwI6dNCEICUQzI4WEbedyPCxenPFoUAjLrhM0dElw7gk254xhI8q4ZHJxkeDiaqKIbhyVmG1/20qcCjZXiyDO8twwfL8LoVtgKvW2Er8JYVliwrrLessN6ywnrdCguRd/CVt4jFZw7xA8+8b6luOX67pRt43XJcgdctxxV45Q5vGV55cqOYHwi6Vw1w3sMhsD/w1oPuZQOMWILXnVbirGgdPFdEgXaL+SgdhLOC7lUG5RxU8Jbhda8zqMBbTl0G3SsNKvC6lxpU4HXLcRk+KpfjMrxyOS7Da5fjIrxlhY2WFTZaVthoWWGjZYWNlhU2Xf7lhPOlp494V/FT4Yvp6SNeQfxM+HIU9Ig3CxXDB8vw0TJ8sgzPluHFMPwRr/0phtetsBV43QpbgbessMpfvazAW1ZYtqywrFthz5ieZt1yXM4zsm45LsOLbjmuwCt3eMvw3u4unSC6t9Qtp6dF+R6jxfS06N5UtwKve1fdM+bWRffe9sVAIjrdm9tX4HXvbl+B1711cwVe9/72FXjdclyBVy7HZXjDW36jUy7HZXjtclyEt6ywYFlhwbLCgmWFBcsKC2YV9qU7+zN/WMxvlrfb75W8+736Pviayae/v/7/pzP+Bw==","brillig_names":["add_to_group"]},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"admin","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"]},{"name":"in_group","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"group_member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VXz2/TMBR2mmRNWqaVDRBIHHyFw0gH0hDisIltF9CQ4AAShylb0hEpjavE3Q/+euLOb/nqpeumJYdZap9jv/e9z8/vOY7Frppd/izdd2HMbKSzo2XwsDZsECtok6f1SHh2GuRpAU+byDo4AIvo1CxK6bjGmGrr0F/T8lBInmSJTMI0+RdHqP4c+u+0PJhmJzIRWWlzdJqL6YSfhBkXWXrJj+Oyn6ZxxAsZykT1LxHuDfQ/a/lTijw8jXmRljQCnpX/pZk4j6NNjnMFH08LqYBzyUe5GPPhJmJ/hf4rLXfzPLwseUbxBRdTycWIH4tpFhVo+Av6r7UMpYzHE8ml4GEU8fNE/uXiLM5HJbHreE609Fm1B7RPO/o5eFgb+kCuUeyPH7YV9ko7vN8r7G472IHC/eJdYRF/8qXyfk/PkbT0b5VVtUP2q6yqqz0Yo9rZ12NKPGHV/IFX+VNtA8YoP5T+QPfDs/H3yYmI4t0oyuNiLgExTre1u+J598B7aeIdTtM0GSVxvn+RFHIO16/BpfOnU7Me5ILzzMD0DKwd/Rw8rM1eHMTF0di+wcsFnQ0t1xfwxPU3+FIauqzKwRd35MCa879l7kGT5wDWFwMf2HCeePRgvOkz1QI/5J98UZ4q3l2D0wDGMBe6BlbXwEI7F+xbivns8tBbsj7lv9+O/62n2j9x6BtxxBi6wLMh/wGD9boLYt9SLc9i34e4473NBx6k81bLu5w5TdbAfevSB9lW3qyy+fNtGSfi0WsxTrif5J984Vlh5voAxlwYM3NB2dIdhupDPW/Delzw7dTou6CzBxifdF/d8/E9SLiEQ+PmuYW+2QLfa2y+1lSzF/iz9Jx5DpCNY2Djvc0z8PAuR3N9zcc1dG3QxTWrhvmGd0jV1P3ome5f34/0J8mPOIxufKSxm/m67P5E4z2Yayt/6Z5BMcD8JJ1vWtadR7OYe5UNcXe8VrhvKdg/4Pv6/AR/y2qz7l1INhQHrFUb1oXfz03viW1wIi7oE3mijg26pPNby7p9W3buYG3QuaPqaIW+cSDeXa/i7IBOBziRzhHghuDXNXDVvKiZp3bbO4Byb/aubCcPr+5TkPcO+HJg/aTTAx4uPI9hPX1vfj0UC8JV8fd0v+8ttnMNuwHoeGDnG3a+sW9qDyLd77H5Gmsy93GvVe7+B9kHes8FFQAA","debug_symbols":"5ZvdbuIwEIXfJddceDz+GfMqq1UFLVSRUKiArrRCefc6lDghiZxWlMoj34ADh8l3LDMzMeRcvGzW769PZbXdH4vln3Ox2z+vTuW+8kfnelGsD+VuV74+9V8uRPMA8qI/vq2q5vB4Wh1OxVIsik314p/9Z7flblMsrakXI5lDexU6bYMUmvFIq6Roo/qhC2rnJsTGSbiKjT9JX/x3UQDewQwC1FUJAtUvUqt7ZtpiO9NubqZBkmsdotJxZgLdikkKOWTWP8LsJ/oWugltHhfaPi40PS60+3Jor5biW2r4lnoyJ4DEdnWD1HrGKoTMYHpOLU6tV92CgKOglc14HFcrEVKO676PCDitDhPeW9vysrYlZuFSZeFSZ+HSZOHSZuGSsnDpcnCJIguXkIXLLHofzKL3QZWFyyx6H7y/9wGhZDhBj2ba5xev6Ywx7SU/YReS5AXacoQmjtCOIbQSHKGBI/R8VbdqDtroDlrcnGGs9tmuVRsBpo7uwWmr2/zrh1Tf7sEpZMyuGLNrxuyGMbtlzE6M2R1fdi0YswNjdsZ1VSee30kFdtJD9rTzDIUfTf3QDNl/P8+QCOwIM+zY/hyqVbdiUECDbgRfdOCLLpmgazNCR77oii964l1YLLObtLswCv/40aSG/3CxaXdhJGWEPe0ujITr2CkudtjtuqLFodG0W7Zo62DT3gqJsyvG7Gm3ynH2tLdC4uxpb4XE2RlfotjEi3CMnRIvwlH21ItwjJ1xXSXGdZUY11ViXFeJcV0lxnWV2NbV2h/9Wx3K1Xq3ud6Xsn2vnnu3qZz+v32+48Uf","brillig_names":["in_group"]},{"name":"remove_from_group","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"approve","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VazY4bRRBu78zYHu+Obf4kkDgMBzhGY7MSOSDhiCTcwk+QIo6T9RgG2etoPN4kCHgAuIG4wRkkHgBuII5wBokDQuKK4Blwe6vW35R7vOufRpuWVt3TXV31VXV1dXV7K+q0OLO/CrU9ql21XJimR3W0XenskFdkE2flEcG594jgdGzgrIDTugK8NoyjlsuBUFCX56HdovrWOA/T4zRP42H6QdJH8leg/QTVR/FwmGRhOgmPZxPj/ig9xilvQPtlqm/n4yx+Nwknw9mM6HTecDi+n/SvhDg2CUfTSR5O8jjLw0E2HoWdK8h7Cu3nqI7zPBndy8N8HE6md/MsPsrD+2n+Xjg+SbLBTAgy+ATaz1B9LcvihzMD9JMH4Xiah+NBeHc8Pe5PcOJn0H52WXLc75cL/XJToV9vIfS7TYX+sIXQnzcV+uuaQs98+l+qfXW6D3ThvdKj72i70vEB3E55Xz18SfOu2cF9qHnX7fCONOZXiTnjZ1k6Fl2nD64r9KfHblLfTTEWqEUcY96BWsS769DHB/kN6KuqIt869euig9drDJCKT38W7NMJ1MIeCmRgcQUWXdqqaEcecy4JTseA0wWc7iXBWYZpl8lOmQ0u21ohJmVJf+avc442teOT0ev3jsb95Fq/nyWTQsDHuLSqXJSfvwa/pyW/W9PhMB2kSXbjQTrJC3wbBr6cc+2pZX0QC44rMe4LXj36jrYr82QefXIPdGCZHtC8QPXjJThR/137si/krfJl1MHSmdYNQM5FMNUBmy074XqyfJbF/qVx7wtMbejDmO0DZranJeyRxlUT8vQZfQjy0FddA70PeuzatrgPfgJ8V6ndAjy4X/lepQRmzD8DQXMg9GoBT6Y9UIs72Vlsup3MMucM3RDTxfMKi/VAXA36eLxHdVkYqME300bbla6vilfUHS7ti+uGF1weWymhyXXkURGoojvo0oY+XHvpYoHghfO8FfMkBv3dtGOD7mNkY8bAchpCZ9QV/RRTK3zLqwC9C/OY5k2qTf7twJwq9GO6heHrbcDgg0zXQI/77lvgcQfGWeY7MP4RtS1eD9dOJzEUVu1g6uKRcRFMjKNh0U4VVfQLU8jHKynTtqHPdG2qwVx5LGseA9AHfdtV5mMcMfZ2o/uhB7K/AGzvUxuPSEzLPMBSdkTK65ondGqp5euVA3RSnqOKMUPBHGlznuMb+nr0HW1XOmgHbptwYOxBe9dBF6Y5obosjpn0L/Ovh4BBpmGSHrF/DDw+hDbHrH1VtLk8hxEb+yzSWnpC6G76hNBQ1q4cHdM+YFkYWxyBqQ19GJdtPT1g7sL+yOvqQD/TfEq1yU9NeZDUuaKKTxaYQrPclirGBUU0T1F7kUKf/sJwJ0vzRImCd3QZtOS4VELSMzB5X9GlKmg8qJnmc6pNRgsMc3ETmwIxBku5CU2HKNNqIz5JbWnEt5K48AMRBjgsFYMsSWMxkeigA0mHRX2Z5iuqy2zviLfueaCqW8He1Wx/B9lnCS3Ik5tD+qspacH3QF3aanntMdngeSa/Rh9EGjyAmOYbqk22Nb2hBgZ+mBA5MC4DOmKXAcNXRT13fbisc+HEZMfmhbMsRpkunEyLF0d81w4s4mwCBjwQEBvTfE912eHSPEdn0yWY57DcllrYAy/kGx8u6JieYVwqIReOgeEmxM2BNHi4MM2PVJcFODkXb7qYieOpzxsMdUNH0aVHdbRdmf83TVNgVoBhnUPL9I8R8rtZQmN7I/ADIG8EvCVyP9P8QvV5h1Yhu/6fDq2zDQ3yWoAPN92qjclz2A4YnHAdyx5lcb+wHaqCBjNbpvmN6rJDi/cB6xAY+OFjt9ajSswdsEmtvsDsAs0eYGKaP4DvnyDXE3z1+D+GcS4rbz1EO/+Ryo6vRJpfo77QzwVZLujPNA3A4cH336DPfr2oD9uC+c5jGLX36+XzPDGvDTR1mOeLeb5YN70Gf1G7oYr7YJcxA9da+/p/hJ55ovYoAAA=","debug_symbols":"5Z3Rbts6DIbfJde9EEmJEvsqBwdDurVDgCAd2u4AB0XffU4Wy27iSVGaZiR80zot5XwyFf8iKSuvi2/3dz+/f1ltHh6fF7f/vC7Wj1+XL6vHTffq9e1mcfe0Wq9X37+M/7xw2x9AO/vnH8vN9uXzy/LpZXHrbhb3m2/d767tw2p9v7iN/PbvzQJ8k3VosuYm69hknZqspcUaXZM1NFljk3WTL7HJl9jkS2zyJTb5Ept8iU2+pCZf0um+vDkyE4p7Qwkxm8L2+MjWo+vP2h1KthaZMGZB2Btz9yZj4y0zfoAZHPi9JTjyV6Smj1zpSP2VltqVBkzS95B8KDMnCL1xQoeHzP4izN2Ffg+9PXX4vFPz5506ft6pJ+8JCJH3jRDE18Y2h/wOMtBAwgnrINJbswMuj5MQQ/9Z7w7T4TgRu+zeGWYHw+xomJ0Ms3vD7MEwOxtmj4bZDetqUH6PTD6zp3DIrnu8pzyx7w75kP364z25zE5QZu/Olyf44IYxQy7s4JNleDEMz9NTySGGRIRUhvfEfZDgKVZwoou4N44uHQacXJ0cdjhv79MBjGe0oTPa+OkrFUJuE6USTUFOPvAomIo05bfQewBkcABuj4/PG7zLWQ0ZIAho2jqPtVH4jL89EGbRS55FL+Mseplm0UuZQy+jm0UvYRa9xFn0kmbRSz+LXs5i7hNnMfeJH5/7gPM4BGVS6eeJBRXmPsTgRO/ivC10sggtBqGTswhdnzcIVaDR52wAxvDuHSZoaEg0kFTKsiR9Jdk7P0ozwA7dXx3dU0bnCjpD6F3ZHdJBUiJND3DKrsKu65fN71wsGyvOMDsYZkfD7GSY3RtmD4bZ2TB7NMyeDLMb1lVwym/wpTJn98aq4Yt1TnDX/7i2lNso9sMGKPHhPLirwJmmF8v04MzQj4KhTA+m6dE0/QlT4jim3zXy5zQK5zTicxrFcxr94fZFkhuNgu1rpyAAKadkcLSMvHcjwtXpL5aFAGTd8NJ/ghhdPIKPuuETluCTanh0kuHhaKKKYhienGV43XebCjxahifL8N4yfLAMr1thK/C6FbYCb1lhybLCessK6y0rrNetsMBpgK88RSw+c4gfReZ9T3XL8Z97uoPXLccVeN1yXIFXHvCW4ZUXN4r1gaB71UDKeziE5I+i9aB72UBCLMHrLiulrGgdfKqIAg2L+SgepbOC7lUG5RpU8Jbhda8zqMBbLl0G3SsNKvC6lxpU4HXLcRmelctxGV65HJfhtctxEd6ywrJlhWXLCsuWFZYtKyxbVth4/YcTLleePuFZxb8KXyxPn/AI4t+EL2dBT3iyUDF8sAzPluGjZfhkGV4Mw5/w2J9ieN0KW4HXrbAVeMsKq/zRywq8ZYVNlhU26VbYC5ank245LtcZk245LsOLbjmuwCsPeMvw3u4unSC6t9Qtl6dF+R6jxfK06N5UtwKve1fdC9bWRffe9sVEIjrdm9tX4HXvbl+B1711cwVe9/72FXjdclyBVy7HZXjDW36jUy7HZXjtclyEt6ywYFlhwbLCgmWFBcsKC2YV9q179d/yabW8W9/vv1fy4efm6+hrJl/+//H7P53xLw==","brillig_names":["remove_from_group"]},{"name":"set_balance","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["set_balance"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"PublicGroups::remove_from_group_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::remove_from_group_parameters","fields":[{"name":"member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"approve","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"PublicGroups::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::constructor_parameters","fields":[{"name":"admin","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"PublicGroups::make_payment_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::make_payment_parameters","fields":[{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}}]}}]},{"kind":"struct","path":"PublicGroups::set_balance_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::set_balance_parameters","fields":[{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"PublicGroups::balance_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::balance_parameters","fields":[{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"PublicGroups::add_to_group_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::add_to_group_parameters","fields":[{"name":"member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"approve","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"PublicGroups::admin_abi","fields":[{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"PublicGroups::in_group_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::in_group_parameters","fields":[{"name":"group_member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"boolean"}}]},{"kind":"struct","path":"PublicGroups::member_count_abi","fields":[{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":64}}]},{"kind":"struct","path":"PublicGroups::split_group_balance_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::split_group_balance_parameters","fields":[{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debtors","type":{"kind":"array","length":10,"type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}},{"name":"participants","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}}]}}]}]},"globals":{"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}]}],"storage":[{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"group_members","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"group_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"member_count","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}}]}]}},"file_map":{"24":{"source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n","path":"std/embedded_curve_ops.nr"},"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"29":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"34":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"57":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"76":{"source":"// mod test;\n// mod types;\n\n//this will be a little test to make public groups in noir\n\n\ncontract PublicGroups {\n\n    use dep::aztec::{prelude::{Map, PublicMutable, AztecAddress}};\n    use dep::std::hash::pedersen_hash;\n    use dep::std::collections::bounded_vec::BoundedVec;\n    use dep::std::collections::vec::Vec;\n    // use crate::types::bounded_vec_wrapper::AddressVec;\n\n\n\n\n    #[aztec(storage)]\n    struct Storage {\n        admin: PublicMutable<AztecAddress>,\n        group_members: Map<AztecAddress, PublicMutable<bool>>,\n        group_balances: Map<Field, PublicMutable<Field>>,\n        member_count: PublicMutable<u64>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.group_members.at(admin).write(true);\n        storage.member_count.write(1);\n    }\n\n    //helper functions to read variables when testing\n\n    //read the admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    //read the group members\n    #[aztec(public)]\n    #[aztec(view)]\n    fn in_group(group_member: AztecAddress) -> bool {\n        storage.group_members.at(group_member).read()\n    }\n\n\n    //read the member count\n    #[aztec(public)]\n    #[aztec(view)]\n    fn member_count() -> u64 {\n        storage.member_count.read()\n    }\n\n    //read the balance between two addresses\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance(creditor: AztecAddress, debtor: AztecAddress) -> Field {\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        storage.group_balances.at(key).read()\n    }\n\n    //functional methods\n\n     #[aztec(public)]\n    fn add_to_group(member: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        storage.group_members.at(member).write(approve);\n        if (approve) {\n            storage.member_count.write(storage.member_count.read() + 1);\n        }\n    }\n\n     #[aztec(public)]\n    fn remove_from_group(member: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        storage.group_members.at(member).write(approve);\n        if (approve) {\n            storage.member_count.write(storage.member_count.read() - 1);\n        }\n    }\n\n    //this set balances but only between two people\n    #[aztec(public)]\n    fn set_balance(creditor: AztecAddress, debtor: AztecAddress, amount: Field) {\n        assert(creditor == context.msg_sender(), \"cannot adjust someone elses balances\");\n        assert(storage.group_members.at(creditor).read() == true, \"Creditor is not in group\");\n        assert(storage.group_members.at(debtor).read() == true, \"Debtor is not in group\");\n\n        //cant store the addresses in a tuple in storage so hash them together,\n        //easy to know who owes who as hash a,b is different from hash b,a\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance = storage.group_balances.at(pedersen_hash([creditor.to_field(), debtor.to_field()])).read();\n        let amount_to_write = amount + balance;\n        storage.group_balances.at(key).write(amount_to_write);\n\n        //adjust the balances\n        //balance between creditor and debtor\n        let creditor_debtor_hash = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance_creditor_debtor = storage.group_balances.at(creditor_debtor_hash).read() as u64;\n\n        //balance between debtor and creditor\n        let debtor_creditor_hash = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let balance_debtor_creditor = storage.group_balances.at(debtor_creditor_hash).read() as u64;\n\n        //if the balance is greater than 0, then the creditor owes the debtor that amount\n        if (balance_creditor_debtor > balance_debtor_creditor) {\n            let difference = balance_creditor_debtor - balance_debtor_creditor;\n            storage.group_balances.at(creditor_debtor_hash).write(difference.to_field());\n            storage.group_balances.at(debtor_creditor_hash).write(0.to_field());\n        }\n\n        //if the balance is less than 0, then the debtor owes the creditor that amount\n        if (balance_debtor_creditor > balance_creditor_debtor) {\n            let difference = balance_debtor_creditor - balance_creditor_debtor;\n            storage.group_balances.at(debtor_creditor_hash).write(difference.to_field());\n            storage.group_balances.at(creditor_debtor_hash).write(0.to_field());\n        }\n\n        if (balance_creditor_debtor == balance_debtor_creditor) {\n            storage.group_balances.at(creditor_debtor_hash).write(0.to_field());\n            storage.group_balances.at(debtor_creditor_hash).write(0.to_field());\n            //this is not setting them to 0\n        }\n        //if the balance is 0, then the creditor and debtor are even\n        //the values should never go below 0 as as you are subtracting a larger number from a smaller one.\n    }\n\n    #[aztec(public)]\n    fn make_payment(creditor: AztecAddress, debtor: AztecAddress, amount: u64) {\n        assert(storage.group_members.at(creditor).read() == true, \"Creditor is not in group\");\n        assert(storage.group_members.at(debtor).read() == true, \"Debtor is not in group\");\n        //make sure the payment is less than  or equal to the balance\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance = storage.group_balances.at(key).read() as u64;\n        assert(balance >= amount, \"Insufficient balance, or paying more than is owed\");\n\n        //subtract the amount from the creditor\n        let amount_to_write = balance - amount;\n        storage.group_balances.at(key).write(amount_to_write.to_field());\n    }\n\n\n    //same as the above but with a fixed vector of addresses\n    #[aztec(public)]\n    fn split_group_balance(creditor: AztecAddress, debtors: [AztecAddress; 10], participants: u64, amount: u64) {\n        assert(creditor == context.msg_sender(), \"cannot adjust someone else's balances\");\n        assert(storage.group_members.at(creditor).read() == true, \"Must be part of the group\");\n\n        // //calculate the amount per participant\n        let amount_per_participant = amount / (participants as u64 + 1);\n\n        // //update the balances\n        for i in 0..10 {\n            let debtor = debtors[i as u32];\n            if (debtor.is_zero()) {\n                continue;\n            } else {\n                assert(storage.group_members.at(debtor).read() == true, \"Debtor is not part of the group\");\n                let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n                let current_balance = storage.group_balances.at(key).read() as u64;\n                let new_balance = current_balance + amount_per_participant;\n                storage.group_balances.at(key).write(new_balance.to_field());\n            }\n        }\n    }\n}\n\n//can bypass the whole making a bounded vec and just use an array of addresses\n//skip if the address is zero.","path":"/Users/niallcheetham/dev/aztec/publicgroups/PublicGroupsRoot/publicgroups/src/main.nr"},"78":{"source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: Field = 3;\n// ADDRESS_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[aztec(note)]\nstruct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/address-note/src/address_note.nr"},"84":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"99":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\nuse crate::hash::ArgsHasher;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    args_hash: Option<Field>\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs, args_hash: Option::none() }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            let mut hasher = ArgsHasher::new();\n\n            // TODO: this should be replaced with the compile-time calldata size.\n            for i in 0..self.inputs.calldata_length as u32 {\n                let argn: [Field; 1] = calldata_copy((2 + i) as u32, 1);\n                hasher.add(argn[0]);\n            }\n\n            self.args_hash = Option::some(hasher.hash());\n        }\n\n        self.args_hash.unwrap()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"127":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"140":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"157":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"158":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    point::Point, traits::Hash, hash::{sha256_to_field, poseidon2_hash_with_separator}\n};\nuse crate::oracle::logs_traits::ToBytesForUnencryptedLog;\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (n as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        poseidon2_hash_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x1cce4dbf69f14c44865919991ee1057922e34d7310ba237d71759aa422621ca9);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"164":{"source":"use dep::protocol_types::{\n    header::Header, address::AztecAddress, constants::CANONICAL_KEY_REGISTRY_ADDRESS,\n    storage::map::derive_storage_slot_in_map\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys, constants::NULLIFIER_INDEX},\n    state_vars::{public_mutable::PublicMutable, map::Map}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"173":{"source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"182":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"223":{"source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"232":{"source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"295":{"source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"297":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"298":{"source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"300":{"source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"301":{"source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"304":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"305":{"source":"use crate::{\n    crate::address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"313":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"345":{"source":"use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    protocol_types::{\n    traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    point::{Point, POINT_LENGTH}\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul};\nuse std::hash::from_field_unsafe;\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.value);\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> ValueNoteHidingPoint {\n        ValueNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    /// The following method needed to be implemented because the note is passed as an argument to a contract function\n    /// --> the serialize method is called by aztec-nr when computing an arguments hash.\n    /// Note that when the note is about to be encrypted and emitted as a log the to_be_bytes function auto-implemented\n    /// by aztec macros is called instead.\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n\nstruct ValueNoteHidingPoint {\n  inner: Point\n}\n\nimpl ValueNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_value(&mut self, value: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(value.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for ValueNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}