{"transpiled":true,"noir_version":"0.33.0+cb20e078dd909656110d133339b2b425e6c3ebb0","name":"PublicGroups","functions":[{"name":"admin","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zVRy04DMQycxInjpMAFCXoAbkggFbq9ZOHAiW17QEhwRvxwv4rxrljJ3owf44kzQELcQewADJCY6aCP4Ke0DNj7LdQmm76JbVoMkRZGJiGjR9IzA2cjyLQ/eOHeC+5mntmXt3/O4ukBIWhDMC1PwCXKMbiAEIzwCmmBElJnMVmRZnlKmBwqhsAsj8mDWgaGao+19JjML1E7at7gvkFy9SFblA0eejAKkBIpRbTmHrJ1mFfL1pM30Kxkc3JNKq+uW2jJ9egZ6bSR7gXNRfLKxYQbRLR5CUfuI3uDSGz0LSslqTf74FzSBX1yimmh6FEoIbnYMZiYrrhFJZ+r/jCq/iSnGAt+R19eDs5vFLibD/WcDdWStWtutFnzF+NvfrG22PJiJPyxxnbzhhXHrcwc5hlGM1s5rJxeN/jaBSGjD96OWJ/Wpz8zMHHaMAIAAA==","debug_symbols":"1ZrdbsIwDIXfJddcxPlxY15lmlCBgipVBUGZNCHefSlrAyssDDFQfAMJnLpfoyTHsboX82K6W07KerHaivHbXlSrWd6Uq9r39oeRmG7KqiqXk/OfhWw/QB3123Vet91tk28aMZYjUdRz/+2vXZRVIcYZHkYXMtJZJySbBSm07QutUbKP6psU1ERXxEgKOjH6m5yL30cC9APMIMF0SpDavJDaPDLSme5Hmm6NNChH/RNqY+PMDmwvdkqqIbP9F2Y/0D+h29D4vNDZ80K754WmP4f2aiXvUsNd6qt7AkiEgJ/RrVWGNojpdANw6oraEvVqlIDxGWsz2+86vukGM1ZpxuyGMbtlzI6M2TPG7I4xO/Fl15IxOzBmZ+yrmrGv6sT3SGcCu7MDdpP2WnXheOSbOGR//Vp1MrBriLP7eOGYBPI0Z7S0R3jFGV5zhue8XNNOaVwo2FhnhgUKk3ZK45T6nd0mvk1G2dNOaZykE7uLi0mbfhvwBTA9fNC085+ol9m08584u2HMnnZdIc6edl0hzp62CcfZEzfhKHviJhxjR8ZnFUzdhGPsjH0VGfsqMvZVZOyryNhXkbGvIltfPfjeR74p82lVdK9ELHb17OwNieZz/f2PF38B","brillig_names":["admin"],"assert_messages":{"21":"Function admin can only be called statically","18":"Not initialized","55":"Array index out of bounds","67":"attempt to add with overflow"}},{"name":"balance","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/02SvY4VMQyFj+P82Alsh7gF0CNd2LnNDBRU3P1pEKLiAZAoEBI94gn3qTjO7EWMlEzsON+xnSxQSSeo3QMLNDdOsNfgZxyNv48vUe1s5y/hO+8DiUM2bkK38GTONyicb1HfcvNqA6l3t3HoLoJfTeac/cOF7xx9gYh3SHd7AzxjvEQyIp3mAXk3VfsKZFLRsYhKLHOis/uaCknqiavqywyJTeMyjU85VB7VQnUsqFoCWS/I+h+SzjqIHLRG4srH9I+g2T9aDVIQSUPuqDVTWlBYipco5d2lFBWnUAkhx6SsMxu2euruydNpVMuhWFhWO+KmQ1t3sj7Dj7hf5bFQi+72tkpjZIkm6HVsvkBt3KvV8vtoct4TVNEnJOkg6StGZMX7cVNePZLluLHvvLyCvQWz9KZrMp3Z02xuV5wtEN92BHOlukWem5haHUyqktcY8yP8P8lUK0f82SKRIpSDUeM0F/6UB9yy9ecQ69bjqfE3n1rfx/7UCPxtncctDgzKDbMwyzSTmY0wneps1K+TKIkhfL3h8HB4+AsCdAMW6QIAAA==","debug_symbols":"5Zttb+IwDMe/S1/zIs6jzVc5nSbYYKpUlQnYSSfEd7+Uo2lXemETlylW3kAKf+yfI2I7UXuqXjbr99enut3uDtXyx6lqds+rY71r/dXpvKjW+7pp6ten8ceV6F5AX/SHt1XbXR6Oq/2xWopFtWlf/Lv/7bZuNtXS2fPiRkbKXYVkXJBCN77Rail6q35IQU00I7Yk4Sq23slY/HNRgXmAGQToqxKE0t9IbR+Zaaf6maZ7Mw0SqY9QaRNnRjC9GKWQU2b3X5j9RH+E7kxjOtOUzLQU6UzDp013avkltfqSejYngBWyx7ej5T4bqkTXiyXB8LeSl7+VNKkd2NQOXGoHmNoBJXagRGoHkNqBTO1ApXaQeiWr1CtZpV7J6h8r2brggOSdvA6hDbKjtO7UXHE2fdYFwhEKztk1WoT+iobmQ4GaV4fqIm6ixCKipBKi1KKIKKGIKGURUaoiotRFRGmKiNIWEWURvY8uovfRRfQ+5vHeB4QOewcxopmP85NHO9ba/uQP1WAS5QUaOEJLjtCKI7TmCG04Qt+t6k7chbZmgBYfPNyqfbbr1VaAPY9O12fEzvQcfohjccfuGLMjY3biy24FY3ZgzC4ZsyvG7Joxu2HMzriu2szzO+rAjmbC7vLOMxjunfBDO2X//jyDIrAriLMD6WDab0iHLauAC7zmDG84wzNerph3O4bhbi6Denr3EubdjqGUEfbc0yQN7BgXkxqO0pRT00Dz7t2i9QDz7t3i7Hn3bnH2vHu3OHveZyJx9rzPROLseRfhKDtlXoSj7JkX4Sg7470KMa6rxLiuEuO6SozrKjGuq8S4rhLbunr2V79W+3q1bjbXZ4627+3z6BGk4++3v9948R8=","brillig_names":["balance"],"assert_messages":{"98":"attempt to add with overflow","55":"Storage slot 0 not allowed. Storage slots must start from 1.","20":"Not initialized","23":"Function balance can only be called statically","86":"Array index out of bounds"}},{"name":"split_group_balance","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"debtors","type":{"kind":"array","length":10,"type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},"visibility":"private"},{"name":"participants","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/41VTYslNRS9qaSqklTNqyRVrx1kWtwIM/DafgNSj1F0oe3oQqF7QEQXIogbQVEXrvwJ/gHBvX/E1ewE9/4EQXAhbjwnqXo9DePHg+QlqeSec8+9yd2LVtV90faRyF704NCJvyf4eTQnYt84lcZe2IsrzO1FaVKhqVMx9tJe8u/KXh2wVfSB3w36N6Wm3YfSwKSn3a6bs1UtneyVVhz6qjsI7OOcdBbnxNn6RRi/M4tvYOZSWvRXYrl47yE5PCI72MawvQWI1tbWPiPK4keu+GWutrTC9UzkrrUK23nAHZR1tuHU5GllG+s4baWy7U5Oz5/LGuS+e3XVo0Pr96JU50X1nT+jav4tJfI8t/RemrrvsPqSdFyF15pe99dec9hXWOz8Xprq1lzdKkL4uar9Pu/jjg2G1fCuWVCJvkEbcCjj+B5DJRsQGTYBkG9LWCBVAORAyMBpFTENnMbMgMPAxZjmqkcLA9i4nbznRbvO0II+E4U47uSDWQ3IAu0qMNGmC7MKwx1pBkONxSwta4xl49C5IX8blpa/UTQHlp/KUFgahW+mHcwGvaEDnxUHGqSTISO/k8+ZO7Zn12LH14LQfHXOxZaLrcHiN2J4DOyawtG3s2otJLI9vqvX6Ma3jARlMYss0CFvrrAYIoIQMYtQpbIxr0cql476QzTIJ5JgN/QGqptNAvp3klbV02o+HVVP16pzmLLqI1RHSwY+wp/voXrbRTC9K3EnP8zKLBEioy7NKhkqG7OocWmr4DGgC08JBrj9WJT5L9fr/+s6Uk9bWnvS06M1LKbVRrYWnrA2Hq2lxdoIIdMi5AiyP8m4Cjmu5sejkOO1kByOWcgJQqKNi5A/H4VMFPIXCFm4ZOm7cVYjhDQmQbEUMYoAMWaIyEATGcxfj8H8ZxcROVsoYBTGvD6S5nTDRXyQKbuITFR2w0z9rcSDUbOF8u8rZfmLlP/gQ6DtZs33P6XlgVks7wLOtXAI3APx4DWF1KBJhsVVLJrMMOuIO9KOEwSxMi13JFYT+qnNary8Zg0TrtUBwG3gnQmFKfKDJCkkwUeCj9MDnproI0G2BNme4NCzcsJDeMOj1XyfK2vwaqsP8YDXkmGrE/Qn7RZB22bISMiI+KsXSvznaoIPkeFcYSFnE9KYYceSh1pNhJ22Z3xZtv8CW0JFsG2LXElThk2ETUyVVyQWWGZR4nW8GQP1+o0Y4DXkZXQQrPEhPlivZMgPADi5RGfeKc6Ak3kKpxKqzMzx+WV+Oo2HUDs+hOr98hDOVcQzaPgwo1xp23SoTw3rE/Z8hCqlPoY5beud+vLAglerXBTNWh0dq6NDhfOsjt56Vkf85eroS1sfC/WF9aU6OtsBrivFss7TCiW149QB3e3UJ/eVhkUCnx/k9uPbj/8Ge81jR0gIAAA=","debug_symbols":"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","brillig_names":["split_group_balance"],"assert_messages":{"47":"Not initialized","314":"attempt to add with overflow","238":"Storage slot 0 not allowed. Storage slots must start from 1.","331":"Array index out of bounds","139":"Storage slot 0 not allowed. Storage slots must start from 1.","281":"Array index out of bounds","342":"attempt to add with overflow","51":"cannot adjust someone else's balances","263":"Array index out of bounds","292":"attempt to add with overflow","321":"attempt to add with overflow","222":"attempt to add with overflow","100":"Must be part of the group","248":"attempt to add with overflow","117":"Array index out of bounds","71":"Storage slot 0 not allowed. Storage slots must start from 1.","271":"attempt to add with overflow","303":"Array index out of bounds","105":"attempt to add with overflow","166":"Debtor is not part of the group","195":"Storage slot 0 not allowed. Storage slots must start from 1."}},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2dCZSlSVWg/1e5Z1V2ZlV112ZW1p9ZmVm5VGW9NRcW6VGkoRtxQRgVRXNtGpuqhq6m7UEdjx7nePQoCqicGRwEgQEEGVGZQbDVGRYVFQcGPKKoR6VdkUUUm22m/qz/5vvyvvvHv7yMl1VN/+dUvZfx7hY3Im7cuHEj/lJw7Tl49V8p/t4Tf/YGrY/A3Bp/ltt7KntIq+xTztINIueBG0TOrhtEzu49lDOSrSvY/ey1vD0e9LrXMvbeADL27XG7i4zd8ff+q/8Grv4bDK7Z3pYfWbEDcceJfo8aOFJgH2CSiP6xUk70PBnfb44/n3Hpuy5dvv9SeOnylc3wygP3bIZPeSJxFtBrT8af/+4FL1h9ILzr0sbmd4eX77sSXt4K1y7fd2njXiIuFkX8yqKIdwBxNP5cvXJl83n3XAmvXA5XNzbC+++68pzw8gs3X7B19+X7ifutRZneXRTx/jakfVUbuG8uKvCvFkX89aKIv9tGNc93F2RaL4r4uKKIT+kuXs1vLsr0uUUR72tD2le2gfsLRQX+5aKI7yiK+NttVPO+noJMv7co4g8VRXxJT/Fqvqoo018uivhgG9L+bRu4nykq8BeKInb3FkQ83Fu8mqeLMp0qinihKOJj2qjmU4oyfVZRxK02pP2JNnBfUVTg1xRFfFNRxLe3Uc3FvoJMv7Io4pOKIj69r3g114oyvVIU8T+2Ie0b2sD91aIC/3pRxHcXRfxAG9X846JMH2qD6d8XZfpwG0y5JM7FdKi/ONPDRZmGbTA9V5RpvQ2my0WZ3tYG06cVZfqsNph+R1Gml9pg+h+KMv2Boog/UhTxZ9qo5uuKMv2fRRH/dxvSfrwN3IeLClwaKIg4UBTx2EDxak4UZTpXFLFaFPEJbVTzaUWZfmdRxO9qQ9qfagP3VUUFfkNRxF8qivhgG9V8d1GmH2iD6YeLMv1YG0z/sSjTh9tg+sWiTA8NFmd6dLAg07ANppNFmdbaYPqYokxva4PpHUWZfmsbTFeLMn1OUcR725D214D72Pjz6Vcuv2D1zs3w3rsvXwmfd9+9V8K1q39sRh9bl1+wGa5fft49912569Kd1/bWnnPXRvT9nst3XbpC0p846I30hw8VVNWfFUV8qCjiPwMxb+McGCrI9OaiiGeGikv7lDZwn1FU4G8virhZFPEFbVTz/xZl+qdFEf+6KOKn2qhmcFNBpkeKIp6+qbi0t7WB+/SiAj+rKOJ6UcR72qjm6eGCTKeKIl4oiviY4eLVfEpRps8qirjVhrQ/0QbuK4oK/JqiiG8qivj2Nqr57qJMf78o4oeKIv5lG9X8VFGmXSMFEW8aKS7tchu4Tywq8FOLIn5TUcTVNqr550WZ/k1RxE8URfxCG9U8eLgg09NFEWcOF5f2G9vAfXZRgbeKIl4qiviiNqr5A0WZvrgNpi8tyvTVbTD9xaJM31YU8cGiiO9ro5ofKcr0H4sifrYNacePFMe9cKSgwI2iiI8vinh7G9V8ZlGmzy6KuFUU8d42qvkDRZm+rCjiK9uQ9nfawP1QUYE/WhTxY0URP91GNR8uyrT3aHGmg0cLMj3ZBtOwKNNzRRGrOaXdOXpxR4wYbZ0ciMui3/bwfFEF2zJ7S3u5vjUQy+5B7mU5suKBdjnKOfrq/qbuA/CKThZIAot8luJ/Q0HzrJbgDwXNozZPRJnk6H4NyiQb8Ukok/yn2yBPv5/2WvbYXrWI7kE/tOtDaJ8APPggs35HjsHAWx/aPvt5UPEXXjKWt/tL3Jj9KOvu3y3ndn9R/TH6M8Tv/aiT/D6v6kZZupQsEd0eH7pYrq9FtHt90I7bXnTYbeiwx9Bhr6HDyNTeoehEcvf1e5F7+3xfP2TsBi+R8wBg+iFHD/6eC5rlA8gw6oZehG4UxuqVftSfjNet8EYA0wu8PoXXB7m3Ya/+G4+/HwyaxwzluTX+LBd8FperS2vVWlnob+suaLav8NprvvGzbdMO7T3d7Tl5aO/p1iO6N7VPt6YLIroSIpW5cI9k3qY9Yslcr1SrtUp9aW1xubzcKG+sL1c3l1cbjdWVRnWjvrFVLVcbi1ub5cZKbWOlvnK1uF5ZXy2Xt8qra1uVRkT3MGTes7FduSbzER+0y+XtXLejfmhv97ubLV239dS2dX2Ln/6xLfMxS+bV5fWl6uZieaN89b+txsZyud6or2zUl7dq5Xp9o7xYqZfXVpY3N5YqS6sra41adXVrsVZerzRq5aWVbbrH/eh5226cCPZaz9f63cn8dCtZ6J7yoovKNu2v8KPnbXs3utd6jsf3aT8yl6P5S+ay++NJK5rPvioui3iP7WGdlir16lUruhTROBPT4hw6hjL5/ZuDplxPgh5kvHTHf8uccAtoCMxT4k/EHXYePZ/soX4bQ5AnAA8+9JVFjsFgtw3b67XCsOIvvLhWOK5kGkHZCch2XNE6rmhdD3hRfaSfS12j/jQfL3ijPnAGPPZS3xFvjiHhEah6yCNyRDKFfmTaXsecySFTGH8OetRTCXyEv/BivxxXMo2gjP1kXNEaV7T2Ei8qkzYWmYfxnTGUM4r+GYN+v6LFeI3MBdHfdxt0ZX0n8MdRLjDfDlt/2ZB3DGVjRh3G8L0bf1t1GDPwgsCuu9UHBOc0ZBLaoQPPoq3bVnCOgrbwG3fgWbQnFIzgHAHtMP4usAOKz17bnTxjfBwyTXiUaTyHTNTTWY8yTeSQ6SxkmvQo09kcMk1CpimPMk3mkGkKMk17lGkqh0zTkOmcR5mmc8gkckQ2U88XnGvGUCb9NUSZ9JculE0qflGZ6KsHZSKv2NhIPzOQfe/0U93Wj9Q5AA8+1I/IMRj4a7MS+Ah/4SU2PorfRL5jP4QWnFDKhkGIwmriM4r4CODlt6gRZj1VeEjJJDwCJac8s5BT8E5AzjmPcs7mkHMOcs4acs57lHMuh5zzkFPwJLib5Oy9BXQFXzt7p1AuMItw9t4alw0DZwZl8p06l+9RXz2pcIJgd717HfjbGwkKpwe/vz3+TFqk++lj1wxSv+KXpY8NBp42R2ODNKf4Cy9tkMYgtOCEUjYMQhRWE59TxOnBy2++DVKeAUSDJHidGuh5DBIHumWQznuUcz6HnOchp+DRIMnkRIP0h6Ar+GKQBJ4GSWCGYZA+KGVBa39j300zSOw7rHe/Az+SaUzh0CB9JP5MMkh6FXxr/He5raeau+1EjsHAX7+3Vu/CSxukEEILzk4Zl9gUVhO3QgrzqsK+DVKesB0NkuB1aqDnMUgc6JZBuuBRzvM55LwAOQUvzSB9CnQF32WQBOZvB5o0PhOXRf1U9zf23TSDxL7Des878COZQoVDg/T5+DPJIAmuD4OUp+3C+HMw8NfvrZCf8NIGqQdCh0rGXXE5CquJh4o4O6b85tsgUSbhESg55aFBErxODfQ8BokD3TJICx7lvJBDzgXIKXhpBulIqUlX8F0GSWB+CwbplpjGMHDCoFkm39MMUojfOZjPOfB7gubgsQzSaCxbkkHykuNXLq/kNUgih2+D1KP4a4PEscH4m5Qxb3FW0ZpVtIg3UxCvvyDeXEG8+YJ4YwXxzhXEC+NP9uHouTX+rFRqlcbianlxeWuxXCtXa9V6eX1lca2+sdqoL9UXF5c21mpry0uVynqjWllfqi9XK9XVSmNtvVyrb64uDih5hG51udpYX1pZX19cbayvrW1ubi1tLK4ub1XWFlcr1bXaVSKrtdpyvV5e3dzaXKvXVhYr9eX15ZVKfWm9XF+hXd8lb3VlbWujEkm3tlRerG4srjXq9c2lzdri2kp5qbZYa5S3FrfWVsuVanV5vX5V5Gp5ZaVRXtlqLJUrm7TDpFve3FirbFZXauu19c2VytrWVSE2r35dXW2UN6rrjXpla3Vlo7wS0bsqbrm2ubVWWd9ara6v1WqNpe2c/YuWvLV6ZWNxqbG1elW7m+ubtasKX91o1NZXa/Wr9aitVVbWFjdXlhar5fri0tWy+lU1VOvr9ava2ti8lgNWQdvv4TjfiMZwOdj9uGyPyDEIPB+2p6L4Cy/anqqSKdJTLWjVf61cry5uLtZXNzev6n9lZXm9UltfXt/cXN9Yra0uLS2Xr3bwzastUl1br27V1rbKm6uby43K2tXuVSmvV0bAq4Y6V5WMVSUj8XoK4g0XxJstiHehw3IuFMS72GE5RwriHWtTzgGU7fE4286b4TgTHoGSUx6RYzDwZo8qlp702I90UvfDfz2i11D8zxv8F/3wX47oLSn+FcU/WggehJ5EFyK3yCZ0ZA+V2yRsv17Fr1fxGwE8fbpyipzWulNwThsyCexA4G9uydvny5Ap9ChTnjk4hEx+orb51+cMYvrcrcgTxJyHTJ62dOt5o9vcbvMZ3dY7Yjq6zTU+t5nPQT6R7ZyipXMJiHeiTTzamg60X+OR2n7ttkOn8G5CmdhA7jKG8fejKGMAO3qi+ePH4kbjuoCxqxcjdqV39wT+CMoF5qsQu3oJYlfyO+3vPOpMPsOgKzA/7Yg1JdXh5RnqcNyow0nU4b+gDoLDOc5TPKmRd94VOXz7mucVf+2Te5zP6tY4t3y9o5BTZJkDTvTIOSC2K/WWZe0h8NWMtEo5aHF8V1Am44fnQ7L4lUlrBPqVY0Z9ykZ9tK9ZdtSHY+V69FE9rRVz+6hVyOQzna6aQyZm/lxvqXMebW9uH5W216ePo22v5ePMKJmYsjkE2bKkpOpUz6J4ST6qz7nzkdh+7bZDp/DSfFSxQfRRmfUVPZHv9SfwUUUf9O8+Cv9Op8QKPH1UgfnPuJvjL+DfaV+B9e5WfOijCsxfp/ioVh0eylCH40Ydno86/B3qYM27nvp0I+8+rMjhex92XvHX/pC/8w3XfFS9nrMSU45CTn1kwPJRpQ7UWyWlnsxRqWSkVcpBi+Ob9krGj8tH1Tpx7WHRR50z6lM26pPFRxV4+S0aX3IHVncMGI2vA/F3+k9iG6PfR/taZbHOgY6jTL5PoEy+n0WZfJ9EmXyfQpl85xknP2OsmvuME+dXX2fBrPlVeOmEsDKE1jlcu4IVFFYT1x2YB6nkN9+OcxHjy47PRCtPBjF3OvMM5Jw35PR5cC/PmSge3BO8Q/EnF6Sc7CcONOkKvkz2As+EMIG5HZP9VEyD53UYONOBD35nQpiVBBaApoUfyVRWOHRKzseyJSWE+Wm7au7FNoP2PpMytCOgJyExSGcgtE7y25X5R2GzRI11Y/k2SHlOdtIg6ai471PDeQzSNOS0DFLoUc48s2wIOQUvzSB9NQyS4LsMksCchUF6EgyS7m/su2kGiX2H9S478HmrxTTK5PevTTFIfsZCfg+JKyOfHpJeGSV5SOMQWnBCKeNSmcJq4jq8wY7JMFDoqcJ5B3oIOa2B7uu0Z97UAV4PEBpy9nmUM89J2T7IKXhpBmkDBknwXQZJYL7Q16RxJwyS7m/su2HQfOQ7DZJ1kDAATQs/kmlc4dBwXkoxSH76WDX31Su84nfci0zXDFK/4i+8tEGahND6+p/tRj0cf6ewhxXxw4r4CODlN98DnTIJj0DJKQ8HuuB1yvPIM9BDyNlvyOnTIIU55KRBErw0g/RDMEgC6zJIAvMhGKQfhkHS/Y19lzrncf+TCicIdt+9Oe7Aj2SaVDi8iuHFKQZJcPe47bbz6E8qfq62EzkGgefDIE0q/sKLezT9Sib2e+a7a+Omr3AgXk9BvOGCeLMF8S50WM6FgngXOyznSEG8Y23K6XG+Wsl75xedBk92w3QaJpWeOC9YzvIMZAsVrVDRIl7e88FSVi6Id64g3nRBvPmCeOMF8ehzhaCx17kcRXwZ39f7hIq/nmcinYz64b99ZuOU4j9p8D/kh/8yF3fC37re6CD0JLoQuUU2ocMzG9ofKgXZ7nUVePbn8ylyRjBJe5unDZloC/qBE/2bUngHQIt1Ya7q78cVj/zMD8VC8VylD587T6hd5PB9lv9iDpkWIJPPexAWcsh0ATL5vCzmQg6ZOrCNWb9RckhcZ/mtW754HmRW0XKdPT/RJp6Vk/FoDlD+9mu3HTqFx1w7sYHMxREbxFw7sQHMtfsSclysPDWZYKnbLLl2T8P81NXV5Cu/0/7Oos7kw1w7genr2s2TT1IdBjLUwcq1m0IdDqEOMs44x/nMac0znzDnxte8a/lH1tljn+dB9FhZUPyTzoOwr0UPc+2kDtRbOaWeHGvljLRKOWhxfFt3ETHX7qKSVevEqo/g0Ge9YNTnolEf7WtedNRHfmO8VfhE4+v9ho0gL96fw3Fr3eA4i3H7ZIPuRdRrVpV5TDXa7rfTCfVgWo3AXHTYOtIKAnu+KAWt2SI6Vc26upp6KfvXS43xV5deBGYpRS+TQX69TBp6mVYyBMFuuyN6Y+6lz/ziJB3NoFxgnpAyT8p7G7khL+9k3Os5LCK7eLTJe2cMgJ9uM52hUApazyLoNmNK3izKZGwLTdoFl8/Id+Dxrq40+/PUjD7KPGiKj8I7ovZ6nOVNjOCaxuf5GD2Xu87HsF2ljO8IyXNeZTz+9Dhuq7Q1rnErMM9KsW3abmldWToQHNo2fYdckm/OswlJvrnArDlkT5rXSZ/1OW7QfxHm9S1jXqe/MqN4MSONcSBP+xU1xnr13Y+04wLzvOvHXtez2OsQ8iXZa23TBYcp1AJDm6ftsbSlyx7r9GXa4+926JZxE2Z8Lih6EZ//GtOhHeU683sxp3BsJ/VrgXkN+vX3Z+zX9Fc9ZQ428mb2ihy+39mi/V5t4z2O67rV9613xhyFnCJLCJzo4dpT++BZ5zL9+hjSmjdolRy05h20zuWkpeXabxu2Mx4dNkzXw2XDTqOu2obRpvBYi4xZ2j8dp6Od8eGbvrqAbxrAJul51fJvdD/iHP562Lr3GnS5Nj+nyjo1rnU9rPn6F1P8tBB/WzbC1bfoY2kbYp0K8e3HjGbQi8C8LUUvowX0MmroJVQyBIF9kkDgPM6TdZeOGO8RmAcz+nozkL1Ta/NQ5AU/3WYCwzbTc7JuMx4CoP2TsR3Gn7QL1hwo9Gj/zgE3zf68L0X3Gpd+HWOX4/j9/ZD3ImSN/ll7+1LG+GkPyt/X3aT9QcQFHt1HT5bpy3QfvfBxYI9xpvojNc60n/foyPhk+1GevV735Wk/kcN3+w0p/lb7zSqZbvS9fR2H4N4f9/YZ24ueaO74Qkq84ktdrfJp/4V7+zvxbcxPpe4m353j4EErXVf8cId3926efJLOafR1N3npvX2Bt/b2z6IOg6iD4HRgjmvknXdFjsHAX55fKdg9x1GP+7W3r/eVJb4icmbZ25c6UG9Z7tER+EpGWqUctKz9cY5l7u0vKFm1Tqz6CA739q17gRaM+mhfc8FRH/mNOaLCJxpfv9nb5OXK/9Hj1opfnMO4fZJhexjvn1Vlnd7bl3pYe/sXHLbOWk/l2dtn27r29juQ87AdP5jKoBeBaaToZSrIr5cpQy/X295+ko64hhWYx6fMk9fb3r5usyx7+7rNkvb2ZWxzb/9Jhk8gdIWeK37qsj+3Z/RRGD8VH8VjH6rR9w3AI1D1l0fkGAz8vbvQalc9XrnHxFi5lE1Atjz3pfNdR55sW9Wy+dLuls3/Fo82n361y+afN/iJbz4LeC37dzpkJ/0LCfRZn+MG/Qcwr290t9K19gWYzzytynzHxM+iDmwHxsQF5rsy2utZyN6pfbGdeQf8zkI+2mJXjF5wuIcuMLR52reXtqQ9ZuyVMPQTBeaFDt3SR51C2QVFL+LzipgO7SjXmS/CnKL3u6x+LTCvRr/+voz9mv6qyO1j7Ul7Izz4cL4QOXzfVKR9BW3jfe8B6r5v3ZR0FHKKLGeBEz1ce0odqLcsc5n2UUlr1qBVctCaddCazklLy7XfNmxnPDpsWJZ9RsGx9vaz7uPT/uk4He2MKx7tsoU61kFb+HMp84zGZQzQmlct/0b3I87hr4Ote3d3K12uzadVWafGta6HNV+/KcVPS7MRrr5FH0vbEOqlAzkP237MeJCuF4H5lRS9jAf59TJu6EXffRwEu+cq0ZvADQS7c4D3uu8k6Yh9SmDemdHX482cnVqbW76ebjPL19P9XbfZSGD7fzK2hSbtgjUHCj3aP67r0+zP76ToXuPSrwuC3e9ql/qcQJn8/s7eJv4fYG3/6F54skxfpnvhuS+jpP/kK974SI0V7ee7GGV8sv086Wp77TYY7H6y5lcM+pHJzK8YVLpLy6+4Ed9zwz1ZKdM5usyt5v78Z1NiDg93t8qnfRDuzwvM4zE/fcGIOVh54a4Y4I5uenbz5JO0P3+gp8kraZ+PcROBuRl16OlpyqTPDnuc426Ys/fW/ryv3C5rrKSdvddnzawYic67yLo/L/CVjLRKOWhxfPPsvYwf7s/rnAnr7L2uj+Bwf37eqM8Foz7a17zgqA/HyvXoo/p6b2leH5V7Rp58r9zvrGQOuE8fdSaHTPRxfL6LMY+PStvr00fVttflo/JcOmOlItv14KP6zCHN037MIfXZfkOKv9V+55VM9OnYDlleDbVfeJaPSp9b50HQv6WP+jWx75V0t9JtDv/Ouh9KYH6qp0njdvh3+vwF6YqP6sohfVqKj2rV4etRhzz3Q92NOjz9UR911zjL4qPeaPdD3Ug+qowfHz7qjFGfvfJRmRPNva8HjRxS6ivJ9lg5XPdg3L7YsD3MK9F5LVG/9XmOcCqhHtyHE5gXOmwdaQVBkJhPpHOOBIfnCfQ+cVJurSe9OO+Hol4E5vtS9DIZ5NfLpKGXKSVDEOy2O6I3gfOdf5ykI+sOrf+UMk/uZw6ptU+l28zap0q704t+MX0hGdvcp3qx4RMI3XbP4L80o4/CHFLxUXzmauf12Rl39+mzJ+0T0me3zhZL2QRk0+Na71ETj33fk22r5rX5r74ObP6Mwc8VPxaYNzhkJ/1KAn3W57hB/39hXn9zTytdK/+EPozOOfeYV2DmXui8hl25Fxnt9X7kX+3MO468AoHJklfAXE2Boc3Tvr20petOAIGhnygwv+HQLX3USZRVFL2Iz8ewVrb2c96FOSUpr8rKjf4H9Ov3ZuzXHciDbnCuDsCDD+cLkWMw8JbXar7LSdv4TuULCX/tq8jaU+QUWcaBEz1ce0odqLcsc5n2UUlr1qBVctCaddCayklLy7XfNsw6t6Tb0cpnS7JhzCHVNiwtX5T2T8fpaGcsW2j5ptoW6n052sK/y+ib0u7dBpuk51XLv9H9iHP4J2Drbuptpcu1+ZQqu57yAP8lxU9LsxGuvkUfS9sQ6mXBv17Mey4tvQjMF1P0Egb59RIaehlXMgTB7rlK9CZwvvOPw6CpC+qIa/YdmLjfp/l6PJvaqbX5zhhw3KMnMK68X8HhOlxgaP9kbAtN2gVrDrRySLmuT7M/R1J0r3Hp1yWds9O5O9p3ZI7NCeS9LPW20qX9m1FlnY5NVpQuqMcxhx5JKwjsfCvXOpVrNmudqu8o7HRs0tKLwEyn6GWygF4mDb1o/yoIdu/xW7FJTz553aUj9imBWcho/zrgJzaynDXSbWadNdL9XbcZfWLmtsrYpg+3BPun/T/rfLs+Q+SyP49N0b217j3QodhknhwVxiZ95fLQtxb+erymxSbpl+WJTTJG1cnYpGvuvN2jzadv57L58wY/iU3q/AbK/g0O2Un/fAJ91seKTT4X8/ozelvpWjEca6+J5yjGIYtvn174cw0kMN+W0V4zl20/Y5Mh5EuKTY4rGMGhbyowtHm6j1uxSW2PdQyF9vhOh26TYpPnFb2IxI/FdGhHGZu82/Cppe2tfi0wL0W/vpyxXz8am2zyt2KTnsZ1Pcv6WscmRZYQONHjOzY5Y9ByxRNnHLT2Mja5HzbMik2GQfNJik0m2TDGJrUNyxOb1LFG2hnaOeFvrc11bFLvMTI2+ZMZ1+a0r3KGxppXLf9G9yPO4T8DW/e2ArHJToxrXQ9rvv7ZFD8txN9JMbikvkUfS9uQpNikTz9mNINeBOa1KXoZLaCXUUMvoZIhCOzYpMD5jk0m6YhrdoF583UcmwxFXvDLcne9npN1m6XFJsP4k3bBmgOFnis26bI/v5aie41Lv455lRX8/iB+L8flF/H7b8a/DwTe7pxt5D0TI3IMBv7ODpWC1vep6nzcQ0HTJ75z88odmw88c/XuuzZWr9x1+dI3bj7/vs17r5Qg3kVVFf6WVN0DKDuD7yeM3/kMA54qOqN4nFF0uOV4xpBd8LQqIpikK2qPGzLR/Pu6yrhotxoIHn3VgkumL9PrJerc/s4i043yyvubIZsOJ+v0wb28Fp+2hu1HefZ6msnTfiKH7/a7WfG32m9eycRjyGwH3Rf0KxL2E49H0sQGMjVbvwqNLhaPpP0LXBbrONdne1vlE9fWOpImMM/sa9L4HJZ3gkP7O486l4LW1y+Q7pdS3LayUYegr8nrvKqDwDMctyMj6tDV15RJX1nvcY5rsE4BePCx5rhB4PkYZ9o/sY6k+TrObI2VsuIvoTeRUx8DsEJvUgfqLcuRNIGvZKRVykGL47uMMhk/PJIm30VWrRPL9xQcHkkT2rxO9bRRn9OqPqeD5PrIb1F/rsbfhU80vkbj8TUQeOu3uZdGIofvpVFZ8df9gn4u+wCXliKbbt+LihbxxgrizRXEq6I+B+PvXD7P9zV/H4jLD+L3D45c+855hHZXz0+iK9r8neOOsO1f39dKl31/XpV5vNKizjCurocVxl2KZffxivMydKDDwdbRUY96qVlbaZZeBOYJKXqZLqCXaUMv+gq1INg9N4neeEWlp+NddZeOmJ4iMLc5dMTwI9cT+5kapNvMSg1KOs5Cu2mt3/Q1xLQL9BuFrtBj+JFHDNPszzel6F7j0o/12IdqXB8F4BGo+ssjclzvrxukT5HnejqJsXm0bVXL5ku7WzZ/3aPN59rLZfMvGPxk/WZdKSIwz3XITvoLCfRZH+sVAT+Ief1SXytd63VOTKvo4GsDzHRXnUrKVM77Mtrr/XglvLWtPgn5aIuzpHJyC12nrVn2wNoO0tvh2j6w33y/Q7eMrXEbX18BFfF5HXxY6zWRP4Q5RaeyW/1aYN6Efv3DGfs1/VVPaY0NztUBePDhfCFyDAbe0lsrru1Cxic6kaIt/LWvIvEJnVYzCZzoYXxC6kC9ZZnLtI+alOKp5zeL1ryD1rmctLRc+23Ddsajw4ZZabZJNoypQdqG0aZwa1z7oVYsl3bGioW1e6XGG1PmGetKjc860hUt/8b1Wvn/Dlv3/r5Wulybn1NlnT56IfWw5uu3pfhpaTbC1bfoY2kbQr1U/OvFfIWXpReBeTBFL1leN6P1ctbQy6SSIQh2z1WiN4HzfeQrSUdcswvMezL6eh1IoWxkSQPXbSYwruMIus14JIP2T8a20KRdsOZA69U/2hd02Z8Ppuhe49Kvi/rdobj8cPy53TaQZe/aplqO6HWhDowfd6NcYD6SMva68HeEPx5/P6DkJ4zg0Aftw+9BDCNwfcAnbKjoCl8Lj3IeUjhRnzms4Ibxvd9RF6nDKcAI/d4gWb8C8zcO/Q6gDj76QR3ydEO+PpQLzD+k9IN6sFsvVj/oUzB1fI8ejgWB7cLvh4BP2BDldfC18Pi9S+FE/aBfwSXx6QIf+X0UdEIFZ40V67hgUt/hmBWYz6XYHY27bXcONOslOqbvTHl99zerbgJT6k+um9XfrFiB1rfg0O7Q3sin7pcath/l7AcWHuXsUzhcH9XBR76HQXJdLLsj9F19R2BucujX9/zTgDycD2gfBeZISj9oBLv1YvUDbbMbSi9F5x/2gwb4Wnj8Xlc4tBd9KXxo3+R32p1+BWeNFcvuJPUdjlmBGXe0yZCBG9HcgN0J43Lxn3zPc+xXrFufKo+emZT+pvuSlTOh5znBod3pVzJwnmN7E5b+cB/4WniUM1Q4jKVw7pXv8466WHYnjL/rvkP9Ckwjxe5oX+vW+O9yW4/t9+rxRb93JaUfaHts9QPdHtoucCwIbFdg+7eEZT/g/GPhhUoG4nD+CVP40L+W32l3phWcy1em3Qnj7y5fWWCenNHudIPmV8Pu6D0r3/1N2xeRj/1NYL4upb/pcWjNc7q/CQ7tTqhkyNLfuF7uB18Lj3KeUzg8tmjNc7Q7ui6W3dFrdEu/AvNtKXYnBF3f84/IF6ry6PnOnPOP1Q9CBaPnB44Fge3C74x5JeWs0B5YePyufSvanXMpfDjPye+0OzMKzjVnueI71pwlMJcz2h36UBOwO1LXKvjrvTwrvi4w9/U36b6sv5Uu84t0/oK/vn0tRtmfUI8Q5QLzopS+rce8tXcSKhjBsa5PDg29VPzrpWaNeUsvAvODOcd8Fr10G3rRdicI7GupBM7f/Hit7yTpSPep6PnRlDG4n1fm7+xVKX7yJO1J6P6u24zrOe75ydimDXsZeGfZ32MsOs3+vDxF99b+3kOla9995njmzT0TOXznniXtLzD3TM91XJMxBndO0dL9iHiSn+3xKrAqbY0et9yzFZj/lmLbQlU/K/dM60BwaNt0TgHnxzmDX3eQnHsmML/okD1pXg9Bn/U5btB/L+b1txrzunXVYhVloSrzF7e7Nqfp+G2Iukq5wLz9+rHXLXkbO/ML+OkYGdc5lIkwOk47AhjavFDhSVu6coG1D8Nc4Hc5dMs8Ea67qopexOfvY4Ck3LPfgX44tpP6tcB8Ev369zL2a/qrnnyOBq+pCMCDD9tY5BgMvPmKFcsP0Dbe47iuW30/VPwl96wfMEHQut/B3DPdf7POZQJvrQvnDVolBy3XGjPMSStUtPbbhlk+p25Hy+dMsmHMPdM2jDaFeRYyZkOUiZ1h7tnfe/RN/6mAb/rReNBb86rl3+h+xDn8M7B1Rwda6XJtHqqyTo1rXQ9rvv5czv3WMP6epW/Rx9I2hHqp+NfLth/TyKCXnf28AbdeGgX00jD0Yu0dh/iu9/V8r82TdMS1ucAMOnREO8n9vk6tzXfGAPjpNuOeqsDoOVm3GdfmIcpkbHPvU+yCNQdauWchcNPsz/EU3Wtc+nU8vxqCvz4XK7bROpd2eqBJ93EDrXRp/3S8stPnYqUejL0KzNmUcZ7UblnOSHHNNqdk2I9zsf0Z9CIw8yl66S+gl35DL1bsn76C6I02hOt633HtqpKDOqpltH/Xy7nYtPVGCfUUGN1mI4ChTbRik4+D/dPnYrW/aK2FXfbn1hTda9yI5ssRm/QUB6zdyPdVWe06p2S2+sicokW8+LiHz3Fbpa1xjVuB+boU26btltaVpQPBoW3TcUjOj2MGP4lNWvcaCcwzHbInzeukz/pY5wcvY17/VmNeZwxnTvFiPFbKPPqrZmxS+NOOC8zq9WOv92xdr2264HANvzOnA0/bY2lLlz0WGMse3+3QbVIcIVT0Ij4viekk3TP2fMwpHNtJ/VpgXo5+fSVjv6a/6mlfpXGjvGJF23jf61Dd9/Xet8Qm9d61KzapffCsc5nAzxm0zhu0Sg5a5x20ZnLS0nLttw3bGY8OG6br4bJhjE1qG0abMocyfdcP7Qxjky/x6Jv+dAHf9MWITep51fJvdD/iHP4K2Lp3DLTSTcsb6sS4duV+CMyrU/y0NBvh6ltW3lC/oZeKf72YsUlLLwLzxpyxySx6aRh6qSsZgsDOG2Js0tM8WXfpiPEegXlrRl9vDrJf77FJPSfrNrPuSkiKTb7D8KOEbp69Gcv+/EaK7jUu/bqo38l9AGH86e+ux2t5uhXUgX52GeUC856UsafvAbXWjmUFo33jSAcXlQxdQet9shr2Asp5LsHCo5wLCodzpnVX6WyQXBepA/O1hb7OcaB+BeaDDv36u7f+Wj+oQp5uyHcR5QLzRyn9oBrs1ovVDy4qmKrSC8eCwHbhd96tS1j2gyr4Wnj8XlE4vANvIYUP7yKV35mvfUHBWWPFyo9J6jscswLzUIrd0bgRzSPwu0RG5tP57G/s/6wb+5vAfDylv+lxaMXjdX/TMdui/Y3+80XwtfAop74/OOonYwpuOGi9m9Kqi2V3eG9wkn4F5nMpdsfPvd32/CPyLaBcYL6Uc/6x+kHSndy8L+eCkqErsOcZwrIf0B5YeNZcxbusZxVcEh/Oc/I77Y7ej3TNWbQ7SX2HY1ZghgavfabZnTJofipo1kv7Q777G/s/68b+JjA3O+pmjUMrfzLpHTW0O0X6G/c0FsDXwqOc+k5o7ldwDMj3WUddLLvDdX2SfgVm3KHfgcDX+2fs+UfP65x/plL6gR5TVj+4oGD0/MCxILBdgT3PEJb9gPbAwrPmKuvO3/MpfDjPye+0O/oucNecRbuT1Hc4ZgWmntHuXATNPwya9dL3E/nub+z/3UFzb5D9TWAem9Lfksahq7/RlxQdFOlvXC9fAF8Lj3LqO3EZw7X861lHXaQOtDs6RmnpV2CenGJ3/OxF2/OPntc5/zw15/xj9QMd39XzA8eCwHYF9jxj7esGwW57YOFZcxX9Xn3XeBIfznPyO+3OnIKzxor0C1d8u1fRYd95Vord0bjR328JmvWSu7K5zhqHLHsdW51AHVi3cZQLzFpKf5vA30nz3LiCmYAeRAehksG3Ds5m0IHA3JXSvhI75Z3nndpj2mlL8NN3CgqMq00ER/QwErS+druE74JnjZ0zoEUYwe0BzBWHbrn+lToMGfSiv++Ovw8Eu3NJ9nIfmLwD8AiUTuTheD7jR6bt9wGO5ZBJ5Bj0qCf2AeEvvJhfFSqZGGfl+91CRStUtPYSLyqTNhaZh/Gde15jiv6YQb9f0eI7fJjH8aODrXTFNgk88zgEZvRok8aPD7bKSxvba9ShF985Vq069Bp4QWDX3eoDgsN3ZgntMw48i3aoYATnKGhrO2HhWbS1bRScI6At/Dhfkc9e2508YzyETJ7m0EreM4TU04RHmcZzyDQBmc56lGkih0xnIdOkR5nO5pBpEjJNeZRpModMU5Bp2qNMUzlk4jsu9HzBucbysTgHSn/h/WRnFb+oTPTVgzKRV2ws5eoBLOdJ3oFXAvww8ATmHSnrZD/5DtUK35USgAcftgXzAn31D+pO+Ot7qKK8vFuCpt4jIfTZ211JNxQ2y0FhffG3x0MzlbwvLWHSheCdgJyzHuXMk0TKl0vMGHJ6StSv8KXYWeRkYp/gHYo/kxzLD8Cx1AnCAn8K5QLzL0eaND4Ex1IfQEo6tMQkq5MKJ3qsQ00WPo2WdfD5T1MMkqeDLdsLrx7Fz9V2PNjS40cm82CL8OLCa0bJxH7PxYE++KET54jXWxCPQRM/bVVb9BfAvXbAKY+tETl8J6zrIK/uB/42N64F2HSQ1UpYZ7voIPGCgueii3rTi8UzCs/qaxFef4p81iJXcE4bMhGWSary+wkHXYt3j4LRgTbyJmxvCm/qh3qw8PoPNn/7EuYRX7rbS92wDaKHDuQZlMkc2I+yWdAR+Q4dbKVzwqBzwqBzi0HHd1Awj01iUNCnTdJjVbctL6XigoiLKJFN90G98UC8YwXxpP19JrsPBbv1IjwCJac8Isdg4K3/mJcxabvKYDjbR8roM+sxbQUZpYzrmF4/9auznwXgESg55RE5BgNv/aCSxfZFOvHkO9Ysn+GMwd+Tz1C1fAY9NiOf4WCwe64KglYfgklT0WMdasm6vhZ4BjbOpMjJtZbACM5pQ6Y5B55FW/vX+rBqkq80k4F2kt/G4LfeVO8KWg/fleJ/vFCb/LsA269wfF6Iknfsixy+x35a20R9P1rri+8h/ob4GNKXpN31mtrXWJhOkdvq04LjGgu+A7t5+sA0ZPIZC8oT4KSefPkBPMSaRSau5Q96lCmPv3QQMnmKN9bp/2eRSeQY9KinUtD6sm/hZcWCrBjoIGTLE9M50SYebU0H2q/xSG2/dtuhU3g3oUzPb0ziO4oysQFco1/CGl30wVj4PQdb5ZNYuMAfQbnAvBCx8HsPNvlacaWDqDP5cDNNYO4/uJsnn6Q6PJChDtZFNl+LOnwP6iC65Rznyfdq5N3voB3ytVfk8qe57vE0znddsib8ZxV/udxD5NQxK9GZdbkH9Zblcg+Bn8tIq5SDFsc37ZWMn1tAU/uVWidZ/cozRn2mjfpoX3PaUR+OFZ8+ap6xcr37qL7WTnl91H7I5NNHzbO+oI/jc92bx8eh7fXp42jba/k4vUomxguHIFueOOOJNvFoDzrQfo1Havu12w6dwivio+p9hIjWO+Gjij7o3z0I/07o68v86KMKzB8cbtL4Lfh32ldgvbsVH/qoAvPuFB/VqsN7M9ThuFGH16IOv4s6WPOupz6d+wI6kcP33tlBxV/7Qz73S6w9V2s//yjk1DF6y0eVOlBvsyn15LpxNiOtUg5aHN+0VzJ+XD6qtVet62P5qP1GfaaN+mTxUQWeSZ998fePYT//r2CHxHaJbYx+f9dIUxahaR2ICFEm38dRJt8nUCbfz6JMvk+iTL4zCXcK9Tqr5KaOxLZNgZ7gCcwnHbbNn29fLZxYPBj4S8C2+rPw0smsZyG04IRSNhwDBkrYw4r4YUWc2cvym+8FFmUSHoGSUx5mdwsek0R9LibyLLrolEwbcvZ5lDOPg9oHOQWPyaxW8KvvUJOuwOrgF5NZBeb74FgMxoXDgJX2ZN+lzmloTyqcAGXkb+HTaJ1Emfx+OJYtySB5OqWyvTg8qfi52k7kGASeD4OkT7IKLy4uppVM1gRuGTdr8pSysYJ4Yfzp0W7V8p7e4eTh65STpSfdVpFODnnSieUgn1X8D6t2EVnm40+9cOWNA9SbTrDWN0rxtA4TmsMU+azFtOCcNmQirMDxVgLXZozF+6SCEZyjBm/CzqTwpn6oBwvvcXGjRHa6Cls/nUH+UMFYjrbwDB14WXQjONSN8BNYzmEzKBMfZxplo6ATPVH9bz3USueEQeeEQecWg47H+aOW10fh/OHLv7PmD227eYqV84eU8TaZUNEKFS3i0X8N/dSvnnceCONP3/NAqPjr8URfI4TuTuK7yKbHnZ5TiHesIB6TfD35MnX2swA8AiWnPCLHYOCt/1QsPem26vScPW3w97ReqVoB4FDxl4RT0ZPoQuQW2YQOk+ykH4eQfyTYzW9E8aMN4Tg4nCJnBHNMwQjOaUOmYw680KB9SsEIDuc/4XfKgRcatLWNFhwmnAo/ge0CHOtSin8LlSyCI7ChwhlQcu/n2Bc5fI/9tLaRhFPxPcTf4O1aAhc9x5T8vsbCbIrc1njRsYRhQ37OXd3xv0mFdwC0QuD1oPy+eEcysgnfC9/rekwU8HmbQx5/kLc5+LyJI0/QlTdxhB5lKuLDRTKN+pEpt70SOXzbq1HFX3jRrzylZBoJdttTkU3bvlOKFvFOtInHRIEw/vTYfo1Havu12w6dwrMSBUKUiQ1iogA3wqInmjteh/W/4DMW/nrER0RfEgsXeCYKCMy/IsbyC4iFy++0v1KnbsWHm2kC8xZH7DqpDr+UoQ7HjTr8PurwK6iDlSgQoj57Pc7yzCdh/Ol7Ey9U/K1EAV9zhzVWrE3Eo5BTZGFfix4rUYB6y5IoIPCzGWmVctDi+J5CmYwfV6KA1olVHyt+edaoz7RRnyyJAlYcUuKUvA30/qEmr1GDF/fbOG45ngXm/2DcftKwPdOol95Hi/rtMVWvW+O/y+09da4ZdD2OoVxg/shh60grCOz5wrVeD6EDHduiXmb966XGdZpLLwLz5yl6GSmglxFDL3rNGQS77Y7eo/UZ23PpiHu8AvM3KfOk3CY8Ctk79Sa2nTEAfrrNdN6GFUfUbcZ46ymU7ex7x5+0Cy6fkbcNnwJumv35TEYfZRQ0fwlreE8xohr3bgLwCFT95eGaxtNcbsaIhJcVy2e7StkEZMsTk5f+43HcVmlrXONWYLrieTDJtmm7pXVl6UDHI2nfuT9h+ebHQCfJNxeYQYfsSfM66bM+xw36ZxHzusnwF+ivnFS8GN9lHKgT+w7S7sKfOUUCc4tDdx221/Us9lrvqVj2+pCCERzRwwhgaPO0PZa2dNljgbHscejQLeMmh1Gm49ARnyfFdGhHuc6cGmrKx7Gd1K8F5qno1zMZ+zX9VcaW93rtSXsjPPhwvhA5BgNvvmLF8ns7mANUt/r+McVf1p4ip97Ps9aeRfeXBf6kQWvUoFVy0Bp10DqWk5aWa79t2M54dNgwXQ+XDeNb0rUNo02hryFjlvZPx+loZ3z4prenzDMalzFAa161/BvdjziHfz1s3eWhVrpcmx9TZZ0a17oe1nz9zBQ/Lc1GuPoWfSxtQ6iXWf962fZj+jLoRWCenaKXviC/XvoMvehc7iDYPVeJ3nho0ufh+iQdsU8JzFZGX+8kZN/PtbluM8vX0/1dtxnz72n/rLX5ZcOPErpCj/bvGHDT7M+9KbrXuPTrGLscwe/3Q14eDEra25cyxk97UH7vTU3aL4ppX6/76JMeZcqz7zEJmXzu7U/mkIl7+xMeZcqztz8BmUI/MtXzvo0kjD8HPerJ2rMSXowzjSqZ6BcPQTbtl+k4DPFOtIlHO8n2ozx7ve7L034ih+/2G1L8rfYLlUzM79qvt33lxePevtjACZSJDUrb238N5i3BZ7zidUOt8on/IvDc2xeYz8CHfwN8eMGh/R2Pv0v8cELJ2QOYN6fMzdYlAG9BHSZUHaxLAATmfajDW1EHwenAHNfIO++KHL7PM0wq/tYFwZ7GeZ19RvjrfWWJr4icIgv7WvQwvqIPrJeCbJfH6TN+abRKOWhZ++NJe/tTSlatE6s++i1N3NtnfaaM+mhfc8pRH/mNOaLc238ODvlLW3FMSbvpccvxLDDvx7j9J8P2MN4/rso6lZOi62HFYT6Usk7We2JSF7a39iUEh20bKhmol2n/eqlZsXBLLwLz0RS9nCygl5OGXnQOYBDstjth/ClwPnP3XTpinxKYj2WMH9BX7FT8IBR5wS/pXCPbTPd33WbMfRxHmYztMP6kXaBPIHT1eVPan94g3f58OqOPMgGab8Ea3tc4e6Tm445Dtjz5sdIOHsdt1Rq30u7WuC3Fjn1W2xaq+rnGCf1qnevIeeCswU988xDwWvZ+h+ykP5lAn/Wx9kDHEfM6dFMrXStnbxJlJ1WZx31RM19N54IxF+uoQ3e01yFk79S+2M7ejSMXy4rR6z1YweF+l8BY+5CCJ21JexzG33sVDMeawIw5dJu05zap6EV8nhjTScohP3tTU76kXFT26539NvTr6Yz9mv6qp330BvdEA/Dgw/liJ8cn8HsXi85v0jbe47iuW31f7wnL2vMY/g6AZ609df/NOpfpnDfSCg1aJQet0EHrZE5aWq79tmE749Fhw6wc4CQbxr19bcNoU7jfL2OW9k/H6WhnaOeE/4SCp//Uq2AEl+dVnpwyz2hcxgCtedXybwTX8m+eBlv3vJta6XJtrvMIOjWudT2s+fqbUvy0NBvh6lshdKBtSIfzu7b9mKEMehGYb0vRy1ABvQwZetFnpoNg91zFuTx6fJ/ZSNIR814EZiOjr8e4QqfW5jtjAPx0m+nz8dacrNvMyveiTeRe+fMMP0rohvF32j/6aGn25/kpute49OuCYPeln2IrT6BMft8YaeK/MMZ/dC88+1546FGm6+yce6VoXMb3XSGPxHMgPHuf5xzIiTbxrHzxASXPXq/d8rTfID59tt+g4m+13ykl041+9l5sINcHYoO4Px/G37k//0rEHKzzBK9yxBwEnvvzAvOx4SaN18AP1/4/1xeu/XmBeX3K/Grtz78RdcizP/9O1OHNqIPgdGCOy332nvcN+jx7r++y6vT+vI7pJ529FzlFFva16LH256m3LPvzAj+TkVYpBy2Ob/qyYfyd+/OTSlbr7L2uj+Bwfz4MWuszadRH+5qTjvpwrFyPPqqvF1rk9VG5Z+TTH5zJIRP9CZ85pHn8Ce4r+7wrfCKHTLS9PnMQte21chBPKZnoOzBns9P3Q+lcwkdzSO32O6tkok/HdtB9Qd9rup94lo86gTKdB8G8Y/qoH4ePKrTp333C4d8JPH1UgXk8/LtPGz4q7e940Kxzko8qMP+a4qNadfi3DHWwfNSbUYfPP+qj7hpn++2jjiv+WX1U9rXouVF9VH1H+176qKNGffbKR2VONPe+towcUupL2k2PWyuH6wTG7dJwK91J1GtclXU6D1DqYcW7x2LZ28mVTMon4nmCUMmQlFvr694a7kG49LJzXjhFL8cK6OWYoRcdiwwCO4eU5zhD8NjrvpOkoxDlArPg0NF+55BaZ/V1m1l7i6GC0W3Gtfs4ymRsc69J7AJ9AqGr43u0P71Buv15bIruNS59FN/3Q+Xx2RnL9emz67Fo+eyufYFxyJYnvh/Gn52+H8p6d5fA3J7TtmldWTqwbJt1P5Tlm+v7oSzfXGC+wSF70ryu74cSGOt+qOdiXn+GMa9b+Sf0YY6psqjdRyDLXs9pOq9A5zXsyr24fux1pvuh9DrbujNA59EIDvUgMLR52h7nuR+K9lhg7nTolj4qc/2sPP8fi+kknbe8G3NKUt64lRv9UvTryxn7Nf3VR++HuvZw7elpXNetvp92P5TIMgSc6PF9P9SEQavkoDXhoLWX90Pthw2zfM4s+WxJNow5pNqGpeWL0v7pOB3tTFbfVNtCyzcVmJ8s4Jt+ArEvPa9a/o3uR5zDfwa27m3DrXS5Nj+myjo1rnU9rPn6Z1P8tDQb4epb9LG0DUm659KnH3Mog14E5rUpejlUQC+HDL0wdi+PdT+UwHncC6m7dMQ+JTBvzujrXS/3Q+k2s3w93d91m40Etv8nY5v3Q73N8KOErtBz3Q/lsj+/lqJ7jUu/LukODP3OCet8qcD8Juzfn6fEJkdVme/7x48l1MPS43tyrlPz3GNsneM+aehlyr9eavQ3XXoRmD9I0cvhAno5bOhF+1dBsHuPX/QmcL7j2kk6YvxWYD58HccmrfOSus2sOUvHsHSbcc+euYTaJ6RdsPw/63y7PkPksj9/laJ7a937RsQmfY0z5lUE4BGo+svDnGBP/dp8t6nOxWCfoa9/TOnRsom6HxGPMSpPa+mqNW6ln1jvK/l0TtuW530lzE3Qa86kc5GHQYdjcNiQ/eGU2KTO6dH0WZ/jBv0jODPyxeFWuozhWPHYw6qs03fX63toewDTHdftOjjzVM9y5knfVWqdeUq6m5frLYGhzUvyWWiP6csSxvIXhh26tc5YMQeIPmojBqAdZWzy5pGmfNrPs/q1wDwW/fo49uhd/boD6/UG1yoBePDhfCFyDAbe4qUVa+2qbXyn767XazWJTYqcWe6u1+dYs85l+v1KpHXKoFVy0DrloHU4Jy0t137bMMvnbOd+cevueuvcpmsdbp1zoZ2xfF7r7mZ9vlPfXcN9kJWUeUbj8gyNNa9a/o3uR7TFT4Cte/ZIK12uzQ+rsk7fXS/1sObrr3HoMYuNcPUt+ljahlAvU/71su3HDGbQi8B8bYpeBgvoZdDQi3V3Pecq0RvvrvcZ107SEeO3AvOMjL4e4wqdWpvvjAHw020mMK54sm4z7uHQ/snYFpq0C9YcaN11pH1Bl/1ZS9G9xqVfx7zKGfy+hd9n4/Jp/C53d3p8t3wj75kYkWMw8Hd2qBS0vk9V5+NG41d84js3r9yx+cAzV+++a2P1yl2XL33j5vPv27z3SgniTauq8Lek6h5A2Ri+nzB+5zMMeKpoTPEYU3S45ThmyC54WhURzJSCEZzjhkw0/76uMi7arR591YJbJro0X0avWqjnvV5C5Bj0qCdXCgBDkONKphGU3QzZxhWtcUWLeCfaxKOtYftRnr2eZvK0n8jhu/1uVvyt9ptQMjEdh+2g+4JO/9xPPB5JExvI1GyxQTySxiVV9EQuyc/CZbGOc71ypFW+LEfS/h+Wd6/G8k5waH8nUOdS0Pr6BdJ9XYrbNmvU4fWow1lVB4FnOE5gPow6/ALqoF07j3NcbndO5PDtzmn/RHTC0Juv48yurTodehM5daqVFXqT79TbVyg+X6H40O5mpVXKQYvj2zqm5jqSZvmV2vcUHB5JE5q8TvW0UZ/Tqj6ng+T6yG9Rf55Tskfj611YGnnqtw3ahwA8AqWTQNV1EHg+xpI+JqjHkrXcZL84B9l0++pXWxDvTEG8/oJ4c6jPQPxd6hr1gQ9iLhIeA8DpUvyjUAHnFNpgPVfpV2lwTvkI7PzDxlzFcTChynwfQxtLqEeIcoH5i5SQm16vav+iBLoCIzh8bfK4ksE6buJRL9uhyNEMehGYv03Ry2gBvVivkx5TMgTB7nlK9CZwA8Hu41R73XeSdDSOcoH5ZMZQJNcWnQpF7owB8NNtpmMv1jpKtxnXUVzLydgWmrQL9CGFrtBjKJIpPWn254sZfVq+Buj1mC899aHcRxhFDt9HGHW76vHKayIFlsdVOZeHilaoaBGP4zb0U7+qNW6to8c7rw2O49k+bBvXYS6bP2nwk7XcBOC17EcdsltHsjR91ue4Qf98TH87neJwK12meIaK136kvvJ6XLYDU1kEZsyhu/0+/mNdIX8C8nFrhv1Qp/sIDlM4rWPIei0Yxt9dR8oFhn6iwMw6dMs1jXUEiXb/62I6SUcYFw435QshR1K/FphnoF9XMvZr+queUjhzX6W6X1fhhvF3xip8pvrrvq/T0CVWodPvTwAnehhfCOPv1FsYuOs5ErS+kpe0JgxaJQetCQet0Zy0tFz7bcNEDpcN0/Vw2TCmCWkbRpsSokxf3WPFdWlnLFvY7vUaT0+ZZ6wjjK/EGjqMy605XNu6EOUC8y2wdd99uJUu1+ajqqxT49p1FFNgviPFT0uzEa6+RR/LdYRnxr9ezOuFLL0IzJ0pemnnaBP1ckLJEAT2ER6B832EJ0lH1hVMlzP6eiFk79TafGcMOK4X0vkV1pys2yzpCI+MbaFJu2DNgUKv6GuAvidF9xqXfl3U7yQtTdKOBmIYkWXv2qZaLsWySx0Yd+hFucD8YMrY68HfES2x4WzHXgUjOIyL9SkZugDXB3zCMm2yF3wtPH4/pHCYgtxn8Jl21EXqQDtwCPST9CswP+HQ70DQrIuPftANebqVfCyPnpel9INupRerH+i+0q30wrEgsF34nembhNXps8LXwuP3PoVD23EoBx/5nTZIp+9bOrJigkl9h20lMD+fYnc0bkSz71CzXiLjHPizD3B/kOnOAvMG+F2/fbiVLv2uXlU2ELTq5tb473J7z/bc2ZVQD+pRYN6S0re78DfHyQElP2EEh+vsHvyu9TLrXy/bftf5IF0vAvM/UvRyPsivl/OGXrrwuzy0s7QF0ePPLl7rO0k6ol0UmN/I6HcxtbxTftfOGAA/3WYC47LTus1GAMM5VMZ2F377bfhd2n5aR6d7gZtmf34vRfcaN8J7b/yHPx/r2p7IQSWPK8YlcgwCz0eMS/suOjU/kttqVz3+rD7So2gRT3IIPI7bquXPWONWYP4kpz9jHWNI8mdo27RPxfmx3+AneyIHAa9l/8uUPRFrXu9WcgrMcYP+5zGvP2TM6/TbexSvYdCRsqjdLyhZbo3/Lrf3bM9pC6oOwv8CygXm49ePvW6JJ+7MO+C3APloi9kPLyiYBXyPnhHA0OYlrctoj+k7Ekb7idHzbyl7ItJvzqNsTtGLPsdiArSj3BP5IuYUPbatfi0wk0fAK/6e1q/pr4rcPvZEaG+EBx/+LnIMBt58xYrlK2gb73Fc162+3634y56IyCmy6P7PPRHtg2edyzi3aFoHDVolB62DDlrdOWlpufbbhu2MR4cN0/Vw2TDuiWgbRpvSgzJ97ot2hnsiYmd8+KYTMe08vumD8R/WvGr5N7of0RbPwNbddqSVLtfm3aqsU+Na18OarxccesxiI1x9iz6WtiHUy6x/vWz7MReDdL0IzGKKXi4G+fVy0dDLgpIhCOy5SOA8zpN1l464ZheYr0wZg2IneyB7p9bmO2MA/HSbCQzbTM/Jus1GAGPFNYUm7YI1Bwo9ly/osj93pOhe49Kvi/qd2EfaP33lgoxLrvME5htg/+450kqX9k/HK33Hl7oT6mHp8d+njPN21qn0d7OsUz3qxYxNWnoRmO9I0cv5Ano5b+hF+1dBYO87CZzHuFLdpSO2n8DcmdH+cc+/U/ZvR6+O2KQ1Z+k1q26zEcDQJmqfkHahFCSfr6H9o6+WZn+upOhe40Y0H0Bs0lMcsJb3rKDI4fusYJL/zdik1a56/Fl9RO9LEE/ORXkct9Xce+4ptk3bLesMX5Y9d/ZnKRNaZwx+EptkfFPL/iMO2ZPmddJnfawYzs9jXv9xY17vB69exctaV3U6Nin8rbXOT10/9tp7bJLrdYGhzdP2WNrSZY8FxrLHP+fQbSSD9BsrNkkb/R7EJvW51ej312JOSdpLZ7/e2ctCv359xn7dqdgk7Y3w4JMUm/TkK1ay7D13OjapY1pFYpPaB886l+mYPGnNGLRKDlozDlo9OWlpufbbhu3Uw2HDrByGPLFJ+ib9qv70Q2n/rNjkezz6pr9bwDe9B7FJPa9a/o3uR5zD/xC27hNHWulybW7tw3QyNin1sObrD+eMTeaJe9PHsmKTQqvfv17M2KSlF4H5s5yxySx6uWjoxYpNcq6yYpML4OE7Njmj+FNHD2X09Xohe6fW5pavp9vM8vV0f9dtNhLY/p+MbaFJu2DNgdbeDOeaNPvzzxn3Zrjf81rYKbF7XDv68b+u5elyjCXFvAXmcyljT48r0b0rxqzntkgH80qGLsDNA5+wsyhn/7Hw+H1O4UR95pyCI58ZR130tbmlYHcOQpJ+BaYv7nRJ+dp+bPC1fqDnJj0vcG466JDTGqtWP0iam4Qvx4LAduH3OeATlv2AexwWHr/PKxz6q3M5+MjvzNeeVXCWjqw9kaS+w7YSmFOONhkycCOaHxhs1ot3TUSP7/tTxlEH1i1EucCMp/S3cfwd0RK/hf0tVDCCQ7tzRsngWwcTGXSwc6Y6pX1lTucdEZ1a++y0JfhNQD7q29UmgsN1jsAwZnhG4Vljh/2ZMILbA5iaQ7eM50odhgx6EcyPYjz1xrrogk76+psydwPmAGQSmMccbdJ9HHNgFN3o99uN3+VxxVOkf0R9ZcBPX9meWwaxF94NXt2ov8AMQo4e/P3ko83yg/276yO6ELqR/vslT6k/Ga9H4Y0Aph94AwpvQLVb1AZPiOUbDHaPg72MTbGto/73/wFFdhb7bLYCAA==","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"member_count","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zVRTUsEMQx9bdo07axeBN3D6k1QWN1ZDzOIeHI/wIMo3sXfu7/KlxkcSKYvTV5e0h4S4hZiB6CHxEwHvQc/pWXA3q6htrPdF7HtZkOkhZGXkNEj6ZGBxQgy7Q+euPeEm4ln8uX1n7P4dY8QtCGYlgfgAuUYXEAIRniJNEMJaWAyWZEmeUqYHCr6wFsekwe19AzVIdYyxGQ+RB1Q8xq3DZKrN3lCWeNuCEYBUiKliNY8hGwrJCsrklSeqg0wL5aN5zKcleSJvTSpPPsYQksuTxdk10b2FzTXzA0UEy4U0aadvHM92QtEYqNvWalQvdh15JLO6ZNTHGeKIQolJNc+BhPTjktV8vkQH8YhPskpxoTf0XeZg/MbBW6nQz1jQbVk7YoLbtb8AfmbHrDNNj8gCX+ssdy8oGO7zsxhnmA0s85hZfe6xvc2CBm98WbE8rQ8/QFNHfJWPwIAAA==","debug_symbols":"1ZrdbsIwDIXfJde9iOP8mVeZpqlAQZWqgqBMmhDvvpS1hRUUhhgovoEETt0vUZPjWN2LeTHdLT/KerHaisnbXlSrWd6Uqzr09odMTDdlVZXLj/OfhWw/QB3123Vet91tk28aMZGZKOp5+A7XLsqqEBNnD9mFjNB1QjJukELbvtBqJfuooUmDmuiK2JKCTmzDTc7F75kAfIAZJOhOCRL1C6n1IzPtsJ9pujXToDz1I0Rt4sweTC/2Sqoxs/kX5jDRv6Hb0PZ5od3zQvvnhaY/hw5qJe9Sw13qq3sCIKkeX4O7tcqsGcZKpxuAV1fUhqhXWwk2/sQaZ/pdJzT96IlVyJhdM2Y3jNktY3bHmN0zZie+7CgZswNjdsa+iox9FRPfI70e2L0Zseu016ofjkehacfsr1+rXg7sCHF2QOeGY5I/saOEI7ziDI+c4TUbeMILeMMZ3jKGN4lnNbFd3qSd1fihzme8Hte1TNpZjVcqwp52VhNn14lnBnRi93Exoe63gVA3xfFA0y4tRFMgk3ZpIc6edtocZ0+7tBBnT7u0EGW3jI8rNnETjrInbsJR9sRNOMqeugnH2Bn7qmXsq5axr1rGvmoZ+6pj7KuOra8eQu8z35T5tCq6N2kWu3p29mJN87X++SeIvwE=","brillig_names":["member_count"],"assert_messages":{"21":"Function member_count can only be called statically","18":"Not initialized","58":"Array index out of bounds","70":"attempt to add with overflow"}},{"name":"make_payment","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/31Vu64cRRCtfk71PHpmbwCWuHaAkBBojfciNCtARFy8TgiI+AEkcn6EH0AiJ+ATkJAgcUiICMktOXTkc6pn17Z05dV2b3dVV52q0121BwnO30jQJyIHCUkxSflI8CkYiu/X9yXrrd5+x/1tG+Ix3H2JetLTEWckHKmImL+RhPmxZMwn6T7ByfkxbZ/Q6wNzbXP/1RmmxxgO4lzfixv68lDkHSknZzFJjymUFUeEwcnBBcfl4CEs40Gyn1Y/jRCNflx9Gk0JRfD127j5Jw4UUnFehl5yGbB0MgKyjjMgP5Z5g3Qz0CrRZm79gu3M7WLgXM4ULrvVDxhzXaXXvRx7MNlHeggPxanEvXy5ugoag3pEEmI/r26u15JrJKESt2GEQhwVk1bT1W2YjvQoojxJ3aIM8RxltLC4rB7COIOOFiRWeTb5bIlc6OAvFLKAiThMIGEaK9x/f3HvkJRMdF8vJNRXJDQ0kgCMAaNOIKHs5QeQUHr6ei51Lz+ubrLMvVlY/hNynO7I0WghCZPppm2YDv5+kumcOrD4OAP0DKYRDOEUcf8NDqscG/FvvoRpS7/SUYKjTEfJHHGZPYSshBwq0mq+FZSqKVkiPl68pVYmEkFkGjKIzGNEsD9LPBMZzxjRiNTV8APMCNmihVA3ImNuRP5iRPLO/xM8rl9Xl1ssgAypj6uL+VpiTmAs4dlEzSO2nSIGHRPsfpPEGLxJq8QuU/p7kzJ7IEnHULKFwmXnIcwJiRsMuPBTMnl6M/G8Jc/E89ABtBsHuP9DBrrnMx5bIn9aItT9LcNe/np0zeoTmhmZ3bm2u9dqG8IO2CNRHUo6lERa/2m02hFjrqTVpe4Lirp2FaGErmLuSN2/aEI4D2cMhBQSHJY5xflz2arASnYhyLKD0f+yo9ER7jSgO4rXiD7mHqClJWmVtcO8KwuuazFIJaQyxGctRLQFMKm8SJQAS77AMsd5MdiF0ITdEXZ3BcMXcrXB1jtgCbP4K8xXhT1nZ7CVsBXty6XWvla/oA4qCxGdh9WkhC13wSph3XKBjW+H1TOshghYjYR97wKLfhHZBI9Og+YBBzJcdTjzvnZ79wHcBU1799mR95QckERxEze2KBMMQKD27+L59trzbwc/9rfTt3HuBO5T7R3DgMEAuEGV22Rbr6oDtwXoZe8+vHEBHgn86Cj3nt57+hI4YWZ09QYAAA==","debug_symbols":"5Z3bThs7FIbfJddceC2flnmVra0KWlpFQqECuqUtxLt3kjJOwkxsmswk68c3kIAP3z8a+/fZL4tvd7e/fnxZrr4/PC2u/3lZ3D98vXlePqy6by+vV4vbx+X9/fLHl90/L8z6B/lN+KefN6v116fnm8fnxbW5WtytvnW/u7jfl/d3i+sYXq8GwZKNbwGTjzkorT8Pwjo2fardx5RDpzQSOCSmt8Chy2Q38L9XCwonMJMh9xaSjHVnpI6nPOlo+yedak+aWFKv0DpfZhbyfWBhw++ZZRLm7kHvQ6+TTrMlzWa+pGm+pHksac/clzHPnioZUC6PYSf9aMfeEt9TU5Icltefh+l6Z3JBT9tSYMmOh84yd94o3rxRbJtQ6ZpQ6ZtQGZpQGZtQKU2oTC2otKYJldSEyibaPraJto91Tahsou1jT2/7kHGcM9ihGdf5wZ5UCKHvaIvdJim8gY6I0IIInQChnUGEJkTouquHUIMOfgtt9nIYhu5quz50MLRNenTky0efOaKX1/2RL2eB2R0wuwdmD8DsEZhdgNkTLrs3wOwEzA7sq155/S4us4t/z667rEqequw+hnfs4fxlVUxmt1Rht/0kpHfbN8Ya2qATLjrjolsQdB8G6B4XPeCi11thcQ99HSf9fZxojogzXoVY7nvE3rrKYwUYrYvchErbhErXhErfhMrQhMrYhEppQmVqQaWYJlQ20faRJto+cnrb5/zTQOIQoT0idECErrcbfJq2yzvZaKYIMHvCZU8GmJ2A2RmY3QKzO2B2D8wegNmBfbVr+uqGL00TktFd0xTnCbv239nhp5qyIuOB2QMwewRhH85adZnhspMBZq83JcMe+yaSPSbSeI3mJGQ8V1k7yxL7HDjR+1EZGt9EP2kOYfYc4uw5yOw5pLlzGN9aPmkONHsOPHsOdvYcZi/TPHuZPrCx2OcK2ftUO1FA/5A1HdhZ/OlkShsyUxMyD2wu/nQyqQ2Z3IZM24ZM14ZM34bMNlpBto1WkG2jFWRPbwWdf6KdnIGkJkhqhqSutiCCqVJfas7IOWR4jwwfkOEjMrwgwydgeG+Q4QkZnpHhkR3WK6/ni6syvO7aprwqI5y/tvmLmV5KLifddZy2Xau3ud5A0PQMTf+BCmcwZR7cMZH8MZHGq5TAeZotODuIFI+JJMdESkdEOrBDOUbJ1VNyg0h0TCQ+JpI9JtL4GyEmV7nCCX9g58CG1E8nM7QhM7YhU9qQmZqQeWBX6qeTSW3I5DZk2jZkujZkttEKktNbQReYo5EISS2Q1AmR+sDuWHGUqYOvUEseCOxeOLMzqmD+ZFGv711tTIRdvqaMo99TMaLYuv7yrGBD5VKz0I0R94G7EdfdwBv4qBs+9Y8+sBncIpdEN7xwCT6phmeTMjy9H/1mY5DhCRmekeF1V5UVeIcM75HhAzK8boetwOt22Ao8ssMSssMSssMSssOS8s5IkC18KgdOLnMktzNR3CvVbceHlW7gddtxBV63HVfglXd4i/CsfKFdadERs+6FdmLj9g2IA3jdC+1ke+rDGLzuhXaSHa2Dl4op2O2Yt412oNThLmxj1r3uvQKvez1kBV73uvcKvO517xV44JWobHXbcQVeuR2X4ZXbcRleux0X4ZEd1iI7rEV2WIvssBbZYS2ywzrlhywXO7xO+dmnxQ7vgR3EauCLHV6n+5zlCTu8TvepzJXSrftY5gq87vsOKvC6Lzwow3vdB2JX4HVfeVCB123HFXjgo8jZK7fjMrx2Oy7CIzusR3ZYj+ywHtlhA7LDBmSHPbDbfM5Lr6fr8F7gsvHpOrwXuG58ug7vgVMA1MBP1+H9wNXql1VaLN0JGP4Dl80rhidkeEaGt8jwuu24Aq/cjsvwyu24DK/djovwyA4bkR1WkB1WkB1WkB1WYB32tfv2383j8ub2/u6pi7P+56/V1+flw+rt6/P/P//8pwv8Gw==","brillig_names":["make_payment"],"assert_messages":{"70":"Creditor is not in group","189":"Storage slot 0 not allowed. Storage slots must start from 1.","282":"attempt to add with overflow","209":"Array index out of bounds","113":"Debtor is not in group","238":"attempt to add with overflow","142":"Storage slot 0 not allowed. Storage slots must start from 1.","217":"attempt to add with overflow","249":"Array index out of bounds","86":"Storage slot 0 not allowed. Storage slots must start from 1.","173":"attempt to subtract with overflow","260":"attempt to add with overflow","21":"Not initialized","271":"Array index out of bounds","41":"Storage slot 0 not allowed. Storage slots must start from 1.","169":"Insufficient balance, or paying more than is owed","227":"Array index out of bounds"}},{"name":"add_to_group","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"approve","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/21Uu4oVQRCtflf39MwNNVjFUOHq3k1mcMFE1zUyEEEQf8DADxAE9QcMxdBc8AcMxWjBXDAQwVz8A8/pviMbeKH7dld11TlVfXp24ow9Eqf3RHbifMIkek3wU4yEvzuXJOqJnjyg7aQPsRiGjlM9bY7TPrpjQZS4hUc95rsSFnrjDTg3PEW4Bmjy3JCcZJmtU5rcanIw+Wbyq8kjyIhf7eeO7iSKY4rLjXyb8621kIxREGpyEVOyXhe5ChamkyhzO+GkcGsV28Ktys7Ai2WhUQfkxyiZXUJQSVuZi7hUGpsBWb+IbuV4Nhmtc8lWzLWMsxnzFXJJRWJOFQdvS+3w0bLprq4cagPlMlsY6zjbNGI3WqzC2OwjaU73vTSiCBGBQyZkr2AjJvkAjIcSiHEgMaKDBcwega2WDN9HyVt5jMUTiVt5Rf5p7WZqbYhzE4BDY8moFwRjDGgDRkJLCpI8Rc5cUET0EfneCbrybDbaAwLmUPxsvB6I1wAyIWGV0DLPpF5TmOjxCH4ufs84pJ79RcvOC3vN1r4E10O4M4jGqIFEz6sDRLlUGj30kFzTSUUSx7a/6W1vR9rlZDcb549pYjtJNw8g5HIj9LYTmiWQC6sieCB48Df/RREkEiQ6BL0Xx6AF/VOH1yVWPbX/Hc8gMMB56zDjOK40NshEyMRb+9BvjRqfJbHBgFQIItZMqdiwSiWckwqMAQLxlIYZQUXHCck+ybSvN9sJ86QUY2j1hv7CnbZ6NSSc/yxpXy/VAh3j1mKquFwDhcWxTq3oiapbkdK4QeRX2eyL1v8U3bDtBvMmgWaljtNQgZsqL/dbf42znfBFqHxXi1GncQCxiFTk9kNh/4l04LqVPwvfdjBAEkVPj9oijwjI6rVcEKNFCz9S+GsfqdJH/0gh4W8tCFcGDIAbVLkNbWtVdeA2Ax2X8OvIOGQk8OEiF88unv0FlmUPcDwFAAA=","debug_symbols":"5Z3bThsxEIbfZa+58Mz4NLxKVVWhhSpSFCoOlSrEu9eBrHdJFjsOIcxob2ADY+/ntdl/PGObp+7X9dXj7x/L9c3tfXf57alb3f5cPCxv1+nT0/NFd3W3XK2Wv3+Mf9yZzRdwL/b3fxbrzcf7h8XdQ3dpLrrr9a/0PZW9Wa6uu8vgn79fdOCbrEOTdWyy5hZrNE3W0GSNTdbUZG2brJv6Epv6Epv6Epv6Epv6kpr6kpr6kpr6kg7vy4s9M6awNWQXsilsrvdsLZq+1nTJ2Zp5wtgzwtbYp5uMjTfM9gPMYMBuLcGQPSO1+8iTDtQ/aa49acDIfQvJujJzBNcbRzS4y+xPwpwe9FvoTdXh86qOn1c1f1rVdvKdAJHycI0Oa2Pbu3wHHmgg4oS1Y+6tvQFfHicuuP5vPV3GnXFiQTE7KmYnxexWMbtTzO4VswfF7FExO+tld4p11Ql/R0ab2aPbZZc93mN27NOl32U//3iPJrMTlNlTfdnBBzOMGTJuA++NZnjQDP+OK+lihg++DG/J95MES6GCE0zArXEwcXfC6evOYeDnt+EAb48o444oM+2EMOQZ0ngCPT2bghx88KPJVKCpfnMm1zv0Gm6u9+t11uSoBg/gBDRtncfaaPqMrz0QZtHKOItW8hxaGcwsWgmzaCXOopU0i1baWbTSzaKVs/B9wix8nzAL3yd83PcBY3GYlHGlnQcmVLz3/dQt0pt5XoKORiM0aIRGjdB1v8FBBRptjgZgcG/uMEFDQ6CBuJKWJe4zydbYUZgBXtD92dEtZXRfQffg+q5Ml7QTlODJAZ4yz/3rB43l08Z3ThaNZVTMTorZrWJ2p5jdK2YPitmjYnbWy548X83wipU1uX+y4UuJzpQIEg1fzHSmu50dviXhRqEfNkDR73rCKQmnmh5U06MaeqZ9elJNb1XT151i58b0L4X8MYXCMYXiMYX4iEL4ToyKQy6E9GVBCEDKQRkcLSTvuxHp7PQni0MARtnwmcOjCXvwLBs+YgGejGh4NJzhYc9RJdAMj5rhZb9tKvBWM7zTDO81wwfN8LIVtgIvW2HL8FazwlrNCms1K6zVrLBWtsKCjwN8ZR8x28zBdjQz71sqW47fb+kLvGw5rsDLluMKvPAJbxHeCU9uFPMDTva6gZhPcXDR7s3WneyFAxGxBG+FZ2Z4gI8VUaBhOR+FvXCWk73OoJyDcrIXGlTgZa80qMBrTl062WsNyvBe9lqDCrxsOa7AC5fjMrxwOS7DS5fjIrxmhfWaFdZrVlivWWG9ZoUNmhU2nH97wunS0wfsVvxS+GJ6+oBNiF8JX46CBtlbQyrwQTN81AzPiuEP2OgnGB40w6NmeNkKW4GXrbAVeM0KK3zzZQVes8JGzQobZSvsCdPTLFuOy3lGli3HFXjZclyBFz7hLcMLP1O3mJ5m2YfqltPTLPyU0WJ6mmUfq1uERyP7XN3T5dbRyD7dvhhITOFOzfCyz7evwFvN8LJPuK/Ay5bjCrxwOS7DKz70G41wOS7Cg3Q5LsJrVljQrLCgWWFBs8KCZoUFtQr7nD79XdwtF1er6+1/lrx5XP8c/aPJh39/Xn+TjP8D","brillig_names":["add_to_group"],"assert_messages":{"39":"Not initialized","119":"attempt to add with overflow","65":"caller is not admin","148":"attempt to add with overflow","158":"Array index out of bounds","193":"attempt to add with overflow","215":"attempt to add with overflow","82":"Storage slot 0 not allowed. Storage slots must start from 1.","140":"Array index out of bounds","169":"attempt to add with overflow","185":"Array index out of bounds","204":"Array index out of bounds"}},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"7Z3druS2sYXfZa59IZLFv7zKQRA4iRMMYNhB7BzgIPC7n94/UvceKSp3yF0iq5Yvkj22RrvW192qtdgS699f/vrDn//19z99/elvP//y5Q//8+8vP/78l+9//frzT7c//fu37778+Z9ff/zx69//9Pivvywv/+P86/G//OP7n17++Muv3//z1y9/WL778sNPf739/+3v/u3rjz98+UNOv/3xuy8uPHU0PXV0fOro9NTR+amjy1NH12eO9stTR7unjn7qtfRPvZb+qdfSP/Va+qdeS//Ua+mfei39U69l+P2v5Xe7w1x07v1IF4PbDnYxHxxNflnPe/uxbkfXenBwqn49daohPx78UrVrqjrSVnUpTNWOfF6Ppnw/taPl4Ojiy/vBJdUPx75U7aesOkxZNU1ZdZyy6jRl1VmwahfvVbumqsuUVdcZq6ZlyqrdlFX7KasOQ1T9UgkNU0kcppI0TCVj9JqXSsboHy+VjNETbpXEMa7zL5WMce1+qUTyelzqdvTCeTqfVwPo6z0W3k78UnSYsWiaseg4atG0Lhv4FLZjfY2vVacpq85TVl2mrLoO+2EMa9Wlflt1Wqas2k1Z9biN8azqcTvjWdXjtsazqgV74+MCvN+ZuCz4Xo3lXkmtDD9HdVvGi+F+7rDQa91h0rpp0rrjoHUXv2aUQsuHz9nBsS5sx+4+kzmpV5jVKyzqFVbtCsuiXqFTr3BUV9FP4aj+o59CUq9Qvacp6j1NUe9pinpPU9R7mqre01T1nqaq9zRVvaeppF6hek9T1XuaqqEfxrQulse8fKvQLRoaIiNRw9U0lvXYWGkvUcPlNNH6UUyx7iVquJ4yEjVcUBmJGlIiI1FDTGQkauiL5xLdsH3xPxqWgzP7lNYz+3w/+v2rROeGzYo9RQ4bF3uKHNbjPCMybPfvu0BuL5IsiBzW5/QUOazTeUYkLevBjlzaixzW6/QUOazb6SlyWL/zlMjoN5Ep7kR6FY6HE6nC8XAiVTie6O91PGwqsIlU4Xg4kWRAZNDwfc75EmRQsQR5LnHYt2o/iSqWIJf17uLk/V6iiiXIc4kqliDPJapYgjyXqOKruXqXuHu8zZGKr+bOJWq4WYWRqMLdnEtU4W7OJZJ+iRrcDSNRg7s5vxOANLgbRqIGd8NIVOFuTiVGFe7mXKIKd3MuUYW7OZeo//YxyW1trpKowt2cS9TvbqJ+dxP1u5uo390k/e4m6Xc3uZvEGhmJOa7fPOR8X+1828DN9dsbprGOJiuU4vYippSZOojSWjVRuUf5ww3os1/Wg7MPy+PBr2VTU9n5Xnb1XNl+xXerfzs2LO/vpzhKIWmUQvIohZRRCqmDFNK2/UfPQtwohfhRCgmjFDLKlbWMcmUto1xZyyhX1jLKlbWMcmWtglfWtLitEle+dUbVDVOJH6aSMEwlNEwlcZhK0jCV5GEqKcNUUgepxC+jXGP9Mso11i+jXGP9Mso19rZwMEwlo1xj/TLKNdYvo1xj/SJ4jc3b3DTKye0qqaNU4pZhKgnDVCL42SlxfQiDSgq7SvIwlZRhKqmjVOIFPzs1bFe2Sv6xkv3BvtL6jYivH1bpy8HRgfL6nG+4/ZoPR7+qJBUqY1i/XggxHaiMJlQmEyqzCZXFhMqqQmUKa8m3H91OZdDRSTiVzoRKb0JlMKGSTKjU4X04lTq8D6dSh/fhVOrwPpxKE96HTHgfMuF92h6xnEaliX5JJvolmeiXZKJfkpJ+uT3/fPux7FRGJf2SUamkXzIqlawVMCqVrBUwKsmESiXeh1GpxPswKpV4H0alEu/DqDThfZIJ75NMeJ9kol8mE/0ymeiXyUS/TCb6ZdLRL/P2hPXtx7hTmXX0S06ljn7JqdSxVsCp1LFWUNy6u//tx/1dTZK7GVyoUof34VTq8D6cSh39soS4qaT91aeoeMdS2IY13H48UKniHUsh+U3lh0LeVap4x3IqqwqHx6pU4fBYlSocHt3+WU8dPXe0W9z2pe7t54eJHeHWhV6pqHCE3akQqBxQ0dG/e1PR0e97U1GxmtediorVv+5UdHjJvlTCosN79qaiw6v2pgJve0QF3vaICpmkktOdSqkfqBzJ3LYmuCm+r9cFekNo0wh3RWjTNXdFaNNid0Vo0493RWjTvPdE6Gw6/a4IbcaCrghtZoiuCG0Gjq4ICQhbESKdNCNEOmlGiHTSjBDppBkh0kkrQh37cF6LEOmkGSHSSTNCpJNmhASErQiRTpoRIp00I0Q6aUaIdNKMEOmkFaGOvZ2vRYh00ozQpKnxD3ca+YdS1juNdOwj+zSVeqcSFuLeWKfHv1I02SSepJi3s98+1/7bj6eOTXCvRWiySfRFSEDIIixx3VjElRcQd4T7g4tfT1087WibTHifSPul39/PnXa80ew783bLdm5HdccbtkCUt46NgSfiDcMhy9vkF2wX8jb5bdyFvAm8RXnbXBK7jrfJLwUv5I18Kcsb+VKWN/KlKG8dm69PxBv5UpY38mUL71eEiIzNCAkIWYS1rgv9fln2CBHsmhEiqzUjRPxqRohE1YwQIakVoY4hGmcIX1UqSRvLaq5uet1epRKPz6hUYsMZlWRCpRIzy6hU4jcZlUosIaNSiWtjVCoxVucqixLvw6g04X2KCe9TyIRKHa4g0qYy+cDGOm7jYCWDjXpT0eE6elPR4VJ6U9HhajpTUTJkqzcVHa6pNxUdLqs3FR0rUr2pEKgcUIG3PaICb3tExaa37bkzhJKJX5citOmaOyIkJbPELkVo0493RWjTvHdFaNPpd0VIQNiK0GaG6IrQZuDoihDppBkh0kkzQqSTVoRK5p9dihDppBkh0kkzQqSTZoQEhK0IkU6aESKdNCNEOmlGiHTSjBDppBWhkvlnlyJEOmlGiHTSjBDppBkhAWErQpOmhhkVQkpm0DxLpe+oEAomm0TPIQ0UTDaJvghNNom+CE0uHlw0KoSUjAcah/b5qBBSMktoIN6nWy8SwRbI8oaHkOVN4C3K2+QXbBfyNvlt3IW84b5ledtcEruOt8kvBa/jrWR03Dy8kS9leSNfyvJGvpTlTeAtyhv5snHOBSmZBncpQqTAxr3dScnMtksRIqu1IlQyWe1ShEhUzQgRkpoRwhcK3hWhZEjVOLRriduplz1uNHpJ3ErGDk2DGwZC9BYrJZOY5uGNJVlZ3gTeorxhvWV5w3zL8sZiryxvrAzL8ka67M2b7ueOu6c8lUx2m4c38qUsb+RLWd7Il7K8CbxFeSNfyvJGvvxE/33AG/lSNO/YnD95IW/kS1HeNmdmXsgb+VKWN/KlLG/kS1neBN6ivJEvZXkjX8ryRr6U5Y18Kck72hxgeiFv5B1Z3sg7sryRd2R52/SDaQO4+EeCb/s1R5sTLFkqNr0VR8XmCjtDxeboSJaKTffGUbHpsTgqNp3QfUbHjVDinFC+y8zlwTctyxtDAkOWoXfbjvc++G8Nos2hjX0R2vTYXRHaNORdEdp0708ipG2ilE/f7n8WbY7LexIhlU0mld270Oa4vL4IYQybERIQsgjTsrWTFNwOIXxhM0L4wmaE8IXNCOELmxHaXALuiTDYXC/uihDppBkh0kkzQqSTZoQEhK0IkU5+B8KzeegxIJ00I0Q6aUaIdNKMEOmkFaHRQdRdERIQsgjDts26I/dh1Xp/8Nke4dHopMzPo83cRmt0UuZ1vNHTOvM+nfwVjU7KvI431vJkeWPhT5Y3VglleRN4i/LG+qMsbyxWyvJGvpTljXwpyxv5UpS30VGg1/FGvpTljXwpyxv5UpY3gbcob+RLWd7Il7/jmRtfNt60uyUrITI2I0QKbEaIYNeK0OiE5q4IEb+aESJRNSNESGp9kNjouOOuCBFlmhHCWqf9BlpGR9lyVGCAD6gYHQvLUYFBELxn2+hoy8+jXUvcTr3scaNpiuJGNxbFjTYv+kCC0bl/1/HGCposbyy3yfKG9ZblTeAtyhurfrK8cQODLG+ky9686T4jKe62FzA69+863siXkryT0TmL1/FGvpTljXwpyxv5UpY3gffn+e8D3siXknknGZ0jeh1v5EtZ3siXsryRL0V5G53Xeh1v5EtZ3siXsryRL2V5E3iL8ka+lOWNfCnLG3lHljfyjihvj7wjyxt5R5Y3qeB9+2c9dfSZ513v38GEx5vij3mXuL6aruR0zvvs0Z2kZBjuOLRPH25ISkaWToNbhzeZBbeSUajj4GZapZK5qfPw1rEUOw9vHUux8/Am8BblDfMty1vHUuw8vHXc6jMPb6TL3rxPb41VMp92Gt5KhtnOwxv5UpY38qUsb+RLWd4E3qK8kS8/0X8f8Ea+FM07SmbFz8Mb+VKWN/KlKG8ls+Ln4Y18Kcsb+VKWN/KlLG8Cb1HeyJeyvJEvZXkjX8ryRt4R5a1kdvk8vJF3ZHkj78jytukH0wZw8fnjo1KvVGy6No6KTW/FUbG5ws5RsekLGSpKphn3pmLTY3FUbDqh5x5izneZuTz4pmV5Y2hzNfc5ht6tZ3c++G8NopKhw5citOmxuyK0aci7IrTp3p9ESGlDmOq3CJUM7v1chKfTw1Ox6fW6IoQxbEYIX8gjTMvWTlJwO4QEhK0I4QubEcIXNiOEL2xGaHMJuCtCm+vFPREqmQp+KUKkk2aESCfNCJFOmhESEPII74ffvinZIUQ6aUaIdNKMEOmkGSHSSTNCpJNGhFnJDNjPRfjMnuxne4RnJRMyx6F9fhttVjIhcx7e6GmdebtluwXdUd3xRgMU5a1kQuY8vLHwJ8sbq4SyvOG+ZXkTeIvyxmKlLG/kS1neyJeyvJEvZXkjX4ryVjKRdB7eyJeyvJEvZXkjX8ryJvAW5Y18+TueufFl401uhxCRsRkhUmAzQgS7ZoTIaq0IjU5d7ooQiaoZIUJS44PE2ei4464ICQhbEcJap90GWtnoKFuOCgzwERV42gMqRodbXnTPttHRlp9Hu5a4nXrZ40bTFMWNbiyKG21e9IEEo3P/LuNtdO7fdbyx3CbLG9ZbljfMtyxvAm9R3riBQZY30mVv3nSfkRR32wsYnft3HW/kS1neyJeivI3OWbyON/KlLG/kS1neyJef6L8PeBN4S+Ydo3NEr+ONfCnLG/lSljfypSxv5EtR3kYnwV7HG/lSljfypSxv5EtZ3gTeoryRL2V5I+/I8kbekeWNvCPKG6OThXmr8IOhhPXoUCh+OPpVJZlQqcL7hOrWU99+LHuVKla0WZUqfBWrUoWbYVWq8BCcSh1jRVmVKtYHWZUqVuVYlTq8D6eSTKg04X10DIpkVerwPiUtm8rlQKUO78Op1OF9zlWWRYf34VTq8D6cSh3eh1OpZN2HUUkmVOrwPpxKHd6HU2nB+xQdYzlZlSa8j44RlLevVPymMrm9SiXrPoxKJes+jEol6z6MSjKhUsm6T143YKYlLHuVSr4nYVQq+Z7kXKWSkVpLSeupb5UwR7vFhftTjy7fVb5vIVqUDL7qTUXH3dG9qei4h7k3FQKVAyo67gfuTUXHU6G9qei4l7k3FR13HPemouO+4M5UlMwr6k0F3vaIik1vm9OdSqkfqBzJvN8YnvK3m5cUJVOFLkVIQNiK0KbF7orQph/vitCmee+K0KbT74rQZizoiZBsZoiuCG0Gjq4IkU6aESKdNCMkIGxFiHTSjBDppBkh0kkzQqSTZoRIJ60IlcyTuxQh0kkzQqSTZoRIJ80ICQhbESKdNCNEOmlGiHTSjBDppBkh0kkrQiXTg55E6B/uNPIPpax3GimZgfIslXqnEhbi3linx79SNNkknqSYt30/b59rv/t4mmwSfRGabBJdESoZufC5CG+eeD285A+75u4PLn49dfG0o20y4X0i7fMNjW9/Hbz78nbLdm5HdccbtkCWNzyELG8YDlHeSgYAzMPb5LdxF/KG+5blbXNJ7DreBN6ivJEvZXkjX8ryRr6U5Y18Kcsb+VKUt44xNZfxfkWIyNiMECmQR1i3MYd+WfYIEeyaERIQtiJE/GpGiETVjBAhqRmh+tzzqlJJ2qC6nnop4VuVVcc4JlalEhvOqFTilBmVSswso5JMqFRiCRmVSlwbo1KJsWJUKvE+jEoT3kfHOCZWpQ7v47dBuLcf/V6lDu/DqdThfTiVZEKlDu/DqdThfTiVOrwPp1KH9+FU6vA+jEolo7U4lSb6pZJxRpxKE/1SybghTqWJfqlkHBCnUkm/jHFTmfNOpZJxPZxKHWsFwa8Pdd9+jHuVOlwBp5JMqNThCjiVOlwBpxL398rttlBtDo/4RNq1xO3Uyx437sEUxa2j+02DG/d2Sm7dUm3OGbiQN+4aleWNR+tkecN6i/K2ORvhQt54Dk+WNx7ak+WNdNmbN93PHcOON4G3KG/kS1neyJeyvJEvZXkjX8ryRr4U5Z2QLz/Rfx/wRr4UzTsJ+VKWN/KlLG8Cb1HeyJeyvJEvZXkjX8ryRr6U5Y18Kco7I1/K8ka+lOWNfCnLm8BblDfyjixv5B1Z3sg7oryNjiJLG8DFPxJ8mwNdjQ4M46jY9FYcFZsr7BwVApUDKjbdG0fFpsfiqNh0QvHuVnxKnBPKd5m5PPimZXljaHM19zmG3q0Pdzsf/M4g2lyg7YnQ6DimrghtGvKuCG269ycRUtoQPpx9RWjTvj2HkMomk8r+XWjT63VFCGPYjBC+kEeYlq2dpOB2COELGxG6RcsMn0sZwhm2M4Q1bGdocxm4L0MCw2aGyCjtDBFS2hkipbQzRExpZ4ic8jsY3g9POewYapm3dSlD5JR2hsgp7QyRU9oZEhg2M4S34RmGbZy7I/dhFXt/8Nme4bdfhvbTF/f5fbW3/4peJQwcja0z8Ft4Wg92VPfA0QWFgWNpTxg41gGFgWPRUBg4XLgwcCxHygJXMv9vIuBImsLAkTSFgSNpCgMnAJcFjqQpDBxJUxg4kqYwcCRNYeBImrLAjc7lffK5HF824LS/W4sQHtsZIg+2M0TEa2dIYNjMEEGsnSGyVTtDxKXGZ45vDJGA2hki1DQzNDpS94ThGxbY5kMscMKHWAhYjrDAJ0je1W10Gubn4a4lbqde9ryNTgu8jjd6sixvNHvZhxaMjgu8EDgW1ISBY/VNGDgsuDBwmHBh4FgElAVudGjghcCRM3sDp/uEpbjfjcDo2MALgSNpCgMnAJcFjqQpDBxJUxg4kqYwcCTNT/ThR8CRNGWDj9FxpBcCR9IUBo6kKQwcSVMYOAG4LHAkTWHgSJrCwJE0hYEjaQoDR9KUBY6hvNLAEXyEgSP4CAMnAJcFjuAjCtyJDix15Q48PgJ/K8WNU4ofp5QwTiltV8P7GzHVyJTiU1iP9ilyR5e4fjhLvj8C4YN/rzvK1R23z6bPrjBHv8zuuX896PLy4ZP/VnuauPY8ce1l4trrvLU3Dqa7tnY3ce1+4trDxLXTxLVP3FfdxH3VDdxXc7rXXupvTJI5nyjn3MBNuK/QgTt2V6F+4PbeV+jAXqCv0IGNQ1+hA7uMvkLJitCB/UtfoQObnb5CrTgjb8UZeSvOKFhxRsGKMwpWnFGw4owapxZNJNSKMwpWnFGw4oyCFWcUrDgjsuKMyIozIivOiKw4o8bJIBMJteKMyIoziuO2F//wTaB/uEVx+yYwjnt98fVee3jcmPb4RTo9/k3ruJeYJ7VmovXwnPz+DTnuJaaz0HEvMZ2FjmvVnxRaYl4PL/nD3cT7g083undpXA/4iUy427GTmgv6U1TO53C6xj21tVJR0ye6UlHTVLpSGXf570oq464VXknFpFvhqOSBY+KFVMZdsrySik1vy1GBtz2iQqByQAXe9ogKvO0RFQPe9k2oAbv6JlSNA633sy/LXmhRYyo5oWp8IidUjfXjhKpxc5xQsiK0yXPlZd074mbewofS386ePvXs+VPP3tR4i9smdBZauBc15q01xocdO8IS32tp6o0lbUpLSUwtFNL6hqGQ3Xb04Q45ecn+/eAbzvx48GvdbbuzFbobhsJ9MMjXtexEe4LVtb2adK+k7t8rbZuisWcPn3r2w0tdpnUPmRyJ+Q3cu/d4f6e8DUnIMT3+hre/k/6Lv5Of/jv+eCukXFZmZQmMek/rG8/5/HCxL/7g6BRo/XSlkOL5pyu5uH66bj+Gbz9d/niXoIdvYIl55apbX7gP21vlw0YSt7ZT759FX482t6pxY15j5e7VuR29NbTFP5z6XSWZUBlNqEwmVGYTKosJldWCyuMNmNSpdCZUehMqTXgfZ8L7OBPex7V6H7eQ337BQzXHOn9nPExpva0+lfAhvLwVnWcsusxYdJ2waM/1mpiHTc/H24aUvP6G8sBwtNqb9o2Iy7q0Ex9u0f5Pq2rb17C3HytTdfXrmVMNeV91yxpc3PYGjuzWwOSWtSGQC8wu38Wnteri6wHrMPL7pK5C0y127munkWsv/rT2OHHtaeDab5/jrfaH75u22ke+LnK1l4lrr/PWfvy0/iS1u4lr9xPXPnJf5Wofua9ytY/cV7naJ+6rNHFfpYn7Kk3cV+PIfdVtt5XcameiYaWtjkp12QsduQn/Z6FvtY/chLnahw63TO0jN2Gu9jzywtn5okIsI9d+HsxjHbh2phmkZeLa3cS1j7zIzdUeJq6dJq49Tlx7mrj2kfsqV/vIfZWrfeK+mifuq3nivpon7qt55L7aM5jnkZswE7LyyE2Yq33kJszVPnS4Pa+9DP08yHkwP37edpTaz4P58SO0g9TONIPjp2InqZ0mrj1OXHuauPY8ce1l4trrvLXXkfsqV/vIfZWrfeK+Wifuq3Xivlon7qt15L7aM5jXkZswE7LqyE2Yq33kJnxeexh7swOmdpMbSZ5up3/7XRaZ1LJtrbMsB1BM7nrNQTG56TUHxeae1+fTKIKzuec1R8XmntccFcxzOaJic89rjgqBygEVm3tec1Rs7nnNUbE5z2Wh+7lj2FOxOc+Fo2LU255T8Ua9LUPFqLdlqBj1tgwVo96WoULm/coRFXjbAxfn4W2PqBj1tgwVo96WoYJ12wMqAeu2R1SwbntEBeu2R1SwbntEhUDlgAq87REVeNsjKnBxR1Tg4g6oEFzcERW4uCMqA3fmtMlc/KPOG5W32gfun2ztA3c5tvaB11nY2gfuo2ztA3c7rvY4cE9iax+4c7C1D5zS2doHztJs7RP31ThxX40T99U4cV+NE/fVOHFfTQP31XhPHj59rP3g+JzXERoul8fpu8u70oG78HNK/X2arn+YLLJGsjRwy+4rdOD+3lcoWRE6sHN4UiilTWiqe6EDt7vnhFLZLrtUDl7RgXtjV6FZTSPlhKrpo2nZLkYpuL1QNX2UE6qmj3JC1fRRTqiaPsoJHTiu9xU6cLbvK1SNM+KEqnFGjNCixhlxQq04o6LHGd0PT3n/9EDR44wYoWRFqB5nxAjV44wYoXqc0bnQqqa9hO3sjtyHFYb9wee7T1U1161nmHA3ZVU1F7muVNRcEZ+i4pbt5kBH+5Xoquby2ZWKmhTalYqayNqRCi1q8m1XKibdCktFTXLuSkVNzO5KhUDlgIpNb8tRgbc9ogJve0QF3vaICrztAZWRN+K9kAq87REVeNsjKmq8LfmyUSG3F0pWhKpxoJxQNaaSE6rGJ3JC9dx2zAjVc9vxudCRd5PtedsxjbxBbF+hamwUJ5SmFPpW+5we4K32Odv6W+1zdurX2kfeHPGi+zdo5K0RP4/J+UwoGnm3u+ugmFz356DYXPY/v9GHgs1lf46KzWV/jorNZX+Gysg7AF5IxeayP0fF5rI/R8XmLS0cFbJJ5XRyC428D+WFVIx6W4aKUW/LUDHqbRkqRr3tOZWRdxK9kAq87REVeNsDFzfyvqoXUiFQOaCCRxGPqGDd9ogK1m2PqGDd9ogK1m0PqOjZzbcrFXjbIyrwtkdU4G2PqMDFHVGBizuiAhd3RAUu7oBK417C9x3/U/WMTipuvZGair8v9dT6Xoofp5QwTik0TilRsJQlbKWE+FjK/uDqfX0/uPq87OtOk9adJ627TFp3nbPuxu1dr6vbjVD3Wyl+nFLCOKVI9p5EWynZ7UuJ45SSxilFskPE+3slhfNPfsrrTdOp7r/TK2XKquuYVQfn11MHR4+nLm+F12XWwt2shftZCw+zFk6zFh5nLTzNWvigPZMvfNC2yRc+aeeMy6SdMy6Tds64TNo54zJp54zLEJ3zrZQheuFbKUN0t7dShuhXf/zt9qf//f6fX7//848//HL7Oy//8V8//eXXrz//9P7HX//vH2//5Xbw/wM=","brillig_names":["constructor"],"assert_messages":{"1341":"attempt to add with overflow","1012":"attempt to add with overflow","482":"Array index out of bounds","1439":"Array index out of bounds","787":"Index out of bounds","592":"Array index out of bounds","1427":"attempt to add with overflow","964":"Array index out of bounds","580":"attempt to add with overflow","641":"Array index out of bounds","1269":"Array index out of bounds","1074":"Array index out of bounds","751":"Array index out of bounds","1001":"Array index out of bounds","1385":"attempt to add with overflow","1507":"attempt to add with overflow","160":"attempt to add with overflow","1312":"Array index out of bounds","739":"attempt to add with overflow","983":"Array index out of bounds","1300":"attempt to add with overflow","977":"attempt to add with overflow","142":"Array index out of bounds","800":"Array index out of bounds","538":"attempt to add with overflow","697":"attempt to add with overflow","374":"Array index out of bounds","1197":"invalid admin","813":"attempt to add with overflow","1447":"Array index out of bounds","228":"Args length exceeds maximum","490":"Array index out of bounds","1246":"Array index out of bounds","1374":"Array index out of bounds","600":"Array index out of bounds","149":"Array index out of bounds","527":"Array index out of bounds","1356":"Array index out of bounds","649":"Array index out of bounds","1277":"attempt to add with overflow","1082":"Array index out of bounds","509":"Array index out of bounds","948":"Array index out of bounds","503":"attempt to add with overflow","759":"Array index out of bounds","107":"attempt to add with overflow","936":"attempt to add with overflow","1320":"Array index out of bounds","686":"Array index out of bounds","668":"Array index out of bounds","662":"attempt to add with overflow","138":"attempt to add with overflow","1095":"attempt to add with overflow","1455":"Array index out of bounds","1193":"Initializer address is not the contract deployer","1254":"attempt to add with overflow","1187":"Initialization hash does not match","608":"Array index out of bounds","474":"Array index out of bounds","1474":"attempt to add with overflow","767":"Array index out of bounds","956":"Array index out of bounds","633":"Array index out of bounds","1468":"attempt to add with overflow","1328":"Array index out of bounds","621":"attempt to add with overflow","1066":"Array index out of bounds","1054":"attempt to add with overflow","792":"Array index out of bounds","780":"attempt to add with overflow","1292":"Array index out of bounds","902":"Array index out of bounds","1219":"Storage slot 0 not allowed. Storage slots must start from 1."}},{"name":"in_group","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"group_member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zVSTW9UMQwcx/lwEsoJqT0Ad8RC317eAyFOLN0TQj1X6qGq1HvVX9lf1XGyu5K9sZ3MjO23QCXsoXYEFqhmOpQv4K/QMmB/PiHbwQ63jO0wDYEmG4vQzTOR/i/Sd6YvNhDv5savu5PPA214+31GNlpdIGINUq18Az6gHMVliFSGl4gzzKG6NFuBSGg+XUTFjzEwaWUNlZBaAk+pLOOKFxuPof+LJzqnbbROSKSGXFIkGSoVxNpJ+RV9UqrUM1vFQGFYPeyD3I/Vk72RklYjheQdfjRotkSsI9IOv1aJUxon6YVVUvyIHMvteRDlPE2mi9FZHLV4slFbEb1TvSZe4p2s3E3R+tNvUgzUNbd35GjeyP/ZCDeRTLleBIu+m3uuKeGknr5nalefkyQXmPQ9vTrE3YSYram3tomp5c7lZuL5xh6s7PBITDU2+7L5oJOQDkbp+3GoF3xQLVq7BJdtzT8n/o3PqU2bTRLw2Rqfmz/opOtmHqYRBjPrHlay1x2e9qJEdOLrDVevV69vJf7ewc0CAAA=","debug_symbols":"5ZvdbuIwEIXfJddceDz+GfMqq1UFLVSRUKiArrRCefc6lDghiZxWlMoj34ADh8l3LDMzDuRcvGzW769PZbXdH4vln3Ox2z+vTuW+8kfnelGsD+VuV74+9V8uRPMAeNEf31ZVc3g8rQ6nYikWxaZ68c/+s9tytymW1tSLkcyhvQqdtkEKzXikVVK0Uf3QBbVzE2LjJFzFxp+kL/67KEDdwQwC1FUJAtUvUut7ZtpiO9NubqZBkmsdotJxZgLdikkKOWQ2P8LsJ/oWugltHxeaHhfaPSy0FF8O3ajhW2r5LfVkTgCJ7eoGqfWMVQiZwfScWpxar7oFAUdBK5vxOK5WIqQc130fEXBaHSa8t7blZW1LlYVLnYVLk4VLm4VLysKly8EliixcQhYuZRYus+h9UGXhMoveB7PoffD+3geEkuEEPZppn1/c0xlj2i0/YReS5AWaOEI7htBKcIQGjtCSI/R8VbdqDtroDlrcnGGs9tmuVRsBpo5eg9NWt/nXD6m+vQanFGN2zZjdMGa3jNmJMbvjy64FY3ZgzC4ZszOuqzrx/E4qsJMesqedZyj8aOqHZsBufj/PkAjsCDPs2P4cqlW3YlDABR34oku+6MgEXZsRuuaLbtii28S7gVhmt2l3AxT+8aNJDf/hYtPuBkjKCLtKvKK6jp3iYofdVVe0ODSa9pY82jrYtFu2OHvaW/I4e9pb8jg741aZ0t6Sx9nTLsJx9sSLcJQ98SIcZU+9CMfYGddVYlxXiXFdJcZ1lRjXVce4rjq2dbX2R/9Wh3K13m2u96Vs36vn3m0qp/9vn+948Qc=","brillig_names":["in_group"],"assert_messages":{"78":"Array index out of bounds","90":"attempt to add with overflow","42":"Storage slot 0 not allowed. Storage slots must start from 1.","22":"Function in_group can only be called statically","19":"Not initialized"}},{"name":"remove_from_group","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"approve","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/21Uu4oVQRCtflf39MwNNVjFUOHq3k1mcMFE1zUyEEEQf8DADxAE9QcMxdBc8AcMxWjBXDAQwVz8A8/pviMbeKH7dld31TlVdXp24ow9Eqf3RHbifMIkek3wU4yEvzuXJOqJnjyg7aQPsRiGB6d62g5O++gHC7zELbzqMd+VsPA03sDhhrcI1wBNnhuSkyyzdUqTW00OJt9MfjV5OBnxq/3c1Z1EcQxxuZFvc761JpIxClxNLmJK1usiV8HCdBJlbjecFG6tYlu4VdkZnGJZaNQB8TFKZpXgVNJW5iIulcZmQNQvols5nk1G6VyyFXMt42zGfIVcUpGYU8XF21I7fLQsuqsrh9pAucwWxjrONo3YjRarMDb7SJrTfS+NKFxEcCATolewEZN8AMZDCcQ4kBhRwQJmj8BWS8bZR8lbeYzFE4lbeUX+aa1mamWIcxOAQ2HJqCcEYwwoA0ZCSQqCPEXMXJBE9BHx3gmq8mw22h0C5lD8bLweiNcAMiFhlVAyb5KFLYWJew/n5+L3jEPq0V+06GzYa5b2Jbge4jiDaIwaSPS8OkCUS6XRQw/JNZ1UBHEs+5te9nalNSe72Th/TBPLSbp5ACGXAwm97YRmCeTCrAgeCB78zX9eBIkEiQ5O78XRaUH91OF1iVVP7X/HMwh0cN46zLiOlsYGmQiZ2LUPvWvU+CyJBQakQhCxZkrFhlUq4ZxUYAwQiKc0zAgqOk4I9kmmfb7ZTpgnpRhDyzf0F+605ash4f5nSft8qRboGF2LqaK5BgqLY51a0hNVtyKlcQPPr7LZJ63/Sbph2w3mTQLNSh2noQI3VTb3W3+Ns53wRah8V4tRp3EAsYhQ5PZDYf+JcOC6lT8L33YwQBJFTY/aIo9wyOq1XBCjRQs/UvhrH6nSR/9IIeBvLXBXOgyAG1S5DW1rVXXgNgMdTfh1ZBwiEvhwkYtnF8/+AsVhOFw8BQAA","debug_symbols":"5Z3bbtswDIbfxde9EEmd2FcZhiHd2iFAkA49DBiKvvuUNpbdxJWiNE1J+KZ1Wsr5ZCr+RVJWnrpf11ePv38s1ze3993lt6dudftz8bC8XadXT88X3dXdcrVa/v4x/nNnNj/Avdjf/1msNy/vHxZ3D92lueiu17/S79T2Zrm67i6Df/5+0YFvsg5N1rHJmlus0TRZQ5M1NllTk7Vtsm7yJTb5Ept8iU2+xCZfUpMvqcmX1ORLOtyXF3tmTGFryC5kU9gc79laNP1Z0yFna+YJY88IW2Of3mRsvGG2H2AGA3ZrCYbsGandR650oP5Kc+1KA0bue0jWlZkjuN44osFdZn8S5nSh30JvTh0+79Tx807Nn3ZqO3lPQAh+2wiBbW1se5ffgQcaiDhh7Zh7a2/Al8eJC67/rKfDuDNOLChmR8XspJjdKmZ3itm9YvagmD0qZme97E6xrjrh98hoM3t0u+yyx3vME/t06HfZzz/eo8nsBGX2dL48wQczjBkybgPvjWZ40Aw/PZUcYkhEiGV4S74PEiyFCk4wAbfGwcTdgNNXJ4cJ5/ltOsDbI9q4I9pMT0LQudwmcCWagpx88KNgKtCU31zvAeDBAbg53j+vsyZnNXiAIKBp6zzWRuEzvnogzKKXcRa95Dn0MphZ9BJm0UucRS9pFr20s+ilm0UvZzH3CbOY+4RZzH3Cx+c+YCwOQRlX+nlgQcX7PsTwkd7EeQk6Go3QoBEaNULX5w1MFWi0ORuAwb15hwkaGhINxJWyLHFfSbbGjtIM8ILuz45uKaP7CroH17syHdJOUoKnBzhlV2Hq+mnzOyfLxjIqZifF7FYxu1PM7hWzB8XsUTE762VPM1/N8IqVNU3/ZMOXCp2pECQavljpTO92dviWghuFftgARb87E05FONX0oJoe1dCPwqFMT6rprWr6AybFYUz/0sgf0ygc0yge04iPaITv3L6Ic6NRuH3uJAQg5aQMjhaS925EOjv9yfIQgFE2PPefII8m7MGzbPiIBXgyouHRcIaHvYkqgWZ41Awv+25Tgbea4Z1meK8ZPmiGl62wFXjZCluGt5oV1mpWWKtZYa1mhbWyFRZ8HOArzxGzzRxsR5F531PZcvx+T1/gZctxBV62HFfghQe8RXgnvLhRrA842esGYt7FwUW7F6072QsHImIJ3gqvzPAAHyuiQMNyPgp76Swne51BuQblZC80qMDLXmlQgddcunSy1xqU4b3stQYVeNlyXIEXLsdleOFyXIaXLsdFeM0K6zUrrNessF6zwnrNChs0K2w4/+MJpytPH/C04pfCF8vTBzyE+JXw5SxokP1oSAU+aIaPmuFZMfwBD/oJhgfN8KgZXrbCVuBlK2wFXrPCCn/4sgKvWWGjZoWNshX2hOVpli3H5Tojy5bjCrxsOa7ACw94y/DC99QtlqdZ9qa65fI0C99ltFieZtnb6hbh0cjeV/d0tXU0sne3LyYS0cje3r4CL3t/+wq81Qwve4f7CrxsOa7AC5fjMrziTb/RCJfjIjxIl+MivGaFBc0KC5oVFjQrLGhWWFCrsM/p1d/F3XJxtbrefrPkzeP65+iLJh/+/Xn9TzL+Dw==","brillig_names":["remove_from_group"],"assert_messages":{"39":"Not initialized","119":"attempt to subtract with overflow","65":"caller is not admin","148":"attempt to add with overflow","158":"Array index out of bounds","193":"attempt to add with overflow","215":"attempt to add with overflow","82":"Storage slot 0 not allowed. Storage slots must start from 1.","140":"Array index out of bounds","169":"attempt to add with overflow","185":"Array index out of bounds","204":"Array index out of bounds"}},{"name":"set_balance","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["set_balance"],"assert_messages":{"509":"Array index out of bounds","375":"Storage slot 0 not allowed. Storage slots must start from 1.","116":"Debtor is not in group","308":"attempt to subtract with overflow","494":"attempt to add with overflow","555":"Array index out of bounds","674":"attempt to add with overflow","607":"attempt to add with overflow","540":"attempt to add with overflow","89":"Storage slot 0 not allowed. Storage slots must start from 1.","278":"Storage slot 0 not allowed. Storage slots must start from 1.","397":"Storage slot 0 not allowed. Storage slots must start from 1.","586":"attempt to add with overflow","653":"attempt to add with overflow","324":"Storage slot 0 not allowed. Storage slots must start from 1.","443":"Storage slot 0 not allowed. Storage slots must start from 1.","696":"attempt to add with overflow","629":"attempt to add with overflow","44":"Storage slot 0 not allowed. Storage slots must start from 1.","422":"Storage slot 0 not allowed. Storage slots must start from 1.","227":"Storage slot 0 not allowed. Storage slots must start from 1.","486":"Array index out of bounds","157":"Storage slot 0 not allowed. Storage slots must start from 1.","346":"Storage slot 0 not allowed. Storage slots must start from 1.","471":"attempt to add with overflow","20":"Not initialized","532":"Array index out of bounds","596":"Array index out of bounds","663":"Array index out of bounds","718":"attempt to add with overflow","517":"attempt to add with overflow","194":"Storage slot 0 not allowed. Storage slots must start from 1.","578":"Array index out of bounds","645":"Array index out of bounds","563":"attempt to add with overflow","685":"Array index out of bounds","618":"Array index out of bounds","359":"attempt to subtract with overflow","24":"cannot adjust someone elses balances","463":"Array index out of bounds","73":"Creditor is not in group","707":"Array index out of bounds"}}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"group_members","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"group_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"member_count","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"approve","type":{"kind":"boolean"}}],"kind":"struct","path":"PublicGroups::remove_from_group_parameters"}}],"kind":"struct","path":"PublicGroups::remove_from_group_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"PublicGroups::constructor_parameters"}}],"kind":"struct","path":"PublicGroups::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"PublicGroups::make_payment_parameters"}}],"kind":"struct","path":"PublicGroups::make_payment_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"PublicGroups::set_balance_parameters"}}],"kind":"struct","path":"PublicGroups::set_balance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"PublicGroups::balance_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"PublicGroups::balance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"approve","type":{"kind":"boolean"}}],"kind":"struct","path":"PublicGroups::add_to_group_parameters"}}],"kind":"struct","path":"PublicGroups::add_to_group_abi"},{"fields":[{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"PublicGroups::admin_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"group_member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"PublicGroups::in_group_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"PublicGroups::in_group_abi"},{"fields":[{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"PublicGroups::member_count_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"debtors","type":{"kind":"array","length":10,"type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}}},{"name":"participants","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"PublicGroups::split_group_balance_parameters"}}],"kind":"struct","path":"PublicGroups::split_group_balance_abi"}]}},"file_map":{"127":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"140":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"157":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"158":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    point::Point, traits::Hash, hash::{sha256_to_field, poseidon2_hash_with_separator}\n};\nuse crate::oracle::logs_traits::ToBytesForUnencryptedLog;\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (n as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        poseidon2_hash_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x1cce4dbf69f14c44865919991ee1057922e34d7310ba237d71759aa422621ca9);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"164":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{\n    header::Header, address::AztecAddress, constants::CANONICAL_KEY_REGISTRY_ADDRESS,\n    storage::map::derive_storage_slot_in_map\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys, constants::NULLIFIER_INDEX},\n    state_vars::{public_mutable::PublicMutable, map::Map}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n"},"173":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n\n"},"182":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"223":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n\n"},"232":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"29":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n"},"295":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"297":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"298":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"300":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"301":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"304":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"305":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"313":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"345":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    protocol_types::{\n    traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    point::{Point, POINT_LENGTH}\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul};\nuse std::hash::from_field_unsafe;\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.value);\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> ValueNoteHidingPoint {\n        ValueNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    /// The following method needed to be implemented because the note is passed as an argument to a contract function\n    /// --> the serialize method is called by aztec-nr when computing an arguments hash.\n    /// Note that when the note is about to be encrypted and emitted as a log the to_be_bytes function auto-implemented\n    /// by aztec macros is called instead.\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n\nstruct ValueNoteHidingPoint {\n  inner: Point\n}\n\nimpl ValueNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_value(&mut self, value: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(value.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for ValueNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n"},"57":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"76":{"path":"/Users/niallcheetham/dev/aztec/publicgroups/PublicGroupsRoot/publicgroups/src/main.nr","source":"// mod test;\n// mod types;\n\n//this will be a little test to make public groups in noir\n\n\ncontract PublicGroups {\n\n    use dep::aztec::{prelude::{Map, PublicMutable, AztecAddress}};\n    use dep::std::hash::pedersen_hash;\n    use dep::std::collections::bounded_vec::BoundedVec;\n    use dep::std::collections::vec::Vec;\n    // use crate::types::bounded_vec_wrapper::AddressVec;\n\n\n\n\n    #[aztec(storage)]\n    struct Storage {\n        admin: PublicMutable<AztecAddress>,\n        group_members: Map<AztecAddress, PublicMutable<bool>>,\n        group_balances: Map<Field, PublicMutable<Field>>,\n        member_count: PublicMutable<u64>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.group_members.at(admin).write(true);\n        storage.member_count.write(1);\n    }\n\n    //helper functions to read variables when testing\n\n    //read the admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    //read the group members\n    #[aztec(public)]\n    #[aztec(view)]\n    fn in_group(group_member: AztecAddress) -> bool {\n        storage.group_members.at(group_member).read()\n    }\n\n\n    //read the member count\n    #[aztec(public)]\n    #[aztec(view)]\n    fn member_count() -> u64 {\n        storage.member_count.read()\n    }\n\n    //read the balance between two addresses\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance(creditor: AztecAddress, debtor: AztecAddress) -> Field {\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        storage.group_balances.at(key).read()\n    }\n\n    //functional methods\n\n     #[aztec(public)]\n    fn add_to_group(member: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        storage.group_members.at(member).write(approve);\n        if (approve) {\n            storage.member_count.write(storage.member_count.read() + 1);\n        }\n    }\n\n     #[aztec(public)]\n    fn remove_from_group(member: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        storage.group_members.at(member).write(approve);\n        if (approve) {\n            storage.member_count.write(storage.member_count.read() - 1);\n        }\n    }\n\n    //this set balances but only between two people\n    #[aztec(public)]\n    fn set_balance(creditor: AztecAddress, debtor: AztecAddress, amount: Field) {\n        assert(creditor == context.msg_sender(), \"cannot adjust someone elses balances\");\n        assert(storage.group_members.at(creditor).read() == true, \"Creditor is not in group\");\n        assert(storage.group_members.at(debtor).read() == true, \"Debtor is not in group\");\n\n        //cant store the addresses in a tuple in storage so hash them together,\n        //easy to know who owes who as hash a,b is different from hash b,a\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance = storage.group_balances.at(pedersen_hash([creditor.to_field(), debtor.to_field()])).read();\n        let amount_to_write = amount + balance;\n        storage.group_balances.at(key).write(amount_to_write);\n\n        //adjust the balances\n        //balance between creditor and debtor\n        let creditor_debtor_hash = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance_creditor_debtor = storage.group_balances.at(creditor_debtor_hash).read() as u64;\n\n        //balance between debtor and creditor\n        let debtor_creditor_hash = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let balance_debtor_creditor = storage.group_balances.at(debtor_creditor_hash).read() as u64;\n\n        //if the balance is greater than 0, then the creditor owes the debtor that amount\n        if (balance_creditor_debtor > balance_debtor_creditor) {\n            let difference = balance_creditor_debtor - balance_debtor_creditor;\n            storage.group_balances.at(creditor_debtor_hash).write(difference.to_field());\n            storage.group_balances.at(debtor_creditor_hash).write(0.to_field());\n        }\n\n        //if the balance is less than 0, then the debtor owes the creditor that amount\n        if (balance_debtor_creditor > balance_creditor_debtor) {\n            let difference = balance_debtor_creditor - balance_creditor_debtor;\n            storage.group_balances.at(debtor_creditor_hash).write(difference.to_field());\n            storage.group_balances.at(creditor_debtor_hash).write(0.to_field());\n        }\n\n        if (balance_creditor_debtor == balance_debtor_creditor) {\n            storage.group_balances.at(creditor_debtor_hash).write(0.to_field());\n            storage.group_balances.at(debtor_creditor_hash).write(0.to_field());\n            //this is not setting them to 0\n        }\n        //if the balance is 0, then the creditor and debtor are even\n        //the values should never go below 0 as as you are subtracting a larger number from a smaller one.\n    }\n\n    #[aztec(public)]\n    fn make_payment(creditor: AztecAddress, debtor: AztecAddress, amount: u64) {\n        assert(storage.group_members.at(creditor).read() == true, \"Creditor is not in group\");\n        assert(storage.group_members.at(debtor).read() == true, \"Debtor is not in group\");\n        //make sure the payment is less than  or equal to the balance\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance = storage.group_balances.at(key).read() as u64;\n        assert(balance >= amount, \"Insufficient balance, or paying more than is owed\");\n\n        //subtract the amount from the creditor\n        let amount_to_write = balance - amount;\n        storage.group_balances.at(key).write(amount_to_write.to_field());\n    }\n\n\n    //same as the above but with a fixed vector of addresses\n    #[aztec(public)]\n    fn split_group_balance(creditor: AztecAddress, debtors: [AztecAddress; 10], participants: u64, amount: u64) {\n        assert(creditor == context.msg_sender(), \"cannot adjust someone else's balances\");\n        assert(storage.group_members.at(creditor).read() == true, \"Must be part of the group\");\n\n        // //calculate the amount per participant\n        let amount_per_participant = amount / (participants as u64 + 1);\n\n        // //update the balances\n        for i in 0..10 {\n            let debtor = debtors[i as u32];\n            if (debtor.is_zero()) {\n                continue;\n            } else {\n                assert(storage.group_members.at(debtor).read() == true, \"Debtor is not part of the group\");\n                let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n                let current_balance = storage.group_balances.at(key).read() as u64;\n                let new_balance = current_balance + amount_per_participant;\n                storage.group_balances.at(key).write(new_balance.to_field());\n            }\n        }\n    }\n}\n\n//can bypass the whole making a bounded vec and just use an array of addresses\n//skip if the address is zero."},"78":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/address-note/src/address_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: Field = 3;\n// ADDRESS_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[aztec(note)]\nstruct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"},"84":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"99":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\nuse crate::hash::ArgsHasher;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    args_hash: Option<Field>\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs, args_hash: Option::none() }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            let mut hasher = ArgsHasher::new();\n\n            // TODO: this should be replaced with the compile-time calldata size.\n            for i in 0..self.inputs.calldata_length as u32 {\n                let argn: [Field; 1] = calldata_copy((2 + i) as u32, 1);\n                hasher.add(argn[0]);\n            }\n\n            self.args_hash = Option::some(hasher.hash());\n        }\n\n        self.args_hash.unwrap()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"}}}