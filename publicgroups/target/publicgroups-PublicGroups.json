{"transpiled":true,"noir_version":"0.33.0+cb20e078dd909656110d133339b2b425e6c3ebb0","name":"PublicGroups","functions":[{"name":"add_to_group","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"approve","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/21Uu4oVQRCtflf39MwNNVjFUOHq3k1mcMFE1zUyEEEQf8DADxAE9QcMxdBc8AcMxWjBXDAQwVz8A8/pviMbeKH7dld11TlVfXp24ow9Eqf3RHbifMIkek3wU4yEvzuXJOqJnjyg7aQPsRiGjlM9bY7TPrpjQZS4hUc95rsSFnrjDTg3PEW4Bmjy3JCcZJmtU5rcanIw+Wbyq8kjyIhf7eeO7iSKY4rLjXyb8621kIxREGpyEVOyXhe5ChamkyhzO+GkcGsV28Ktys7Ai2WhUQfkxyiZXUJQSVuZi7hUGpsBWb+IbuV4Nhmtc8lWzLWMsxnzFXJJRWJOFQdvS+3w0bLprq4cagPlMlsY6zjbNGI3WqzC2OwjaU73vTSiCBGBQyZkr2AjJvkAjIcSiHEgMaKDBcwega2WDN9HyVt5jMUTiVt5Rf5p7WZqbYhzE4BDY8moFwRjDGgDRkJLCpI8Rc5cUET0EfneCbrybDbaAwLmUPxsvB6I1wAyIWGV0DLPpF5TmOjxCH4ufs84pJ79RcvOC3vN1r4E10O4M4jGqIFEz6sDRLlUGj30kFzTSUUSx7a/6W1vR9rlZDcb549pYjtJNw8g5HIj9LYTmiWQC6sieCB48Df/RREkEiQ6BL0Xx6AF/VOH1yVWPbX/Hc8gMMB56zDjOK40NshEyMRb+9BvjRqfJbHBgFQIItZMqdiwSiWckwqMAQLxlIYZQUXHCck+ybSvN9sJ86QUY2j1hv7CnbZ6NSSc/yxpXy/VAh3j1mKquFwDhcWxTq3oiapbkdK4QeRX2eyL1v8U3bDtBvMmgWaljtNQgZsqL/dbf42znfBFqHxXi1GncQCxiFTk9kNh/4l04LqVPwvfdjBAEkVPj9oijwjI6rVcEKNFCz9S+GsfqdJH/0gh4W8tCFcGDIAbVLkNbWtVdeA2Ax2X8OvIOGQk8OEiF88unv0FlmUPcDwFAAA=","debug_symbols":"5Z3hTtswEMffJZ/54Dvb5zteZZqmssFUqSoTsEkT4t2Xdo0T2mA3pZQ75QukcHZ+Fzv523eO+9z8uL35/fPbcn13/9hcf3luVvffF0/L+3X76fnlqrl5WK5Wy5/fhn9u3OYHxK3946/FevPx8Wnx8NRcu6vmdv2j/d2WvVuubpvrFF6+XjVAk6zTJGueZC1TrNFNsoZJ1jjJ2k+yDpOsJ7UlTmpLnNSWOKktcVJb+klt6Se1pZ/Ulv74trw6MBOfdoYSUzaFGEdsA7qu1vZQsrWkEWMShJ0xtScZGm+YwzuYwUHYWYLz4YLU8T1XOvnuSkvtSgOydB76EMvMDLEzZnS4z0xnYW4v9GvoTdXp46rmj6taPqzqMPpMAKJciBhqfZtiPoP0NMBuxDqKdNbkgMr9JKbY3evtIe/1kwCG2dEwuzfMHgyzR8PsZJg9GWZnw+xilz0a1tWo/BnJIbNz3GfX3d85D+zbQ9pnv3x/Z5fZPZTZ2/ryAB9c32e88xt4cpbhwTL8G0NJ7m5xSC6W4YPPngafKjjJJdwZJ8f7E06qDg7TwIX/4QAKJ5SJJ5QZH4SkgLkMUWU2BTn4QIPJ1OaaHVYcuzYG6VFQaKzeGFyOakg/5fcA49a5rw2mzyhbL9MsvORZeClz8DK5WXgJs/ASZ+Gln4WXYRZexll4OYuxT5rF2CfNYuyT3j/2AdcbuwHNuJ9HJlSIqJu6sX81z2uh2VmEBovQaBG6Pm7gWioZQ44GYIqvzjBC4/tAg5dKWtZLl0kOLgzuxu3tyHRx9OAzOlXQCWLH0R76vaCEjHdwjjlYwInPG985WzRW0DC7N8weDLNHw+xkmD0ZZmfD7GKXvR35WoY3rKzt8E83fCnR2SaCVMMXM53t2S4OPyXh5lPOnXmm/ZFwm4QzTQ+m6dEMvfhDem+aPpimrw+KOQzpt4XolELplEJ8SiE5oRC+8fhCyoUifloQAtDniAIOFpJ3zYj+4vRni0MAsm546e4gQpcO4EU3PGMB3jvV8Ogkw8PBQNWDZXi0DK/7aVOBD5bho2V4sgyfLMPrVtgKvG6FLcMHywobLCtssKywwbLCBt0KC8Q9fOU9YgmZQ8JgZt55qluO3/Z0C69bjivwuuW4Aq98wluEj8qTG8X8QNS9boDzLg6Rw8FsPepeOMCIJfigPDMjPTxXRMH3y/l8OghnRd3rDMo5qKh7oUEFXvdKgwq85dRl1L3WoAxPutcaVOB1y3EFXrkcl+GVy3EZXrscF+EtKyxZVliyrLBkWWHJssImywqbLv96wvnS00e8rfip8MX09BEvIX4mfDkKmnS/GlKBT5bh2TK8GIY/4kU/xfBgGR4tw+tW2Aq8boWtwFtWWOUvX1bgLSssW1ZY1q2wZ0xPi245LucZRbccV+B1y3EFXvmEtwyvfE/dYnpadG+qW05Pi/JdRovpadG9rW4RHp3ufXXPl1tHp3t3+2IgEZ3u7e0r8Lr3t6/AB8vwune4r8DrluMKvHI5LsMb3vQbnXI5LsKDdjkuwltWWLCssGBZYcGywoJlhQWzCvvSfvqzeFgubla3u2+WvPu9/j74osmnv7/+/6c1/gc=","brillig_names":["add_to_group"],"assert_messages":{"39":"Not initialized","119":"attempt to add with overflow","65":"caller is not admin","148":"attempt to add with overflow","158":"Array index out of bounds","193":"attempt to add with overflow","215":"attempt to add with overflow","82":"Storage slot 0 not allowed. Storage slots must start from 1.","140":"Array index out of bounds","169":"attempt to add with overflow","185":"Array index out of bounds","204":"Array index out of bounds"}},{"name":"remove_from_group","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"approve","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/21Uu4oVQRCtflf39MwNNVjFUOHq3k1mcMFE1zUyEEEQf8DADxAE9QcMxdBc8AcMxWjBXDAQwVz8A8/pviMbeKH7dld31TlVdXp24ow9Eqf3RHbifMIkek3wU4yEvzuXJOqJnjyg7aQPsRiGB6d62g5O++gHC7zELbzqMd+VsPA03sDhhrcI1wBNnhuSkyyzdUqTW00OJt9MfjV5OBnxq/3c1Z1EcQxxuZFvc761JpIxClxNLmJK1usiV8HCdBJlbjecFG6tYlu4VdkZnGJZaNQB8TFKZpXgVNJW5iIulcZmQNQvols5nk1G6VyyFXMt42zGfIVcUpGYU8XF21I7fLQsuqsrh9pAucwWxjrONo3YjRarMDb7SJrTfS+NKFxEcCATolewEZN8AMZDCcQ4kBhRwQJmj8BWS8bZR8lbeYzFE4lbeUX+aa1mamWIcxOAQ2HJqCcEYwwoA0ZCSQqCPEXMXJBE9BHx3gmq8mw22h0C5lD8bLweiNcAMiFhlVAyb5KFLYWJew/n5+L3jEPq0V+06GzYa5b2Jbge4jiDaIwaSPS8OkCUS6XRQw/JNZ1UBHEs+5te9nalNSe72Th/TBPLSbp5ACGXAwm97YRmCeTCrAgeCB78zX9eBIkEiQ5O78XRaUH91OF1iVVP7X/HMwh0cN46zLiOlsYGmQiZ2LUPvWvU+CyJBQakQhCxZkrFhlUq4ZxUYAwQiKc0zAgqOk4I9kmmfb7ZTpgnpRhDyzf0F+605ash4f5nSft8qRboGF2LqaK5BgqLY51a0hNVtyKlcQPPr7LZJ63/Sbph2w3mTQLNSh2noQI3VTb3W3+Ns53wRah8V4tRp3EAsYhQ5PZDYf+JcOC6lT8L33YwQBJFTY/aIo9wyOq1XBCjRQs/UvhrH6nSR/9IIeBvLXBXOgyAG1S5DW1rVXXgNgMdTfh1ZBwiEvhwkYtnF8/+AsVhOFw8BQAA","debug_symbols":"5Z1tT9swEMe/S17zwnc+PxxfZZqmssFUqSoTsEkT4rvP7RontMGuSyl3yhtI4ez8HDv5n+8c97n7cXvz++e35fru/rG7/vLcre6/L56W9+v06fnlqrt5WK5Wy5/fxn/uzOYHuK3946/FevPx8Wnx8NRdm6vudv0j/U5l75ar2+460MvXqw58k3Voso5N1txijabJGpqsscnaNllTk3VTX2JTX2JTX2JTX2JTX9qmvrRNfWmb+tIe35dXB2Zsw86QXcim4NyELaHpa02HnK05TBh7RtgZ+3SSsfGGmd7BDAZoZwnG0gWp3XuudLD9lebalQaM3LfQkiszR3C9cUSD+8z+LMzpQr+G3lQdPq7q+HFV84dVTZPPhDT+3K5Q6h5bG9ve5TPwQAPRTFg75t7aG/DlceKC6+/1dBj3xgmBYnZUzG4Vs5NidqeY3StmD4rZo2J21svuFOuqE/6MjJTZo9tnlz3eY3bs06HfZ7/8eI8ms1sos6f6soMPZhgz1tgNvDea4UEz/BuuJHKGp1CGJ+v7SQLZUMEJJuDOOJi4P+H0defQ7YcDPJ1Qxp1Q5g0nJD9QcHx5p2dTkIMPfjSZ2lyzw35zfR8DD9Ui+6l6HZkc1eBhym8Bpq3zWBtNn5G3rQyzaGWcRSt5Dq0MZhathFm0EmfRSjuLVtIsWulm0cpZ+D5hFr5PmIXvE97v+4AhHCZlXGnnkQkV730/dYv21TwvQUejERo0QqNG6LrfgFiBRsrRAAzu1RkmaOwQaLBcScta7jPJZGh0N25vx+gvjk42o/sKugfXd2U6tHtBCZ4e4JBDd4hYzeB/UjSWUTG7VcxOitmdYnavmD0oZo+K2Vkve/J8NcMrVtbk/smGLyU6k3MrGr6Y6Uxnuzh8S8LNhn7YgI1+3xNOSTjV9KCaHtXQsz2kt6rpSTX9EU6xH9NvC/lTCoVTCsVTCvEJhfCNx5ePeSbP9GlBCECbgzI4WkjedyPai9OfLQ4BGGXDc38HeTThAJ5lw0cswFsjGh4NZ3g4cFQtaIZHzfCynzYVeNIM7zTDe83wQTO8bIWtwMtW2DI8aVZY0qywpFlhSbPCkmyFHTgSfOU9YqbMwTSamfctlS3Hb7d0Cy9bjivwsuW4Ai98wluEd8KTG8X8gJO9biDmXRxcpIPZupO9cCAiluBJeGaGB/hYEQU7LOez4SCc5WSvMyjnoJzshQYVeNkrDSrwmlOXTvZagzK8l73WoAIvW44r8MLluAwvXI7L8NLluAivWWG9ZoX1mhXWa1ZYr1lhg2aFDZd/PeF86ekj3lb8VPhievqIlxA/E74cBQ2yXw2pwAfN8FEzPCuGP+JFP8HwoBkeNcPLVtgKvGyFrcBrVljhL19W4DUrbNSssFG2wp4xPc2y5bicZ2TZclyBly3HFXjhE94yvPA9dYvpaZa9qW45Pc3CdxktpqdZ9ra6RXg0svfVPV9uHY3s3e2LgcSEphle9v72FXjSDC97h/sKvGw5rsALl+MyvOJNv9EIl+MiPEiX4yK8ZoUFzQoLmhUWNCssaFZYUKuwL+nTn8XDcnGzut19s+Td7/X30RdNPv399f8/yfgf","brillig_names":["remove_from_group"],"assert_messages":{"39":"Not initialized","119":"attempt to subtract with overflow","65":"caller is not admin","148":"attempt to add with overflow","158":"Array index out of bounds","193":"attempt to add with overflow","215":"attempt to add with overflow","82":"Storage slot 0 not allowed. Storage slots must start from 1.","140":"Array index out of bounds","169":"attempt to add with overflow","185":"Array index out of bounds","204":"Array index out of bounds"}},{"name":"set_balance","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"5Z3dbhs5EoXfxde5IOuPZF5lsRgkM5mBgSAZJJkFFkHefWXH3ZYtmsxKaquO6mbGTsiu70ghT1Wzyf5+88eH9//89dvtpz8/f715+6/vNx8///7u2+3nT7vfvv94c/P+y+3Hj7d//bb/xzfp7j9Z7tt//fvdp7tfv3579+Xbzdv05ubDpz92/9/1/fP244ebt0V+vDlo1rg8NGxa1qZZtdNWKC1X3f3Y1tatdBpbo/zQ2HZB9hv/+81N1hOYc8ry0DInllektlM+6cLLJ91mn3Sm2haFLDpmrlmXxpUSPWcuZ2HefdBPoe8uXbe7dNvs0pS2u3TuXZqE6kMnErFxAGFbIgiXPP7mSyr00Lik+vxfK1GfJtsjTd2nuevDR/SRI/p0xz9pWvsoz76KvM5ctvdN3H1mh+NJl+83t0cUata7rkpap8T2OF9wzv3W6z+IvbFH7V6lhVBZQqisIVS2CCo5hVCZQ6ikECo5hEoJoTJE7sMhch8OkftwiNyHT899chJaA+zR9HX+Ys1ptgBY5cdL1nQHLQkROiNCEyI0I0ILIvTc1fdu5L0AbfoInZ5EOGy9m+2W1payje8UadFl/t39WH88vVMkBsxegNkrMHvDZdcEzJ6B2QmYnYHZBZgd2FfV+fxeZWWv+ozdfI/Vui7q7n605+yvP1ZrWtl5smqnvCzXquyXt/dFqAkuuuKiGwi62gF6xUVvsOhlnoXpE/S7PnREHz6iT38K2U2qSx+jyccKcLeuaAiVFkJlCaGyhlDZIqisKYTKHEIlhVDJIVRKCJUhcp96eu7z+stAtSBCV0ToBgjd5nkD1/OWvGe7m9kyMDsBszMwuwCzKzC7AbMXYPYKzN5w2XfpIzK88xl+tE64C+wafrhQmNPrzzXnWrPKqQKzN1z2nEDYD5etciZgdgZmn+eSB3tkc7ZjOvVntKprp5Yme5CprtuKqeXnt2Vyf9v3WSO0rSP0N4GfNULePAJtHoE3jyCbR9DNI9jmETYf07T5mH5hZ3HT5W4Zp5xPivDCrt5zRsibR6DNI/DmEWTzCLp5BNs8Qtk8Qt08wuZjWjYf0y/sRWuc1k6Kv5aWX9i9dnUyOYZMiSFTY8i0GDJLDJk1hswWQuYLWwWvTmaMLEhjZEEaIwvS07Og138CKKtCUhskdYGknmUQu6K3zKgvtZatDRjeEjJ8RoYnZHhGhhdkeEWGN2T4ggyP7LDF+Tw/fFqs+J5txk+Lldefbf6PJ1Byk/XSu8Jpr1r6WS4Vg6Yv0PTdCYfTur7OyZ7Q33dq/U5lmR047xXFsGV8fy/t9cnMMWRSDJkcQ6bEkKkxZFoMmSWGzBpDZowsqMXIgtrpWdAF7sg3gqRmSGqBpJ57TuYJNcn60j8q+iREB4dleVGcsem4PLXdyvfSeLc6/Oy+BvU3TzLJMpKZ9j7FI56ypJQ3j0CbR+DNI8jmEXTzCLZ5hLJ5hLp5hLZ1hLz5mM6bj+n+bkXmdasdswl8TkT9jY3XJ1NiyNQYMi2GzBJDZo0hs4WQ2d/dfH0ycwyZMbIgipEF0elZ0Ovf3iBSSGqDpC6Q1PMMouUZ9YUeqSJqwPCckOEzMjwhwzMyvCDDKzK8IcMXZHhkhxXn8/zooWUS37PN8KFlktefbc734CyJQdMXaPrphCPpSc1w36kd0UnTMZ36U4qsQ5mVT1t/6m8XP2sE3jyCbB5BN49gm0com0eom0doW0fob489a4TNx7RtPqb7u0FZyzqZWbqCG5n9faPXJ1NjyLQYMksMmTWGzBZCZkkxZOYYMimGzBhZUImRBZXTs6ALrEkWg6QukNQVknqeQbDbe+o1IcNnZHhChmdkeEGGV2R4Q4YvyPAVGR7ZYZvzeX64at18zzbjVev2+rPNGVdOW4Gmr9D08wlHnq8lc0rHdMrHdOpPKWUVxaXJQaf+UK607i6vxQ462TGdyjGd6jGd+t9TbeuBbi3jH1LOL+zDvTqZOYZMiiGTY8iUGDI1hkyLIbPEkFljyIyRBVGMLIhOz4JefxGEiSCpGZJaIKn7GUR7POqn2ex0s7reacu1pL2RU3+GmM/34vUANX5hF+PjbQ1J6Qqmtxf2O16dTI4hU2LI1BgyLYbMEkNmjSGzhZDZf4v99cmMkQVJjCxITs+CLlCpiEBSKyS1QVLPPYfdFpr9/cKSdeERSnUf/r5T93sSkrx2agfr1P0dsbNO9ZhO7YhO/a2owmmZ0oSp4U/C/f2w1yeTYsjkGDIlhkyNIdNiyCwxZNYYMlsImSVGFlRiZEHl9CzoAvVUYUhqgaRWSOoXMgitK3WZvbp5snpc5vO9zkJcrKivL4z7tsJLvoLprXIMmRJDpsaQaTFklhgyawyZLYTMlmLIzDFkxsiCWowsqJ2eBV2gUmkKSW2Q1AWQWtLcc8RroSmpPyilLopF+fk+XenvCBZdI4nOqneACUv6e5ivT2YLIbO/6/r6ZOYYMimGTI4hU2LI1BgyLYbMGFlQjpEF5dOzoAvUHpQgqTMkNUFSTz3Hpk9kX6w67e8AFmNe4bXizz39d81encz+W2mvT2aOIZNiyOQYMiWGTI0h02LILDFkxsiCOEYWJKdnQRcoIyRDUhMkNUNSzz2nmtdCU7Nv+LbMa0apHMCTb/hKI3h2DU+prfC5HsALMrwiw/uebSbwBRm+IsM3YHhLyPC+HXYC79thJ/DIDmvIDmvIDmvIDmu+HTZbfYRv48ZNVo4me6feLEp92/HLSu/hfdvxGL74tuMJvPOCdwwvvte0h9V6cb4gP6zWi7mGH5tCKcjwFRm+AcPXhAyfkeEJGZ6R4X077ATet8NO4JEdtiI7bEV22IrssM23w56xWm++7XhcdjXfdjyB923HE3jfdjyBn+/qvuj+6GG13qpv+GG13ppr+KEpqPNt9RP4jAxPyPCMDC/I8IoMb8jwvh12Au/bYSfwyA6bkR02IztsRnbY7Nthz1eta/Ztx8OyS7NvO57A+7bjCbzzgncIT/P3B1z02OxRta6UfcOPqnUlcg0/NgViZHhBhldkeEOGL8jwFRne97sdxvDs22En8L4ddgKP7LCM7LCM7LCM7LDs22HPWK2zbzsel13s244n8M5ftTSEF+cF7xh+/kb2i765elit/8KL2S8KP6zWf+H97JeEH5vCL7ym3TF8QYavyPANGF4TMnxGhidkeN8OO4H37bATeGSHVWSHVWSHVWSHVd8Oe8Zq3Xzb8bjsMt92PIH3bccTeOcF7xi+bwq1LfDcxG213j9Sww/8sFrvn5LhBn5sCv1TMkDg+6dkoMBnZHhChmdkeEGGV2R43w47gfftsBN4ZIctyA5bkR22Ijts9e2wZ6zWq287Hpdd1bcdT+B92/EE3nnBO4bvm8LOLBZ44zyBT6YLfNobVX14bW1pbSnbGH5nuMsDCrsf9Tl8/0gNN/CVl1sNu9F5UK33T8nwA080giff8Kuj7eDrxBT48bUnXPhAKTtXmlalyQ7gBRlekeENGb4gw1dkeN92PIS35NyOx/DO7XgM792Oh/DADmsJ2GEtATusJWCHtQTssJaAHdb6R2ow8wrPzWvBa/0jNdzADwte6x+p4Qd+VPBa/5QMP/BnK3itf6SGI6XD0W3I8AUZviLDN2D4/mEmKPC+7XgC79yOx/DO7XgM792Oh/DIDkvIDkvIDkvIDkvIDsvIDts/UoNTWWo1ztnr89jWP1LDD/zoeWzrH6nhBn742I/1j9RAgS/I8BUZvgHD90/JQIHPyPCEDO/bYSfwvh12Ao/ssILssILssILssOLbYc/3PLapbzsePlhr6tuOJ/C+7XgC77zgHcN3TYEarw+Tpzw7qO1iy9P9IzXcwI+Xp/tHaviBHy5P94/U8AN/vuXp/pEajpSO7sX1j9RAgSdkeEaGF2R4RYb3bccTeOd2PIZ3bsdjeO92PIIvyA5bkB22IDtsQXbYguywBdlh+0dq0O66D51otyDmteDtH6nhBn5c8PaP1PADPyx4+0dq+IE/X8HbP3/DkdLR6O4fqYECL8jwigxvyPAFGd63HU/gndvxEL45t+MxvHc7HsIjO2xDdtiG7LAN2WEbssM2YIct/VMySJMt8CrqtOAt/VMy3MAPC97SPyXDD/yo4C39UzL8wJ+t4C1JnCsdjm5Fhjdk+IIMX5HhGzB89m3HE3jndjyGd27HY3jvdjyER3bYjOywGdlhM7LDZmSHzbAO+2P323/efbl99/7jh6+7Pnd/+c+n37/dfv708Ou3//798292jf8H","brillig_names":["set_balance"],"assert_messages":{"509":"Array index out of bounds","375":"Storage slot 0 not allowed. Storage slots must start from 1.","116":"Debtor is not in group","308":"attempt to subtract with overflow","494":"attempt to add with overflow","555":"Array index out of bounds","674":"attempt to add with overflow","607":"attempt to add with overflow","540":"attempt to add with overflow","89":"Storage slot 0 not allowed. Storage slots must start from 1.","278":"Storage slot 0 not allowed. Storage slots must start from 1.","397":"Storage slot 0 not allowed. Storage slots must start from 1.","586":"attempt to add with overflow","653":"attempt to add with overflow","324":"Storage slot 0 not allowed. Storage slots must start from 1.","443":"Storage slot 0 not allowed. Storage slots must start from 1.","696":"attempt to add with overflow","629":"attempt to add with overflow","44":"Storage slot 0 not allowed. Storage slots must start from 1.","422":"Storage slot 0 not allowed. Storage slots must start from 1.","227":"Storage slot 0 not allowed. Storage slots must start from 1.","486":"Array index out of bounds","157":"Storage slot 0 not allowed. Storage slots must start from 1.","346":"Storage slot 0 not allowed. Storage slots must start from 1.","471":"attempt to add with overflow","20":"Not initialized","532":"Array index out of bounds","596":"Array index out of bounds","663":"Array index out of bounds","718":"attempt to add with overflow","517":"attempt to add with overflow","194":"Storage slot 0 not allowed. Storage slots must start from 1.","578":"Array index out of bounds","645":"Array index out of bounds","563":"attempt to add with overflow","685":"Array index out of bounds","618":"Array index out of bounds","359":"attempt to subtract with overflow","24":"cannot adjust someone elses balances","463":"Array index out of bounds","73":"Creditor is not in group","707":"Array index out of bounds"}},{"name":"admin","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zVRy04DMQycxInjpMAFCXoAbkggFbq9ZOHAiW17QEhwRvxwv4rxrljJ3owf44kzQELcQewADJCY6aCP4Ke0DNj7LdQmm76JbVoMkRZGJiGjR9IzA2cjyLQ/eOHeC+5mntmXt3/O4ukBIWhDMC1PwCXKMbiAEIzwCmmBElJnMVmRZnlKmBwqhsAsj8mDWgaGao+19JjML1E7at7gvkFy9SFblA0eejAKkBIpRbTmHrJ1mFfL1pM30Kxkc3JNKq+uW2jJ9egZ6bSR7gXNRfLKxYQbRLR5CUfuI3uDSGz0LSslqTf74FzSBX1yimmh6FEoIbnYMZiYrrhFJZ+r/jCq/iSnGAt+R19eDs5vFLibD/WcDdWStWtutFnzF+NvfrG22PJiJPyxxnbzhhXHrcwc5hlGM1s5rJxeN/jaBSGjD96OWJ/Wpz8zMHHaMAIAAA==","debug_symbols":"1ZpbboMwEEX34u98+DmeyVaqqiJPISES5VGpirL3Oik4lFKnUZrI8wM2XIZjC/uOLQ5iNp/sl29lvVhtxfjlIKrVtNiVqzrUDseRmGzKqiqXb93LQp4OSp/123VRn6rbXbHZibEciXk9C+fw7KKs5mLs7XH0Q0bGN0JyPkqVcwNaq2UbNRQpqskPiIG0asQQXtIVv46EMncwK6lso1TS2CdS23t62pu2p+laTyuN1LbQWJdmRuVaMWqp+8zuX5hDR3+HPoWGx4X2jwuNjwtNfw4d1FrepFY3qQfnBKRWTxKvjTFwsaV0Ca9QDqgdUasGqSD9vTrv2jknFLH3vWrDltyyJXdsyYEtuWdLjmzJiSu5kWzJFVtyth5q2HqoyXpWRBvJ0fXIbc4jFOMSKBShT/7sEYoykhuVJg/x4kJIdTiMNGd0zRfd8EXnO0hzTl0wbsU4tP2tB5tz6oJa/07usp4Yk+Q5py4o6UKOaTEZG5mNN/1m5pznJJ3L5ZznpMktW/Kc9wrS5DnvFaTJczbcNHnWhpskz9pwU+TAdiUCeRtuipythwJbDwW2HgpsPRTYeiiw9VBg6qHHUHsvNmUxqebNTwyLfT3t/NOw+1h/3QniTw==","brillig_names":["admin"],"assert_messages":{"21":"Function admin can only be called statically","18":"Not initialized","55":"Array index out of bounds","67":"attempt to add with overflow"}},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2dCZSlSVWg/1e5Z1V2ZlV112ZW1p9ZmVm5VGW9NRcW6VGkoRtxQRgVRXNtGpuqhq6m7UEdjx7nePQoCqicGRwEgQEEGVGZQbDVGRYVFQcGPKKoR6VdkUUUm22m/qz/5vvyvvvHv7yMl1VN/+dUvZfx7hY3Im7cuHEj/lJw7Tl49V8p/t4Tf/YGrY/A3Bp/ltt7KntIq+xTztINIueBG0TOrhtEzu49lDOSrSvY/ey1vD0e9LrXMvbeADL27XG7i4zd8ff+q/8Grv4bDK7Z3pYfWbEDcceJfo8aOFJgH2CSiP6xUk70PBnfb44/n3Hpuy5dvv9SeOnylc3wygP3bIZPeSJxFtBrT8af/+4FL1h9ILzr0sbmd4eX77sSXt4K1y7fd2njXiIuFkX8yqKIdwBxNP5cvXJl83n3XAmvXA5XNzbC+++68pzw8gs3X7B19+X7ifutRZneXRTx/jakfVUbuG8uKvCvFkX89aKIv9tGNc93F2RaL4r4uKKIT+kuXs1vLsr0uUUR72tD2le2gfsLRQX+5aKI7yiK+NttVPO+noJMv7co4g8VRXxJT/Fqvqoo018uivhgG9L+bRu4nykq8BeKInb3FkQ83Fu8mqeLMp0qinihKOJj2qjmU4oyfVZRxK02pP2JNnBfUVTg1xRFfFNRxLe3Uc3FvoJMv7Io4pOKIj69r3g114oyvVIU8T+2Ie0b2sD91aIC/3pRxHcXRfxAG9X846JMH2qD6d8XZfpwG0y5JM7FdKi/ONPDRZmGbTA9V5RpvQ2my0WZ3tYG06cVZfqsNph+R1Gml9pg+h+KMv2Boog/UhTxZ9qo5uuKMv2fRRH/dxvSfrwN3IeLClwaKIg4UBTx2EDxak4UZTpXFLFaFPEJbVTzaUWZfmdRxO9qQ9qfagP3VUUFfkNRxF8qivhgG9V8d1GmH2iD6YeLMv1YG0z/sSjTh9tg+sWiTA8NFmd6dLAg07ANppNFmdbaYPqYokxva4PpHUWZfmsbTFeLMn1OUcR725D214D72Pjz6Vcuv2D1zs3w3rsvXwmfd9+9V8K1q39sRh9bl1+wGa5fft49912569Kd1/bWnnPXRvT9nst3XbpC0p846I30hw8VVNWfFUV8qCjiPwMxb+McGCrI9OaiiGeGikv7lDZwn1FU4G8virhZFPEFbVTz/xZl+qdFEf+6KOKn2qhmcFNBpkeKIp6+qbi0t7WB+/SiAj+rKOJ6UcR72qjm6eGCTKeKIl4oiviY4eLVfEpRps8qirjVhrQ/0QbuK4oK/JqiiG8qivj2Nqr57qJMf78o4oeKIv5lG9X8VFGmXSMFEW8aKS7tchu4Tywq8FOLIn5TUcTVNqr550WZ/k1RxE8URfxCG9U8eLgg09NFEWcOF5f2G9vAfXZRgbeKIl4qiviiNqr5A0WZvrgNpi8tyvTVbTD9xaJM31YU8cGiiO9ro5ofKcr0H4sifrYNacePFMe9cKSgwI2iiI8vinh7G9V8ZlGmzy6KuFUU8d42qvkDRZm+rCjiK9uQ9nfawP1QUYE/WhTxY0URP91GNR8uyrT3aHGmg0cLMj3ZBtOwKNNzRRGrOaXdOXpxR4wYbZ0ciMui3/bwfFEF2zJ7S3u5vjUQy+5B7mU5suKBdjnKOfrq/qbuA/CKThZIAot8luJ/Q0HzrJbgDwXNozZPRJnk6H4NyiQb8Ukok/yn2yBPv5/2WvbYXrWI7kE/tOtDaJ8APPggs35HjsHAWx/aPvt5UPEXXjKWt/tL3Jj9KOvu3y3ndn9R/TH6M8Tv/aiT/D6v6kZZupQsEd0eH7pYrq9FtHt90I7bXnTYbeiwx9Bhr6HDyNTeoehEcvf1e5F7+3xfP2TsBi+R8wBg+iFHD/6eC5rlA8gw6oZehG4UxuqVftSfjNet8EYA0wu8PoXXB7m3Ya/+G4+/HwyaxwzluTX+LBd8FperS2vVWlnob+suaLav8NprvvGzbdMO7T3d7Tl5aO/p1iO6N7VPt6YLIroSIpW5cI9k3qY9Yslcr1SrtUp9aW1xubzcKG+sL1c3l1cbjdWVRnWjvrFVLVcbi1ub5cZKbWOlvnK1uF5ZXy2Xt8qra1uVRkT3MGTes7FduSbzER+0y+XtXLejfmhv97ubLV239dS2dX2Ln/6xLfMxS+bV5fWl6uZieaN89b+txsZyud6or2zUl7dq5Xp9o7xYqZfXVpY3N5YqS6sra41adXVrsVZerzRq5aWVbbrH/eh5226cCPZaz9f63cn8dCtZ6J7yoovKNu2v8KPnbXs3utd6jsf3aT8yl6P5S+ay++NJK5rPvioui3iP7WGdlir16lUruhTROBPT4hw6hjL5/ZuDplxPgh5kvHTHf8uccAtoCMxT4k/EHXYePZ/soX4bQ5AnAA8+9JVFjsFgtw3b67XCsOIvvLhWOK5kGkHZCch2XNE6rmhdD3hRfaSfS12j/jQfL3ijPnAGPPZS3xFvjiHhEah6yCNyRDKFfmTaXsecySFTGH8OetRTCXyEv/BivxxXMo2gjP1kXNEaV7T2Ei8qkzYWmYfxnTGUM4r+GYN+v6LFeI3MBdHfdxt0ZX0n8MdRLjDfDlt/2ZB3DGVjRh3G8L0bf1t1GDPwgsCuu9UHBOc0ZBLaoQPPoq3bVnCOgrbwG3fgWbQnFIzgHAHtMP4usAOKz17bnTxjfBwyTXiUaTyHTNTTWY8yTeSQ6SxkmvQo09kcMk1CpimPMk3mkGkKMk17lGkqh0zTkOmcR5mmc8gkckQ2U88XnGvGUCb9NUSZ9JculE0qflGZ6KsHZSKv2NhIPzOQfe/0U93Wj9Q5AA8+1I/IMRj4a7MS+Ah/4SU2PorfRL5jP4QWnFDKhkGIwmriM4r4CODlt6gRZj1VeEjJJDwCJac8s5BT8E5AzjmPcs7mkHMOcs4acs57lHMuh5zzkFPwJLib5Oy9BXQFXzt7p1AuMItw9t4alw0DZwZl8p06l+9RXz2pcIJgd717HfjbGwkKpwe/vz3+TFqk++lj1wxSv+KXpY8NBp42R2ODNKf4Cy9tkMYgtOCEUjYMQhRWE59TxOnBy2++DVKeAUSDJHidGuh5DBIHumWQznuUcz6HnOchp+DRIMnkRIP0h6Ar+GKQBJ4GSWCGYZA+KGVBa39j300zSOw7rHe/Az+SaUzh0CB9JP5MMkh6FXxr/He5raeau+1EjsHAX7+3Vu/CSxukEEILzk4Zl9gUVhO3QgrzqsK+DVKesB0NkuB1aqDnMUgc6JZBuuBRzvM55LwAOQUvzSB9CnQF32WQBOZvB5o0PhOXRf1U9zf23TSDxL7Des878COZQoVDg/T5+DPJIAmuD4OUp+3C+HMw8NfvrZCf8NIGqQdCh0rGXXE5CquJh4o4O6b85tsgUSbhESg55aFBErxODfQ8BokD3TJICx7lvJBDzgXIKXhpBulIqUlX8F0GSWB+CwbplpjGMHDCoFkm39MMUojfOZjPOfB7gubgsQzSaCxbkkHykuNXLq/kNUgih2+D1KP4a4PEscH4m5Qxb3FW0ZpVtIg3UxCvvyDeXEG8+YJ4YwXxzhXEC+NP9uHouTX+rFRqlcbianlxeWuxXCtXa9V6eX1lca2+sdqoL9UXF5c21mpry0uVynqjWllfqi9XK9XVSmNtvVyrb64uDih5hG51udpYX1pZX19cbayvrW1ubi1tLK4ub1XWFlcr1bXaVSKrtdpyvV5e3dzaXKvXVhYr9eX15ZVKfWm9XF+hXd8lb3VlbWujEkm3tlRerG4srjXq9c2lzdri2kp5qbZYa5S3FrfWVsuVanV5vX5V5Gp5ZaVRXtlqLJUrm7TDpFve3FirbFZXauu19c2VytrWVSE2r35dXW2UN6rrjXpla3Vlo7wS0bsqbrm2ubVWWd9ara6v1WqNpe2c/YuWvLV6ZWNxqbG1elW7m+ubtasKX91o1NZXa/Wr9aitVVbWFjdXlhar5fri0tWy+lU1VOvr9ava2ti8lgNWQdvv4TjfiMZwOdj9uGyPyDEIPB+2p6L4Cy/anqqSKdJTLWjVf61cry5uLtZXNzev6n9lZXm9UltfXt/cXN9Yra0uLS2Xr3bwzastUl1br27V1rbKm6uby43K2tXuVSmvV0bAq4Y6V5WMVSUj8XoK4g0XxJstiHehw3IuFMS72GE5RwriHWtTzgGU7fE4286b4TgTHoGSUx6RYzDwZo8qlp702I90UvfDfz2i11D8zxv8F/3wX47oLSn+FcU/WggehJ5EFyK3yCZ0ZA+V2yRsv17Fr1fxGwE8fbpyipzWulNwThsyCexA4G9uydvny5Ap9ChTnjk4hEx+orb51+cMYvrcrcgTxJyHTJ62dOt5o9vcbvMZ3dY7Yjq6zTU+t5nPQT6R7ZyipXMJiHeiTTzamg60X+OR2n7ttkOn8G5CmdhA7jKG8fejKGMAO3qi+ePH4kbjuoCxqxcjdqV39wT+CMoF5qsQu3oJYlfyO+3vPOpMPsOgKzA/7Yg1JdXh5RnqcNyow0nU4b+gDoLDOc5TPKmRd94VOXz7mucVf+2Te5zP6tY4t3y9o5BTZJkDTvTIOSC2K/WWZe0h8NWMtEo5aHF8V1Am44fnQ7L4lUlrBPqVY0Z9ykZ9tK9ZdtSHY+V69FE9rRVz+6hVyOQzna6aQyZm/lxvqXMebW9uH5W216ePo22v5ePMKJmYsjkE2bKkpOpUz6J4ST6qz7nzkdh+7bZDp/DSfFSxQfRRmfUVPZHv9SfwUUUf9O8+Cv9Op8QKPH1UgfnPuJvjL+DfaV+B9e5WfOijCsxfp/ioVh0eylCH40Ydno86/B3qYM27nvp0I+8+rMjhex92XvHX/pC/8w3XfFS9nrMSU45CTn1kwPJRpQ7UWyWlnsxRqWSkVcpBi+Ob9krGj8tH1Tpx7WHRR50z6lM26pPFRxV4+S0aX3IHVncMGI2vA/F3+k9iG6PfR/taZbHOgY6jTL5PoEy+n0WZfJ9EmXyfQpl85xknP2OsmvuME+dXX2fBrPlVeOmEsDKE1jlcu4IVFFYT1x2YB6nkN9+OcxHjy47PRCtPBjF3OvMM5Jw35PR5cC/PmSge3BO8Q/EnF6Sc7CcONOkKvkz2As+EMIG5HZP9VEyD53UYONOBD35nQpiVBBaApoUfyVRWOHRKzseyJSWE+Wm7au7FNoP2PpMytCOgJyExSGcgtE7y25X5R2GzRI11Y/k2SHlOdtIg6ai471PDeQzSNOS0DFLoUc48s2wIOQUvzSB9NQyS4LsMksCchUF6EgyS7m/su2kGiX2H9S478HmrxTTK5PevTTFIfsZCfg+JKyOfHpJeGSV5SOMQWnBCKeNSmcJq4jq8wY7JMFDoqcJ5B3oIOa2B7uu0Z97UAV4PEBpy9nmUM89J2T7IKXhpBmkDBknwXQZJYL7Q16RxJwyS7m/su2HQfOQ7DZJ1kDAATQs/kmlc4dBwXkoxSH76WDX31Su84nfci0zXDFK/4i+8tEGahND6+p/tRj0cf6ewhxXxw4r4CODlN98DnTIJj0DJKQ8HuuB1yvPIM9BDyNlvyOnTIIU55KRBErw0g/RDMEgC6zJIAvMhGKQfhkHS/Y19lzrncf+TCicIdt+9Oe7Aj2SaVDi8iuHFKQZJcPe47bbz6E8qfq62EzkGgefDIE0q/sKLezT9Sib2e+a7a+Omr3AgXk9BvOGCeLMF8S50WM6FgngXOyznSEG8Y23K6XG+Wsl75xedBk92w3QaJpWeOC9YzvIMZAsVrVDRIl7e88FSVi6Id64g3nRBvPmCeOMF8ehzhaCx17kcRXwZ39f7hIq/nmcinYz64b99ZuOU4j9p8D/kh/8yF3fC37re6CD0JLoQuUU2ocMzG9ofKgXZ7nUVePbn8ylyRjBJe5unDZloC/qBE/2bUngHQIt1Ya7q78cVj/zMD8VC8VylD587T6hd5PB9lv9iDpkWIJPPexAWcsh0ATL5vCzmQg6ZOrCNWb9RckhcZ/mtW754HmRW0XKdPT/RJp6Vk/FoDlD+9mu3HTqFx1w7sYHMxREbxFw7sQHMtfsSclysPDWZYKnbLLl2T8P81NXV5Cu/0/7Oos7kw1w7genr2s2TT1IdBjLUwcq1m0IdDqEOMs44x/nMac0znzDnxte8a/lH1tljn+dB9FhZUPyTzoOwr0UPc+2kDtRbOaWeHGvljLRKOWhxfFt3ETHX7qKSVevEqo/g0Ge9YNTnolEf7WtedNRHfmO8VfhE4+v9ho0gL96fw3Fr3eA4i3H7ZIPuRdRrVpV5TDXa7rfTCfVgWo3AXHTYOtIKAnu+KAWt2SI6Vc26upp6KfvXS43xV5deBGYpRS+TQX69TBp6mVYyBMFuuyN6Y+6lz/ziJB3NoFxgnpAyT8p7G7khL+9k3Os5LCK7eLTJe2cMgJ9uM52hUApazyLoNmNK3izKZGwLTdoFl8/Id+Dxrq40+/PUjD7KPGiKj8I7ovZ6nOVNjOCaxuf5GD2Xu87HsF2ljO8IyXNeZTz+9Dhuq7Q1rnErMM9KsW3abmldWToQHNo2fYdckm/OswlJvrnArDlkT5rXSZ/1OW7QfxHm9S1jXqe/MqN4MSONcSBP+xU1xnr13Y+04wLzvOvHXtez2OsQ8iXZa23TBYcp1AJDm6ftsbSlyx7r9GXa4+926JZxE2Z8Lih6EZ//GtOhHeU683sxp3BsJ/VrgXkN+vX3Z+zX9Fc9ZQ428mb2ihy+39mi/V5t4z2O67rV9613xhyFnCJLCJzo4dpT++BZ5zL9+hjSmjdolRy05h20zuWkpeXabxu2Mx4dNkzXw2XDTqOu2obRpvBYi4xZ2j8dp6Od8eGbvrqAbxrAJul51fJvdD/iHP562Lr3GnS5Nj+nyjo1rnU9rPn6F1P8tBB/WzbC1bfoY2kbYp0K8e3HjGbQi8C8LUUvowX0MmroJVQyBIF9kkDgPM6TdZeOGO8RmAcz+nozkL1Ta/NQ5AU/3WYCwzbTc7JuMx4CoP2TsR3Gn7QL1hwo9Gj/zgE3zf68L0X3Gpd+HWOX4/j9/ZD3ImSN/ll7+1LG+GkPyt/X3aT9QcQFHt1HT5bpy3QfvfBxYI9xpvojNc60n/foyPhk+1GevV735Wk/kcN3+w0p/lb7zSqZbvS9fR2H4N4f9/YZ24ueaO74Qkq84ktdrfJp/4V7+zvxbcxPpe4m353j4EErXVf8cId3926efJLOafR1N3npvX2Bt/b2z6IOg6iD4HRgjmvknXdFjsHAX55fKdg9x1GP+7W3r/eVJb4icmbZ25c6UG9Z7tER+EpGWqUctKz9cY5l7u0vKFm1Tqz6CA739q17gRaM+mhfc8FRH/mNOaLCJxpfv9nb5OXK/9Hj1opfnMO4fZJhexjvn1Vlnd7bl3pYe/sXHLbOWk/l2dtn27r29juQ87AdP5jKoBeBaaToZSrIr5cpQy/X295+ko64hhWYx6fMk9fb3r5usyx7+7rNkvb2ZWxzb/9Jhk8gdIWeK37qsj+3Z/RRGD8VH8VjH6rR9w3AI1D1l0fkGAz8vbvQalc9XrnHxFi5lE1Atjz3pfNdR55sW9Wy+dLuls3/Fo82n361y+afN/iJbz4LeC37dzpkJ/0LCfRZn+MG/Qcwr290t9K19gWYzzytynzHxM+iDmwHxsQF5rsy2utZyN6pfbGdeQf8zkI+2mJXjF5wuIcuMLR52reXtqQ9ZuyVMPQTBeaFDt3SR51C2QVFL+LzipgO7SjXmS/CnKL3u6x+LTCvRr/+voz9mv6qyO1j7Ul7Izz4cL4QOXzfVKR9BW3jfe8B6r5v3ZR0FHKKLGeBEz1ce0odqLcsc5n2UUlr1qBVctCaddCazklLy7XfNmxnPDpsWJZ9RsGx9vaz7uPT/uk4He2MKx7tsoU61kFb+HMp84zGZQzQmlct/0b3I87hr4Ote3d3K12uzadVWafGta6HNV+/KcVPS7MRrr5FH0vbEOqlAzkP237MeJCuF4H5lRS9jAf59TJu6EXffRwEu+cq0ZvADQS7c4D3uu8k6Yh9SmDemdHX482cnVqbW76ebjPL19P9XbfZSGD7fzK2hSbtgjUHCj3aP67r0+zP76ToXuPSrwuC3e9ql/qcQJn8/s7eJv4fYG3/6F54skxfpnvhuS+jpP/kK974SI0V7ee7GGV8sv086Wp77TYY7H6y5lcM+pHJzK8YVLpLy6+4Ed9zwz1ZKdM5usyt5v78Z1NiDg93t8qnfRDuzwvM4zE/fcGIOVh54a4Y4I5uenbz5JO0P3+gp8kraZ+PcROBuRl16OlpyqTPDnuc426Ys/fW/ryv3C5rrKSdvddnzawYic67yLo/L/CVjLRKOWhxfPPsvYwf7s/rnAnr7L2uj+Bwf37eqM8Foz7a17zgqA/HyvXoo/p6b2leH5V7Rp58r9zvrGQOuE8fdSaHTPRxfL6LMY+PStvr00fVttflo/JcOmOlItv14KP6zCHN037MIfXZfkOKv9V+55VM9OnYDlleDbVfeJaPSp9b50HQv6WP+jWx75V0t9JtDv/Ouh9KYH6qp0njdvh3+vwF6YqP6sohfVqKj2rV4etRhzz3Q92NOjz9UR911zjL4qPeaPdD3Ug+qowfHz7qjFGfvfJRmRPNva8HjRxS6ivJ9lg5XPdg3L7YsD3MK9F5LVG/9XmOcCqhHtyHE5gXOmwdaQVBkJhPpHOOBIfnCfQ+cVJurSe9OO+Hol4E5vtS9DIZ5NfLpKGXKSVDEOy2O6I3gfOdf5ykI+sOrf+UMk/uZw6ptU+l28zap0q704t+MX0hGdvcp3qx4RMI3XbP4L80o4/CHFLxUXzmauf12Rl39+mzJ+0T0me3zhZL2QRk0+Na71ETj33fk22r5rX5r74ObP6Mwc8VPxaYNzhkJ/1KAn3W57hB/39hXn9zTytdK/+EPozOOfeYV2DmXui8hl25Fxnt9X7kX+3MO468AoHJklfAXE2Boc3Tvr20petOAIGhnygwv+HQLX3USZRVFL2Iz8ewVrb2c96FOSUpr8rKjf4H9Ov3ZuzXHciDbnCuDsCDD+cLkWMw8JbXar7LSdv4TuULCX/tq8jaU+QUWcaBEz1ce0odqLcsc5n2UUlr1qBVctCaddCayklLy7XfNsw6t6Tb0cpnS7JhzCHVNiwtX5T2T8fpaGcsW2j5ptoW6n052sK/y+ib0u7dBpuk51XLv9H9iHP4J2Drbuptpcu1+ZQqu57yAP8lxU9LsxGuvkUfS9sQ6mXBv17Mey4tvQjMF1P0Egb59RIaehlXMgTB7rlK9CZwvvOPw6CpC+qIa/YdmLjfp/l6PJvaqbX5zhhw3KMnMK68X8HhOlxgaP9kbAtN2gVrDrRySLmuT7M/R1J0r3Hp1yWds9O5O9p3ZI7NCeS9LPW20qX9m1FlnY5NVpQuqMcxhx5JKwjsfCvXOpVrNmudqu8o7HRs0tKLwEyn6GWygF4mDb1o/yoIdu/xW7FJTz553aUj9imBWcho/zrgJzaynDXSbWadNdL9XbcZfWLmtsrYpg+3BPun/T/rfLs+Q+SyP49N0b217j3QodhknhwVxiZ95fLQtxb+erymxSbpl+WJTTJG1cnYpGvuvN2jzadv57L58wY/iU3q/AbK/g0O2Un/fAJ91seKTT4X8/ozelvpWjEca6+J5yjGIYtvn174cw0kMN+W0V4zl20/Y5Mh5EuKTY4rGMGhbyowtHm6j1uxSW2PdQyF9vhOh26TYpPnFb2IxI/FdGhHGZu82/Cppe2tfi0wL0W/vpyxXz8am2zyt2KTnsZ1Pcv6WscmRZYQONHjOzY5Y9ByxRNnHLT2Mja5HzbMik2GQfNJik0m2TDGJrUNyxOb1LFG2hnaOeFvrc11bFLvMTI2+ZMZ1+a0r3KGxppXLf9G9yPO4T8DW/e2ArHJToxrXQ9rvv7ZFD8txN9JMbikvkUfS9uQpNikTz9mNINeBOa1KXoZLaCXUUMvoZIhCOzYpMD5jk0m6YhrdoF583UcmwxFXvDLcne9npN1m6XFJsP4k3bBmgOFnis26bI/v5aie41Lv455lRX8/iB+L8flF/H7b8a/DwTe7pxt5D0TI3IMBv7ODpWC1vep6nzcQ0HTJ75z88odmw88c/XuuzZWr9x1+dI3bj7/vs17r5Qg3kVVFf6WVN0DKDuD7yeM3/kMA54qOqN4nFF0uOV4xpBd8LQqIpikK2qPGzLR/Pu6yrhotxoIHn3VgkumL9PrJerc/s4i043yyvubIZsOJ+v0wb28Fp+2hu1HefZ6msnTfiKH7/a7WfG32m9eycRjyGwH3Rf0KxL2E49H0sQGMjVbvwqNLhaPpP0LXBbrONdne1vlE9fWOpImMM/sa9L4HJZ3gkP7O486l4LW1y+Q7pdS3LayUYegr8nrvKqDwDMctyMj6tDV15RJX1nvcY5rsE4BePCx5rhB4PkYZ9o/sY6k+TrObI2VsuIvoTeRUx8DsEJvUgfqLcuRNIGvZKRVykGL47uMMhk/PJIm30VWrRPL9xQcHkkT2rxO9bRRn9OqPqeD5PrIb1F/rsbfhU80vkbj8TUQeOu3uZdGIofvpVFZ8df9gn4u+wCXliKbbt+LihbxxgrizRXEq6I+B+PvXD7P9zV/H4jLD+L3D45c+855hHZXz0+iK9r8neOOsO1f39dKl31/XpV5vNKizjCurocVxl2KZffxivMydKDDwdbRUY96qVlbaZZeBOYJKXqZLqCXaUMv+gq1INg9N4neeEWlp+NddZeOmJ4iMLc5dMTwI9cT+5kapNvMSg1KOs5Cu2mt3/Q1xLQL9BuFrtBj+JFHDNPszzel6F7j0o/12IdqXB8F4BGo+ssjclzvrxukT5HnejqJsXm0bVXL5ku7WzZ/3aPN59rLZfMvGPxk/WZdKSIwz3XITvoLCfRZH+sVAT+Ief1SXytd63VOTKvo4GsDzHRXnUrKVM77Mtrr/XglvLWtPgn5aIuzpHJyC12nrVn2wNoO0tvh2j6w33y/Q7eMrXEbX18BFfF5HXxY6zWRP4Q5RaeyW/1aYN6Efv3DGfs1/VVPaY0NztUBePDhfCFyDAbe0lsrru1Cxic6kaIt/LWvIvEJnVYzCZzoYXxC6kC9ZZnLtI+alOKp5zeL1ryD1rmctLRc+23Ddsajw4ZZabZJNoypQdqG0aZwa1z7oVYsl3bGioW1e6XGG1PmGetKjc860hUt/8b1Wvn/Dlv3/r5Wulybn1NlnT56IfWw5uu3pfhpaTbC1bfoY2kbQr1U/OvFfIWXpReBeTBFL1leN6P1ctbQy6SSIQh2z1WiN4HzfeQrSUdcswvMezL6eh1IoWxkSQPXbSYwruMIus14JIP2T8a20KRdsOZA69U/2hd02Z8Ppuhe49Kvi/rdobj8cPy53TaQZe/aplqO6HWhDowfd6NcYD6SMva68HeEPx5/P6DkJ4zg0Aftw+9BDCNwfcAnbKjoCl8Lj3IeUjhRnzms4Ibxvd9RF6nDKcAI/d4gWb8C8zcO/Q6gDj76QR3ydEO+PpQLzD+k9IN6sFsvVj/oUzB1fI8ejgWB7cLvh4BP2BDldfC18Pi9S+FE/aBfwSXx6QIf+X0UdEIFZ40V67hgUt/hmBWYz6XYHY27bXcONOslOqbvTHl99zerbgJT6k+um9XfrFiB1rfg0O7Q3sin7pcath/l7AcWHuXsUzhcH9XBR76HQXJdLLsj9F19R2BucujX9/zTgDycD2gfBeZISj9oBLv1YvUDbbMbSi9F5x/2gwb4Wnj8Xlc4tBd9KXxo3+R32p1+BWeNFcvuJPUdjlmBGXe0yZCBG9HcgN0J43Lxn3zPc+xXrFufKo+emZT+pvuSlTOh5znBod3pVzJwnmN7E5b+cB/4WniUM1Q4jKVw7pXv8466WHYnjL/rvkP9Ckwjxe5oX+vW+O9yW4/t9+rxRb93JaUfaHts9QPdHtoucCwIbFdg+7eEZT/g/GPhhUoG4nD+CVP40L+W32l3phWcy1em3Qnj7y5fWWCenNHudIPmV8Pu6D0r3/1N2xeRj/1NYL4upb/pcWjNc7q/CQ7tTqhkyNLfuF7uB18Lj3KeUzg8tmjNc7Q7ui6W3dFrdEu/AvNtKXYnBF3f84/IF6ry6PnOnPOP1Q9CBaPnB44Fge3C74x5JeWs0B5YePyufSvanXMpfDjPye+0OzMKzjVnueI71pwlMJcz2h36UBOwO1LXKvjrvTwrvi4w9/U36b6sv5Uu84t0/oK/vn0tRtmfUI8Q5QLzopS+rce8tXcSKhjBsa5PDg29VPzrpWaNeUsvAvODOcd8Fr10G3rRdicI7GupBM7f/Hit7yTpSPep6PnRlDG4n1fm7+xVKX7yJO1J6P6u24zrOe75ydimDXsZeGfZ32MsOs3+vDxF99b+3kOla9995njmzT0TOXznniXtLzD3TM91XJMxBndO0dL9iHiSn+3xKrAqbY0et9yzFZj/lmLbQlU/K/dM60BwaNt0TgHnxzmDX3eQnHsmML/okD1pXg9Bn/U5btB/L+b1txrzunXVYhVloSrzF7e7Nqfp+G2Iukq5wLz9+rHXLXkbO/ML+OkYGdc5lIkwOk47AhjavFDhSVu6coG1D8Nc4Hc5dMs8Ea67qopexOfvY4Ck3LPfgX44tpP6tcB8Ev369zL2a/qrnnyOBq+pCMCDD9tY5BgMvPmKFcsP0Dbe47iuW30/VPwl96wfMEHQut/B3DPdf7POZQJvrQvnDVolBy3XGjPMSStUtPbbhlk+p25Hy+dMsmHMPdM2jDaFeRYyZkOUiZ1h7tnfe/RN/6mAb/rReNBb86rl3+h+xDn8M7B1Rwda6XJtHqqyTo1rXQ9rvv5czv3WMP6epW/Rx9I2hHqp+NfLth/TyKCXnf28AbdeGgX00jD0Yu0dh/iu9/V8r82TdMS1ucAMOnREO8n9vk6tzXfGAPjpNuOeqsDoOVm3GdfmIcpkbHPvU+yCNQdauWchcNPsz/EU3Wtc+nU8vxqCvz4XK7bROpd2eqBJ93EDrXRp/3S8stPnYqUejL0KzNmUcZ7UblnOSHHNNqdk2I9zsf0Z9CIw8yl66S+gl35DL1bsn76C6I02hOt633HtqpKDOqpltH/Xy7nYtPVGCfUUGN1mI4ChTbRik4+D/dPnYrW/aK2FXfbn1hTda9yI5ssRm/QUB6zdyPdVWe06p2S2+sicokW8+LiHz3Fbpa1xjVuB+boU26btltaVpQPBoW3TcUjOj2MGP4lNWvcaCcwzHbInzeukz/pY5wcvY17/VmNeZwxnTvFiPFbKPPqrZmxS+NOOC8zq9WOv92xdr2264HANvzOnA0/bY2lLlz0WGMse3+3QbVIcIVT0Ij4viekk3TP2fMwpHNtJ/VpgXo5+fSVjv6a/6mlfpXGjvGJF23jf61Dd9/Xet8Qm9d61KzapffCsc5nAzxm0zhu0Sg5a5x20ZnLS0nLttw3bGY8OG6br4bJhjE1qG0abMocyfdcP7Qxjky/x6Jv+dAHf9MWITep51fJvdD/iHP4K2Lp3DLTSTcsb6sS4duV+CMyrU/y0NBvh6ltW3lC/oZeKf72YsUlLLwLzxpyxySx6aRh6qSsZgsDOG2Js0tM8WXfpiPEegXlrRl9vDrJf77FJPSfrNrPuSkiKTb7D8KOEbp69Gcv+/EaK7jUu/bqo38l9AGH86e+ux2t5uhXUgX52GeUC856UsafvAbXWjmUFo33jSAcXlQxdQet9shr2Asp5LsHCo5wLCodzpnVX6WyQXBepA/O1hb7OcaB+BeaDDv36u7f+Wj+oQp5uyHcR5QLzRyn9oBrs1ovVDy4qmKrSC8eCwHbhd96tS1j2gyr4Wnj8XlE4vANvIYUP7yKV35mvfUHBWWPFyo9J6jscswLzUIrd0bgRzSPwu0RG5tP57G/s/6wb+5vAfDylv+lxaMXjdX/TMdui/Y3+80XwtfAop74/OOonYwpuOGi9m9Kqi2V3eG9wkn4F5nMpdsfPvd32/CPyLaBcYL6Uc/6x+kHSndy8L+eCkqErsOcZwrIf0B5YeNZcxbusZxVcEh/Oc/I77Y7ej3TNWbQ7SX2HY1ZghgavfabZnTJofipo1kv7Q777G/s/68b+JjA3O+pmjUMrfzLpHTW0O0X6G/c0FsDXwqOc+k5o7ldwDMj3WUddLLvDdX2SfgVm3KHfgcDX+2fs+UfP65x/plL6gR5TVj+4oGD0/MCxILBdgT3PEJb9gPbAwrPmKuvO3/MpfDjPye+0O/oucNecRbuT1Hc4ZgWmntHuXATNPwya9dL3E/nub+z/3UFzb5D9TWAem9Lfksahq7/RlxQdFOlvXC9fAF8Lj3LqO3EZw7X861lHXaQOtDs6RmnpV2CenGJ3/OxF2/OPntc5/zw15/xj9QMd39XzA8eCwHYF9jxj7esGwW57YOFZcxX9Xn3XeBIfznPyO+3OnIKzxor0C1d8u1fRYd95Vord0bjR328JmvWSu7K5zhqHLHsdW51AHVi3cZQLzFpKf5vA30nz3LiCmYAeRAehksG3Ds5m0IHA3JXSvhI75Z3nndpj2mlL8NN3CgqMq00ER/QwErS+druE74JnjZ0zoEUYwe0BzBWHbrn+lToMGfSiv++Ovw8Eu3NJ9nIfmLwD8AiUTuTheD7jR6bt9wGO5ZBJ5Bj0qCf2AeEvvJhfFSqZGGfl+91CRStUtPYSLyqTNhaZh/Gde15jiv6YQb9f0eI7fJjH8aODrXTFNgk88zgEZvRok8aPD7bKSxvba9ShF985Vq069Bp4QWDX3eoDgsN3ZgntMw48i3aoYATnKGhrO2HhWbS1bRScI6At/Dhfkc9e2508YzyETJ7m0EreM4TU04RHmcZzyDQBmc56lGkih0xnIdOkR5nO5pBpEjJNeZRpModMU5Bp2qNMUzlk4jsu9HzBucbysTgHSn/h/WRnFb+oTPTVgzKRV2ws5eoBLOdJ3oFXAvww8ATmHSnrZD/5DtUK35USgAcftgXzAn31D+pO+Ot7qKK8vFuCpt4jIfTZ211JNxQ2y0FhffG3x0MzlbwvLWHSheCdgJyzHuXMk0TKl0vMGHJ6StSv8KXYWeRkYp/gHYo/kxzLD8Cx1AnCAn8K5QLzL0eaND4Ex1IfQEo6tMQkq5MKJ3qsQ00WPo2WdfD5T1MMkqeDLdsLrx7Fz9V2PNjS40cm82CL8OLCa0bJxH7PxYE++KET54jXWxCPQRM/bVVb9BfAvXbAKY+tETl8J6zrIK/uB/42N64F2HSQ1UpYZ7voIPGCgueii3rTi8UzCs/qaxFef4p81iJXcE4bMhGWSary+wkHXYt3j4LRgTbyJmxvCm/qh3qw8PoPNn/7EuYRX7rbS92wDaKHDuQZlMkc2I+yWdAR+Q4dbKVzwqBzwqBzi0HHd1Awj01iUNCnTdJjVbctL6XigoiLKJFN90G98UC8YwXxpP19JrsPBbv1IjwCJac8Isdg4K3/mJcxabvKYDjbR8roM+sxbQUZpYzrmF4/9auznwXgESg55RE5BgNv/aCSxfZFOvHkO9Ysn+GMwd+Tz1C1fAY9NiOf4WCwe64KglYfgklT0WMdasm6vhZ4BjbOpMjJtZbACM5pQ6Y5B55FW/vX+rBqkq80k4F2kt/G4LfeVO8KWg/fleJ/vFCb/LsA269wfF6Iknfsixy+x35a20R9P1rri+8h/ob4GNKXpN31mtrXWJhOkdvq04LjGgu+A7t5+sA0ZPIZC8oT4KSefPkBPMSaRSau5Q96lCmPv3QQMnmKN9bp/2eRSeQY9KinUtD6sm/hZcWCrBjoIGTLE9M50SYebU0H2q/xSG2/dtuhU3g3oUzPb0ziO4oysQFco1/CGl30wVj4PQdb5ZNYuMAfQbnAvBCx8HsPNvlacaWDqDP5cDNNYO4/uJsnn6Q6PJChDtZFNl+LOnwP6iC65Rznyfdq5N3voB3ytVfk8qe57vE0znddsib8ZxV/udxD5NQxK9GZdbkH9Zblcg+Bn8tIq5SDFsc37ZWMn1tAU/uVWidZ/cozRn2mjfpoX3PaUR+OFZ8+ap6xcr37qL7WTnl91H7I5NNHzbO+oI/jc92bx8eh7fXp42jba/k4vUomxguHIFueOOOJNvFoDzrQfo1Havu12w6dwivio+p9hIjWO+Gjij7o3z0I/07o68v86KMKzB8cbtL4Lfh32ldgvbsVH/qoAvPuFB/VqsN7M9ThuFGH16IOv4s6WPOupz6d+wI6kcP33tlBxV/7Qz73S6w9V2s//yjk1DF6y0eVOlBvsyn15LpxNiOtUg5aHN+0VzJ+XD6qtVet62P5qP1GfaaN+mTxUQWeSZ998fePYT//r2CHxHaJbYx+f9dIUxahaR2ICFEm38dRJt8nUCbfz6JMvk+iTL4zCXcK9Tqr5KaOxLZNgZ7gCcwnHbbNn29fLZxYPBj4S8C2+rPw0smsZyG04IRSNhwDBkrYw4r4YUWc2cvym+8FFmUSHoGSUx5mdwsek0R9LibyLLrolEwbcvZ5lDOPg9oHOQWPyaxW8KvvUJOuwOrgF5NZBeb74FgMxoXDgJX2ZN+lzmloTyqcAGXkb+HTaJ1Emfx+OJYtySB5OqWyvTg8qfi52k7kGASeD4OkT7IKLy4uppVM1gRuGTdr8pSysYJ4Yfzp0W7V8p7e4eTh65STpSfdVpFODnnSieUgn1X8D6t2EVnm40+9cOWNA9SbTrDWN0rxtA4TmsMU+azFtOCcNmQirMDxVgLXZozF+6SCEZyjBm/CzqTwpn6oBwvvcXGjRHa6Cls/nUH+UMFYjrbwDB14WXQjONSN8BNYzmEzKBMfZxplo6ATPVH9bz3USueEQeeEQecWg47H+aOW10fh/OHLv7PmD227eYqV84eU8TaZUNEKFS3i0X8N/dSvnnceCONP3/NAqPjr8URfI4TuTuK7yKbHnZ5TiHesIB6TfD35MnX2swA8AiWnPCLHYOCt/1QsPem26vScPW3w97ReqVoB4FDxl4RT0ZPoQuQW2YQOk+ykH4eQfyTYzW9E8aMN4Tg4nCJnBHNMwQjOaUOmYw680KB9SsEIDuc/4XfKgRcatLWNFhwmnAo/ge0CHOtSin8LlSyCI7ChwhlQcu/n2Bc5fI/9tLaRhFPxPcTf4O1aAhc9x5T8vsbCbIrc1njRsYRhQ37OXd3xv0mFdwC0QuD1oPy+eEcysgnfC9/rekwU8HmbQx5/kLc5+LyJI0/QlTdxhB5lKuLDRTKN+pEpt70SOXzbq1HFX3jRrzylZBoJdttTkU3bvlOKFvFOtInHRIEw/vTYfo1Havu12w6dwrMSBUKUiQ1iogA3wqInmjteh/W/4DMW/nrER0RfEgsXeCYKCMy/IsbyC4iFy++0v1KnbsWHm2kC8xZH7DqpDr+UoQ7HjTr8PurwK6iDlSgQoj57Pc7yzCdh/Ol7Ey9U/K1EAV9zhzVWrE3Eo5BTZGFfix4rUYB6y5IoIPCzGWmVctDi+J5CmYwfV6KA1olVHyt+edaoz7RRnyyJAlYcUuKUvA30/qEmr1GDF/fbOG45ngXm/2DcftKwPdOol95Hi/rtMVWvW+O/y+09da4ZdD2OoVxg/shh60grCOz5wrVeD6EDHduiXmb966XGdZpLLwLz5yl6GSmglxFDL3rNGQS77Y7eo/UZ23PpiHu8AvM3KfOk3CY8Ctk79Sa2nTEAfrrNdN6GFUfUbcZ46ymU7ex7x5+0Cy6fkbcNnwJumv35TEYfZRQ0fwlreE8xohr3bgLwCFT95eGaxtNcbsaIhJcVy2e7StkEZMsTk5f+43HcVmlrXONWYLrieTDJtmm7pXVl6UDHI2nfuT9h+ebHQCfJNxeYQYfsSfM66bM+xw36ZxHzusnwF+ivnFS8GN9lHKgT+w7S7sKfOUUCc4tDdx221/Us9lrvqVj2+pCCERzRwwhgaPO0PZa2dNljgbHscejQLeMmh1Gm49ARnyfFdGhHuc6cGmrKx7Gd1K8F5qno1zMZ+zX9VcaW93rtSXsjPPhwvhA5BgNvvmLF8ns7mANUt/r+McVf1p4ip97Ps9aeRfeXBf6kQWvUoFVy0Bp10DqWk5aWa79t2M54dNgwXQ+XDeNb0rUNo02hryFjlvZPx+loZ3z4prenzDMalzFAa161/BvdjziHfz1s3eWhVrpcmx9TZZ0a17oe1nz9zBQ/Lc1GuPoWfSxtQ6iXWf962fZj+jLoRWCenaKXviC/XvoMvehc7iDYPVeJ3nho0ufh+iQdsU8JzFZGX+8kZN/PtbluM8vX0/1dtxnz72n/rLX5ZcOPErpCj/bvGHDT7M+9KbrXuPTrGLscwe/3Q14eDEra25cyxk97UH7vTU3aL4ppX6/76JMeZcqz7zEJmXzu7U/mkIl7+xMeZcqztz8BmUI/MtXzvo0kjD8HPerJ2rMSXowzjSqZ6BcPQTbtl+k4DPFOtIlHO8n2ozx7ve7L034ih+/2G1L8rfYLlUzM79qvt33lxePevtjACZSJDUrb238N5i3BZ7zidUOt8on/IvDc2xeYz8CHfwN8eMGh/R2Pv0v8cELJ2QOYN6fMzdYlAG9BHSZUHaxLAATmfajDW1EHwenAHNfIO++KHL7PM0wq/tYFwZ7GeZ19RvjrfWWJr4icIgv7WvQwvqIPrJeCbJfH6TN+abRKOWhZ++NJe/tTSlatE6s++i1N3NtnfaaM+mhfc8pRH/mNOaLc238ODvlLW3FMSbvpccvxLDDvx7j9J8P2MN4/rso6lZOi62HFYT6Usk7We2JSF7a39iUEh20bKhmol2n/eqlZsXBLLwLz0RS9nCygl5OGXnQOYBDstjth/ClwPnP3XTpinxKYj2WMH9BX7FT8IBR5wS/pXCPbTPd33WbMfRxHmYztMP6kXaBPIHT1eVPan94g3f58OqOPMgGab8Ea3tc4e6Tm445Dtjz5sdIOHsdt1Rq30u7WuC3Fjn1W2xaq+rnGCf1qnevIeeCswU988xDwWvZ+h+ykP5lAn/Wx9kDHEfM6dFMrXStnbxJlJ1WZx31RM19N54IxF+uoQ3e01yFk79S+2M7ejSMXy4rR6z1YweF+l8BY+5CCJ21JexzG33sVDMeawIw5dJu05zap6EV8nhjTScohP3tTU76kXFT26539NvTr6Yz9mv6qp330BvdEA/Dgw/liJ8cn8HsXi85v0jbe47iuW31f7wnL2vMY/g6AZ609df/NOpfpnDfSCg1aJQet0EHrZE5aWq79tmE749Fhw6wc4CQbxr19bcNoU7jfL2OW9k/H6WhnaOeE/4SCp//Uq2AEl+dVnpwyz2hcxgCtedXybwTX8m+eBlv3vJta6XJtrvMIOjWudT2s+fqbUvy0NBvh6lshdKBtSIfzu7b9mKEMehGYb0vRy1ABvQwZetFnpoNg91zFuTx6fJ/ZSNIR814EZiOjr8e4QqfW5jtjAPx0m+nz8dacrNvMyveiTeRe+fMMP0rohvF32j/6aGn25/kpute49OuCYPeln2IrT6BMft8YaeK/MMZ/dC88+1546FGm6+yce6VoXMb3XSGPxHMgPHuf5xzIiTbxrHzxASXPXq/d8rTfID59tt+g4m+13ykl041+9l5sINcHYoO4Px/G37k//0rEHKzzBK9yxBwEnvvzAvOx4SaN18AP1/4/1xeu/XmBeX3K/Grtz78RdcizP/9O1OHNqIPgdGCOy332nvcN+jx7r++y6vT+vI7pJ529FzlFFva16LH256m3LPvzAj+TkVYpBy2Ob/qyYfyd+/OTSlbr7L2uj+Bwfz4MWuszadRH+5qTjvpwrFyPPqqvF1rk9VG5Z+TTH5zJIRP9CZ85pHn8Ce4r+7wrfCKHTLS9PnMQte21chBPKZnoOzBns9P3Q+lcwkdzSO32O6tkok/HdtB9Qd9rup94lo86gTKdB8G8Y/qoH4ePKrTp333C4d8JPH1UgXk8/LtPGz4q7e940Kxzko8qMP+a4qNadfi3DHWwfNSbUYfPP+qj7hpn++2jjiv+WX1U9rXouVF9VH1H+176qKNGffbKR2VONPe+towcUupL2k2PWyuH6wTG7dJwK91J1GtclXU6D1DqYcW7x2LZ28mVTMon4nmCUMmQlFvr694a7kG49LJzXjhFL8cK6OWYoRcdiwwCO4eU5zhD8NjrvpOkoxDlArPg0NF+55BaZ/V1m1l7i6GC0W3Gtfs4ymRsc69J7AJ9AqGr43u0P71Buv15bIruNS59FN/3Q+Xx2RnL9emz67Fo+eyufYFxyJYnvh/Gn52+H8p6d5fA3J7TtmldWTqwbJt1P5Tlm+v7oSzfXGC+wSF70ryu74cSGOt+qOdiXn+GMa9b+Sf0YY6psqjdRyDLXs9pOq9A5zXsyr24fux1pvuh9DrbujNA59EIDvUgMLR52h7nuR+K9lhg7nTolj4qc/2sPP8fi+kknbe8G3NKUt64lRv9UvTryxn7Nf3VR++HuvZw7elpXNetvp92P5TIMgSc6PF9P9SEQavkoDXhoLWX90Pthw2zfM4s+WxJNow5pNqGpeWL0v7pOB3tTFbfVNtCyzcVmJ8s4Jt+ArEvPa9a/o3uR5zDfwa27m3DrXS5Nj+myjo1rnU9rPn6Z1P8tDQb4epb9LG0DUm659KnH3Mog14E5rUpejlUQC+HDL0wdi+PdT+UwHncC6m7dMQ+JTBvzujrXS/3Q+k2s3w93d91m40Etv8nY5v3Q73N8KOErtBz3Q/lsj+/lqJ7jUu/LukODP3OCet8qcD8Juzfn6fEJkdVme/7x48l1MPS43tyrlPz3GNsneM+aehlyr9eavQ3XXoRmD9I0cvhAno5bOhF+1dBsHuPX/QmcL7j2kk6YvxWYD58HccmrfOSus2sOUvHsHSbcc+euYTaJ6RdsPw/63y7PkPksj9/laJ7a937RsQmfY0z5lUE4BGo+svDnGBP/dp8t6nOxWCfoa9/TOnRsom6HxGPMSpPa+mqNW6ln1jvK/l0TtuW530lzE3Qa86kc5GHQYdjcNiQ/eGU2KTO6dH0WZ/jBv0jODPyxeFWuozhWPHYw6qs03fX63toewDTHdftOjjzVM9y5knfVWqdeUq6m5frLYGhzUvyWWiP6csSxvIXhh26tc5YMQeIPmojBqAdZWzy5pGmfNrPs/q1wDwW/fo49uhd/boD6/UG1yoBePDhfCFyDAbe4qUVa+2qbXyn767XazWJTYqcWe6u1+dYs85l+v1KpHXKoFVy0DrloHU4Jy0t137bMMvnbOd+cevueuvcpmsdbp1zoZ2xfF7r7mZ9vlPfXcN9kJWUeUbj8gyNNa9a/o3uR7TFT4Cte/ZIK12uzQ+rsk7fXS/1sObrr3HoMYuNcPUt+ljahlAvU/71su3HDGbQi8B8bYpeBgvoZdDQi3V3Pecq0RvvrvcZ107SEeO3AvOMjL4e4wqdWpvvjAHw020mMK54sm4z7uHQ/snYFpq0C9YcaN11pH1Bl/1ZS9G9xqVfx7zKGfy+hd9n4/Jp/C53d3p8t3wj75kYkWMw8Hd2qBS0vk9V5+NG41d84js3r9yx+cAzV+++a2P1yl2XL33j5vPv27z3SgniTauq8Lek6h5A2Ri+nzB+5zMMeKpoTPEYU3S45ThmyC54WhURzJSCEZzjhkw0/76uMi7arR591YJbJro0X0avWqjnvV5C5Bj0qCdXCgBDkONKphGU3QzZxhWtcUWLeCfaxKOtYftRnr2eZvK0n8jhu/1uVvyt9ptQMjEdh+2g+4JO/9xPPB5JExvI1GyxQTySxiVV9EQuyc/CZbGOc71ypFW+LEfS/h+Wd6/G8k5waH8nUOdS0Pr6BdJ9XYrbNmvU4fWow1lVB4FnOE5gPow6/ALqoF07j3NcbndO5PDtzmn/RHTC0Juv48yurTodehM5daqVFXqT79TbVyg+X6H40O5mpVXKQYvj2zqm5jqSZvmV2vcUHB5JE5q8TvW0UZ/Tqj6ng+T6yG9Rf55Tskfj611YGnnqtw3ahwA8AqWTQNV1EHg+xpI+JqjHkrXcZL84B9l0++pXWxDvTEG8/oJ4c6jPQPxd6hr1gQ9iLhIeA8DpUvyjUAHnFNpgPVfpV2lwTvkI7PzDxlzFcTChynwfQxtLqEeIcoH5i5SQm16vav+iBLoCIzh8bfK4ksE6buJRL9uhyNEMehGYv03Ry2gBvVivkx5TMgTB7nlK9CZwA8Hu41R73XeSdDSOcoH5ZMZQJNcWnQpF7owB8NNtpmMv1jpKtxnXUVzLydgWmrQL9CGFrtBjKJIpPWn254sZfVq+Buj1mC899aHcRxhFDt9HGHW76vHKayIFlsdVOZeHilaoaBGP4zb0U7+qNW6to8c7rw2O49k+bBvXYS6bP2nwk7XcBOC17EcdsltHsjR91ue4Qf98TH87neJwK12meIaK136kvvJ6XLYDU1kEZsyhu/0+/mNdIX8C8nFrhv1Qp/sIDlM4rWPIei0Yxt9dR8oFhn6iwMw6dMs1jXUEiXb/62I6SUcYFw435QshR1K/FphnoF9XMvZr+queUjhzX6W6X1fhhvF3xip8pvrrvq/T0CVWodPvTwAnehhfCOPv1FsYuOs5ErS+kpe0JgxaJQetCQet0Zy0tFz7bcNEDpcN0/Vw2TCmCWkbRpsSokxf3WPFdWlnLFvY7vUaT0+ZZ6wjjK/EGjqMy605XNu6EOUC8y2wdd99uJUu1+ajqqxT49p1FFNgviPFT0uzEa6+RR/LdYRnxr9ezOuFLL0IzJ0pemnnaBP1ckLJEAT2ER6B832EJ0lH1hVMlzP6eiFk79TafGcMOK4X0vkV1pys2yzpCI+MbaFJu2DNgUKv6GuAvidF9xqXfl3U7yQtTdKOBmIYkWXv2qZaLsWySx0Yd+hFucD8YMrY68HfES2x4WzHXgUjOIyL9SkZugDXB3zCMm2yF3wtPH4/pHCYgtxn8Jl21EXqQDtwCPST9CswP+HQ70DQrIuPftANebqVfCyPnpel9INupRerH+i+0q30wrEgsF34nembhNXps8LXwuP3PoVD23EoBx/5nTZIp+9bOrJigkl9h20lMD+fYnc0bkSz71CzXiLjHPizD3B/kOnOAvMG+F2/fbiVLv2uXlU2ELTq5tb473J7z/bc2ZVQD+pRYN6S0re78DfHyQElP2EEh+vsHvyu9TLrXy/bftf5IF0vAvM/UvRyPsivl/OGXrrwuzy0s7QF0ePPLl7rO0k6ol0UmN/I6HcxtbxTftfOGAA/3WYC47LTus1GAMM5VMZ2F377bfhd2n5aR6d7gZtmf34vRfcaN8J7b/yHPx/r2p7IQSWPK8YlcgwCz0eMS/suOjU/kttqVz3+rD7So2gRT3IIPI7bquXPWONWYP4kpz9jHWNI8mdo27RPxfmx3+AneyIHAa9l/8uUPRFrXu9WcgrMcYP+5zGvP2TM6/TbexSvYdCRsqjdLyhZbo3/Lrf3bM9pC6oOwv8CygXm49ePvW6JJ+7MO+C3APloi9kPLyiYBXyPnhHA0OYlrctoj+k7Ekb7idHzbyl7ItJvzqNsTtGLPsdiArSj3BP5IuYUPbatfi0wk0fAK/6e1q/pr4rcPvZEaG+EBx/+LnIMBt58xYrlK2gb73Fc162+3634y56IyCmy6P7PPRHtg2edyzi3aFoHDVolB62DDlrdOWlpufbbhu2MR4cN0/Vw2TDuiWgbRpvSgzJ97ot2hnsiYmd8+KYTMe08vumD8R/WvGr5N7of0RbPwNbddqSVLtfm3aqsU+Na18OarxccesxiI1x9iz6WtiHUy6x/vWz7MReDdL0IzGKKXi4G+fVy0dDLgpIhCOy5SOA8zpN1l464ZheYr0wZg2IneyB7p9bmO2MA/HSbCQzbTM/Jus1GAGPFNYUm7YI1Bwo9ly/osj93pOhe49Kvi/qd2EfaP33lgoxLrvME5htg/+450kqX9k/HK33Hl7oT6mHp8d+njPN21qn0d7OsUz3qxYxNWnoRmO9I0cv5Ano5b+hF+1dBYO87CZzHuFLdpSO2n8DcmdH+cc+/U/ZvR6+O2KQ1Z+k1q26zEcDQJmqfkHahFCSfr6H9o6+WZn+upOhe40Y0H0Bs0lMcsJb3rKDI4fusYJL/zdik1a56/Fl9RO9LEE/ORXkct9Xce+4ptk3bLesMX5Y9d/ZnKRNaZwx+EptkfFPL/iMO2ZPmddJnfawYzs9jXv9xY17vB69exctaV3U6Nin8rbXOT10/9tp7bJLrdYGhzdP2WNrSZY8FxrLHP+fQbSSD9BsrNkkb/R7EJvW51ej312JOSdpLZ7/e2ctCv359xn7dqdgk7Y3w4JMUm/TkK1ay7D13OjapY1pFYpPaB886l+mYPGnNGLRKDlozDlo9OWlpufbbhu3Uw2HDrByGPLFJ+ib9qv70Q2n/rNjkezz6pr9bwDe9B7FJPa9a/o3uR5zD/xC27hNHWulybW7tw3QyNin1sObrD+eMTeaJe9PHsmKTQqvfv17M2KSlF4H5s5yxySx6uWjoxYpNcq6yYpML4OE7Njmj+FNHD2X09Xohe6fW5pavp9vM8vV0f9dtNhLY/p+MbaFJu2DNgdbeDOeaNPvzzxn3Zrjf81rYKbF7XDv68b+u5elyjCXFvAXmcyljT48r0b0rxqzntkgH80qGLsDNA5+wsyhn/7Hw+H1O4UR95pyCI58ZR130tbmlYHcOQpJ+BaYv7nRJ+dp+bPC1fqDnJj0vcG466JDTGqtWP0iam4Qvx4LAduH3OeATlv2AexwWHr/PKxz6q3M5+MjvzNeeVXCWjqw9kaS+w7YSmFOONhkycCOaHxhs1ot3TUSP7/tTxlEH1i1EucCMp/S3cfwd0RK/hf0tVDCCQ7tzRsngWwcTGXSwc6Y6pX1lTucdEZ1a++y0JfhNQD7q29UmgsN1jsAwZnhG4Vljh/2ZMILbA5iaQ7eM50odhgx6EcyPYjz1xrrogk76+psydwPmAGQSmMccbdJ9HHNgFN3o99uN3+VxxVOkf0R9ZcBPX9meWwaxF94NXt2ov8AMQo4e/P3ko83yg/276yO6ELqR/vslT6k/Ga9H4Y0Aph94AwpvQLVb1AZPiOUbDHaPg72MTbGto/73/wFFdhb7bLYCAA==","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"member_count","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zVRTUsEMQx9bdo07axeBN3D6k1QWN1ZDzOIeHI/wIMo3sXfu7/KlxkcSKYvTV5e0h4S4hZiB6CHxEwHvQc/pWXA3q6htrPdF7HtZkOkhZGXkNEj6ZGBxQgy7Q+euPeEm4ln8uX1n7P4dY8QtCGYlgfgAuUYXEAIRniJNEMJaWAyWZEmeUqYHCr6wFsekwe19AzVIdYyxGQ+RB1Q8xq3DZKrN3lCWeNuCEYBUiKliNY8hGwrJCsrklSeqg0wL5aN5zKcleSJvTSpPPsYQksuTxdk10b2FzTXzA0UEy4U0aadvHM92QtEYqNvWalQvdh15JLO6ZNTHGeKIQolJNc+BhPTjktV8vkQH8YhPskpxoTf0XeZg/MbBW6nQz1jQbVk7YoLbtb8AfmbHrDNNj8gCX+ssdy8oGO7zsxhnmA0s85hZfe6xvc2CBm98WbE8rQ8/QFNHfJWPwIAAA==","debug_symbols":"1ZrdjsIgEIXfhWsvGGCA8VU2m039TZOmGq2bbIzvvui26NYG17ga5kaLnk4/CHCGSfdiNp/slh9lvVhtxfhtL6rVtGjKVR1a+8NITDZlVZXLj8ufhTx+gDrpt+uiPja3TbFpxFiOxLyehe9w76Ks5mLszGF0JSPtWiGhi1JAHNAaJbuo4ZKimtyA2JKCVmzDQy7F7yMB+gFmkGBaJUhtXkhtHhlpp7uRplsjDcpT10NtMM3sATuxV1L1mfFfmMNA/4Y+hrbPC+2eF9o/LzT9OXRQK3mXGu5SD+4JoOLsBmXsrVVmMfaVzg8ALwfUSNSprQSbnrHosNt1wqXvzVilGbMbxuzImN0yZneM2T1jduLLriVjdmDMzthXNWNf1Znvkd5Edo89dpP3WvXxeBQubZ/99WvVy8iuIc0O2rl4TPJnDkV0glec4TVneMMGnvQVPHKGt4zhMfOsJrXLY95ZjY91PvSmX9fCvLMar1SCPe+sJs1uMs8M6Mzu02LSptsGQt1U9zuad2khmQJh3qWFNHveaXOaPe/SQpo979JCkt0yPq7YzE04yZ65CSfZMzfhJHvuJpxiZ+yrlrGvWsa+ahn7qmXsq46xrzq2vnoIrc9iUxaTat6+SbPY1dOLF2uar/XPP0H8DQ==","brillig_names":["member_count"],"assert_messages":{"21":"Function member_count can only be called statically","18":"Not initialized","58":"Array index out of bounds","70":"attempt to add with overflow"}},{"name":"in_group","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"group_member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zVSTW9UMQwcx/lwEsoJqT0Ad8RC317eAyFOLN0TQj1X6qGq1HvVX9lf1XGyu5K9sZ3MjO23QCXsoXYEFqhmOpQv4K/QMmB/PiHbwQ63jO0wDYEmG4vQzTOR/i/Sd6YvNhDv5savu5PPA214+31GNlpdIGINUq18Az6gHMVliFSGl4gzzKG6NFuBSGg+XUTFjzEwaWUNlZBaAk+pLOOKFxuPof+LJzqnbbROSKSGXFIkGSoVxNpJ+RV9UqrUM1vFQGFYPeyD3I/Vk72RklYjheQdfjRotkSsI9IOv1aJUxon6YVVUvyIHMvteRDlPE2mi9FZHLV4slFbEb1TvSZe4p2s3E3R+tNvUgzUNbd35GjeyP/ZCDeRTLleBIu+m3uuKeGknr5nalefkyQXmPQ9vTrE3YSYram3tomp5c7lZuL5xh6s7PBITDU2+7L5oJOQDkbp+3GoF3xQLVq7BJdtzT8n/o3PqU2bTRLw2Rqfmz/opOtmHqYRBjPrHlay1x2e9qJEdOLrDVevV69vJf7ewc0CAAA=","debug_symbols":"5ZvRbuowDIbfpddcxEmcOLzK0dFUNpgqVWUCdqQj1HdfYDQtpUo3MaZYuYEWftzvj4rtpO2xeFmv3l+fqmaz3RfLP8ei3j6Xh2rb+L1juyhWu6quq9en4ceFOL2AOuv3b2Vz2t0fyt2hWIpFsW5e/Lv/7aaq18XS6nZxI3PKXoQObZAC4oRWS9FF9ZsuqJ2dEBsn4SI2/iBD8d9FAfoOZhCgL0oQSv8iNd4z0lZ1I+3mRhokuc6h0hhnJsBOTFLIMbP5EWY/0NfQp9D2caHpcaHdw0JL8eXQJzV8Sy2/pZ7MCSCMCPikZ6xCyAxm4NTC1PmKIa6joJXOTMVFLULKcf3/UQFMqwPx4NyW7uxSZ+ESs3BpsnBps3BJWbh0ObhUIguXkIVLmYXLLHofpbNwmUXvo7LofdT9vQ8ILYN4QDPt84tzOmNMN+Un1YckcYYmjtCOIbQWHKGBI7TkCD1b1f2KzBy0wR5aXB3hVu2zXac2AkwbXYNDi13+9ZvUXq/Bac2YHRmzG8bsljE7MWZ3fNlRMGYHxuySMTvjuoqJ53fSgZ1wzJ52nqFw0dRvmhG7+f08QyKwK5hhV93lUNTD6e15EmqAL7rki66YoKO5QUe+6IYtuk28G4hldpt2N0Dhjh8kPb7DxabdDZCUEXadeEV1PTvFxU71q67KqrHRtKfk0dbBpt2yxdnTnpLH2dOeksfZGbfKlPaUPM6edhGOsydehKPsiRfhKHvqRTjGzriuEuO6SozrKjGuq8S4rjrGddWxraut3/tX7qpyVa8vz6Vs3pvnwWMqh/9vn9948Qc=","brillig_names":["in_group"],"assert_messages":{"78":"Array index out of bounds","90":"attempt to add with overflow","42":"Storage slot 0 not allowed. Storage slots must start from 1.","22":"Function in_group can only be called statically","19":"Not initialized"}},{"name":"make_payment","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/31Vu64cRRCtfk71PHpmbwCWuHaAkBBojfciNCtARFy8TgiI+AEkcn6EH0AiJ+ATkJAgcUiICMktOXTkc6pn17Z05dV2b3dVV52q0121BwnO30jQJyIHCUkxSflI8CkYiu/X9yXrrd5+x/1tG+Ix3H2JetLTEWckHKmImL+RhPmxZMwn6T7ByfkxbZ/Q6wNzbXP/1RmmxxgO4lzfixv68lDkHSknZzFJjymUFUeEwcnBBcfl4CEs40Gyn1Y/jRCNflx9Gk0JRfD127j5Jw4UUnFehl5yGbB0MgKyjjMgP5Z5g3Qz0CrRZm79gu3M7WLgXM4ULrvVDxhzXaXXvRx7MNlHeggPxanEvXy5ugoag3pEEmI/r26u15JrJKESt2GEQhwVk1bT1W2YjvQoojxJ3aIM8RxltLC4rB7COIOOFiRWeTb5bIlc6OAvFLKAiThMIGEaK9x/f3HvkJRMdF8vJNRXJDQ0kgCMAaNOIKHs5QeQUHr6ei51Lz+ubrLMvVlY/hNynO7I0WghCZPppm2YDv5+kumcOrD4OAP0DKYRDOEUcf8NDqscG/FvvoRpS7/SUYKjTEfJHHGZPYSshBwq0mq+FZSqKVkiPl68pVYmEkFkGjKIzGNEsD9LPBMZzxjRiNTV8APMCNmihVA3ImNuRP5iRPLO/xM8rl9Xl1ssgAypj6uL+VpiTmAs4dlEzSO2nSIGHRPsfpPEGLxJq8QuU/p7kzJ7IEnHULKFwmXnIcwJiRsMuPBTMnl6M/G8Jc/E89ABtBsHuP9DBrrnMx5bIn9aItT9LcNe/np0zeoTmhmZ3bm2u9dqG8IO2CNRHUo6lERa/2m02hFjrqTVpe4Lirp2FaGErmLuSN2/aEI4D2cMhBQSHJY5xflz2arASnYhyLKD0f+yo9ER7jSgO4rXiD7mHqClJWmVtcO8KwuuazFIJaQyxGctRLQFMKm8SJQAS77AMsd5MdiF0ITdEXZ3BcMXcrXB1jtgCbP4K8xXhT1nZ7CVsBXty6XWvla/oA4qCxGdh9WkhC13wSph3XKBjW+H1TOshghYjYR97wKLfhHZBI9Og+YBBzJcdTjzvnZ79wHcBU1799mR95QckERxEze2KBMMQKD27+L59trzbwc/9rfTt3HuBO5T7R3DgMEAuEGV22Rbr6oDtwXoZe8+vHEBHgn86Cj3nt57+hI4YWZ09QYAAA==","debug_symbols":"5Z3bThs7FIbfJddceHn5sMyrbG1V0NIqEgoV0C1tobx7J4ExA5mx22QmrB/ftAR8+P5R7H/5NH5afbu5/vXjy3rz/e5hdfnP0+r27uvV4/pu03162l6sru/Xt7frH1+Gv16Z3T/k9+kffl5tdh8fHq/uH1eX5mJ1s/nW/d/l/b6+vVldRre9OEiWOL4kTD7mpOT9SFpnTV9q92PKqVMcSRySpZfEoatkmPjfixWFE5jJkHtJSYbdGanjKU86cv+kU+1Jk5XUK2Tny8xCvk8s1tj3zDILc/eg30Lvik6LFW3NckXTckXbsaK98eElkzdSq4ByewyD8iONfUt8T01Jclqbwli53pnc0NNrK2Ci8dRZ5uAbZdNeJTeh0jWh0jehMjShMjahUppQmVpQyaYJldSEyiZiH24i9mHXhMomYh8+PfYh42yuYEAzrvMPR1Ih9ABB+LXIjmUHHRGhBRE6AUI7gwhNiNB1V0++Bh38K7R5U8Nh6q6361MHQ2FbnPny0ff9b/ejbN/OfDkGZnfA7B6YPQCzR2B2AWZPuOzeALMTMDuwr3rl/bu4zC7+Pbvutip5qbL7MbxjD+dvq2IyO1OFnftFSO+Gw9v9IDQQLrrFRWcQdB8O0D0uesBFr0ZhZN6g7/Kkv88TzRF5xrsQ8pTzxMpjBZiti7YJldyESteESt+EytCEytiESmlCZWpBpZgmVDYR+0gTsY+cHvucfxlIHCK0R4QOiND1uEFk3iHvbLOZIsDsCZc9GWB2Ama3wOwMzO6A2T0wewBmB/bVLvTVDV9aJiSju6cprhN28d/Z4edasurm/YHZAzB7BGE/XLXqKsNlJwPMXg8l0xv2fSY+JtN4j8bUC/ccKwNYK7EfFdtE72dlaPwQ/aw1hMVriIvXIIvXkJauYfxo+aw10OI12MVr4MVrWLxN28Xb9MTBYk45tnSUtuhT1jRxsvjTyZQ2ZKYmZE4cLv50MqkNmbYNmdyGTNeGTN+GzDaiIG4jCuI2oiA+PQo6/0I7OQNJTZDUFpK6HkHYKvVHrRk5hwzvkeEDMnxEhhdk+AQM7w0yPCHDW2R4ZIf1yvv54q4Mr7u3Ke/KCOfvbf5ipZeSy0V3A6fBaOl5uBQImt5C09c7HD5YMg/umEz+mEzjXYrzeZnNRXuQKR6TSY7JlI7INHFCOZjctwbLB5nomEz2mEx8TKbxb0Rgzpm84E/sTBxI/XQyQxsyYxsypQ2ZqQmZE6dSP51MakOmbUMmtyHTtSGzjShITo+CPmCNRiIktUBSJ0TqidOxIeYZppBchVryRGD3hTODliPPVdT7+1CbE7EuX1NmB8fSx+dEAru+6MChcqlZ6OaI+8TdjOsw8R4+6oZP/aMP1hzcIpdEN7zYEnxSDW9NyvD0fvbbGoMMT8jwFhled1dZgXfI8B4ZPiDD63bYCrxuh63AIzssITssITssITssKR+MBHmFr1whnVzmSG6wUNwr1W3H00r38LrtuAKv244r8MoHvEV4q3yjXWnTkbW6N9oJ5zV/cfEAXvdGO7G2BK97o51kR+vgpWIK/DrnzZEPlDrcjW3W6t73XoHXvR+yAq9733sFXve+9wo88E5Uy7rtuAKv3I7L8MrtuAyv3Y6L8MgOy8gOy8gOy8gOy8gOy8gO65S/ZLk44HXK331aHPBOnCBWA18c8Drd71meccDrdL+VudK6db+WuQKv+76DCrzuCw/K8F73C7Er8LqvPKjA67bjCjzwq8itV27HZXjtdlyER3ZYj+ywHtlhPbLDBmSHDcgOO3HafMlLr+cb8H7AZePzDXg/4Lrx+Qa8E28BUAM/34C3frX6Bysttu4EDF+/bF4zPCHDW2R4RobXbccVeOV2XIZXbsdleO12XIRHdtiI7LCC7LCC7LCC7LAC67Db7tN/V/frq+vbm4cuz+6PvzZfH9d3m5ePj///fP5Ll/g3","brillig_names":["make_payment"],"assert_messages":{"70":"Creditor is not in group","189":"Storage slot 0 not allowed. Storage slots must start from 1.","282":"attempt to add with overflow","209":"Array index out of bounds","113":"Debtor is not in group","238":"attempt to add with overflow","142":"Storage slot 0 not allowed. Storage slots must start from 1.","217":"attempt to add with overflow","249":"Array index out of bounds","86":"Storage slot 0 not allowed. Storage slots must start from 1.","173":"attempt to subtract with overflow","260":"attempt to add with overflow","21":"Not initialized","271":"Array index out of bounds","41":"Storage slot 0 not allowed. Storage slots must start from 1.","169":"Insufficient balance, or paying more than is owed","227":"Array index out of bounds"}},{"name":"balance","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/02SvY4VMQyFj+P82Alsh7gF0CNd2LnNDBRU3P1pEKLiAZAoEBI94gn3qTjO7EWMlEzsON+xnSxQSSeo3QMLNDdOsNfgZxyNv48vUe1s5y/hO+8DiUM2bkK38GTONyicb1HfcvNqA6l3t3HoLoJfTeac/cOF7xx9gYh3SHd7AzxjvEQyIp3mAXk3VfsKZFLRsYhKLHOis/uaCknqiavqywyJTeMyjU85VB7VQnUsqFoCWS/I+h+SzjqIHLRG4srH9I+g2T9aDVIQSUPuqDVTWlBYipco5d2lFBWnUAkhx6SsMxu2euruydNpVMuhWFhWO+KmQ1t3sj7Dj7hf5bFQi+72tkpjZIkm6HVsvkBt3KvV8vtoct4TVNEnJOkg6StGZMX7cVNePZLluLHvvLyCvQWz9KZrMp3Z02xuV5wtEN92BHOlukWem5haHUyqktcY8yP8P8lUK0f82SKRIpSDUeM0F/6UB9yy9ecQ69bjqfE3n1rfx/7UCPxtncctDgzKDbMwyzSTmY0wneps1K+TKIkhfL3h8HB4+AsCdAMW6QIAAA==","debug_symbols":"5Zttb+IwDMe/S1/zIs6jzVc5nSbYYKqEygTspBPiu1/KtWlXemETlylW3kAL/9o/R43tRO25etms31+f6ma7P1bLH+dqt39enep948/Ol0W1PtS7Xf36NP65Eu0H6Kv++LZq2tPjaXU4VUuxqDbNi//2127r3aZaOn1Z3MhIuU5IxgUpGDOj1VL0Vv0hBTW5GbElCZ3Yeidj8c9FBeYBZhCgOyUIpb+R2j4y0k71I033RhokUh+h0ibOjGB6MUohp8zuvzD7gf4I3ZrGdKYpmWkp0pmGT5tu1fJLavUl9WxOAK36uxs02nioEp3sxJJguK0kXR2Y1A5sagcutQNM7YASO1AitQNI7UCmdqBSO0g9k1XqmaxSz2T1j5lMtndgJNzJ6xDaIDtK6w7mirPpsy4QjlDsnF2jReivaGg+FMC8OlQXcRMlFhEllRClFkVECUVEKYuIUhURpS4iSlNElLaIKIvofXQRvY8uovcxj/c+ILQMDkY083F+cmvH2h7AohpMorhCA0doyRFacYTWHKENR+j7VV3dhbZmgBYfPNyqfbbr1VbAsE8xuxVvnOnzrz/Esbhld4zZkTE78WW3gjE7MGaXjNkVY3bNmN0wZmdcV23m+R11YEczYXd55xkMz074Qztl//48gyKwj0zPsgPpYNovSEer0Osy1GnO8IYzPOPpinm3Yxie5jKop08vYd7tGEoZYc89TdLAjnExqWErTTk1DTTv3i1aDzDv3i3OnnfvFmfPu3eLs+e9JxJnz3tPJM6edxGOslPmRTjKnnkRjrIzXqsQ47pKjOsqMa6rxLiuEuO6SozrKrGtqxd/9mt1qFfr3aZ752j73jyPXkE6/X77+48X/wE=","brillig_names":["balance"],"assert_messages":{"98":"attempt to add with overflow","55":"Storage slot 0 not allowed. Storage slots must start from 1.","20":"Not initialized","23":"Function balance can only be called statically","86":"Array index out of bounds"}},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"],"assert_messages":{"1341":"attempt to add with overflow","1012":"attempt to add with overflow","482":"Array index out of bounds","1439":"Array index out of bounds","787":"Index out of bounds","592":"Array index out of bounds","1427":"attempt to add with overflow","964":"Array index out of bounds","580":"attempt to add with overflow","641":"Array index out of bounds","1269":"Array index out of bounds","1074":"Array index out of bounds","751":"Array index out of bounds","1001":"Array index out of bounds","1385":"attempt to add with overflow","1507":"attempt to add with overflow","160":"attempt to add with overflow","1312":"Array index out of bounds","739":"attempt to add with overflow","983":"Array index out of bounds","1300":"attempt to add with overflow","977":"attempt to add with overflow","142":"Array index out of bounds","800":"Array index out of bounds","538":"attempt to add with overflow","697":"attempt to add with overflow","374":"Array index out of bounds","1197":"invalid admin","813":"attempt to add with overflow","1447":"Array index out of bounds","228":"Args length exceeds maximum","490":"Array index out of bounds","1246":"Array index out of bounds","1374":"Array index out of bounds","600":"Array index out of bounds","149":"Array index out of bounds","527":"Array index out of bounds","1356":"Array index out of bounds","649":"Array index out of bounds","1277":"attempt to add with overflow","1082":"Array index out of bounds","509":"Array index out of bounds","948":"Array index out of bounds","503":"attempt to add with overflow","759":"Array index out of bounds","107":"attempt to add with overflow","936":"attempt to add with overflow","1320":"Array index out of bounds","686":"Array index out of bounds","668":"Array index out of bounds","662":"attempt to add with overflow","138":"attempt to add with overflow","1095":"attempt to add with overflow","1455":"Array index out of bounds","1193":"Initializer address is not the contract deployer","1254":"attempt to add with overflow","1187":"Initialization hash does not match","608":"Array index out of bounds","474":"Array index out of bounds","1474":"attempt to add with overflow","767":"Array index out of bounds","956":"Array index out of bounds","633":"Array index out of bounds","1468":"attempt to add with overflow","1328":"Array index out of bounds","621":"attempt to add with overflow","1066":"Array index out of bounds","1054":"attempt to add with overflow","792":"Array index out of bounds","780":"attempt to add with overflow","1292":"Array index out of bounds","902":"Array index out of bounds","1219":"Storage slot 0 not allowed. Storage slots must start from 1."}}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"group_members","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"group_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"member_count","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"PublicGroups::balance_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"PublicGroups::balance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"approve","type":{"kind":"boolean"}}],"kind":"struct","path":"PublicGroups::add_to_group_parameters"}}],"kind":"struct","path":"PublicGroups::add_to_group_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"group_member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"PublicGroups::in_group_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"PublicGroups::in_group_abi"},{"fields":[{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"PublicGroups::admin_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"PublicGroups::constructor_parameters"}}],"kind":"struct","path":"PublicGroups::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"PublicGroups::set_balance_parameters"}}],"kind":"struct","path":"PublicGroups::set_balance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"PublicGroups::make_payment_parameters"}}],"kind":"struct","path":"PublicGroups::make_payment_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"approve","type":{"kind":"boolean"}}],"kind":"struct","path":"PublicGroups::remove_from_group_parameters"}}],"kind":"struct","path":"PublicGroups::remove_from_group_abi"},{"fields":[{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"PublicGroups::member_count_abi"}]}},"file_map":{"125":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"138":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"155":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"156":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    point::Point, traits::Hash, hash::{sha256_to_field, poseidon2_hash_with_separator}\n};\nuse crate::oracle::logs_traits::ToBytesForUnencryptedLog;\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (n as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        poseidon2_hash_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x1cce4dbf69f14c44865919991ee1057922e34d7310ba237d71759aa422621ca9);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"162":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{\n    header::Header, address::AztecAddress, constants::CANONICAL_KEY_REGISTRY_ADDRESS,\n    storage::map::derive_storage_slot_in_map\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys, constants::NULLIFIER_INDEX},\n    state_vars::{public_mutable::PublicMutable, map::Map}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n"},"171":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n\n"},"180":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"221":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n\n"},"230":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"29":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n"},"293":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"295":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"296":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"298":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"299":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"302":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"303":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"311":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"343":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    protocol_types::{\n    traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    point::{Point, POINT_LENGTH}\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul};\nuse std::hash::from_field_unsafe;\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.value);\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> ValueNoteHidingPoint {\n        ValueNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    /// The following method needed to be implemented because the note is passed as an argument to a contract function\n    /// --> the serialize method is called by aztec-nr when computing an arguments hash.\n    /// Note that when the note is about to be encrypted and emitted as a log the to_be_bytes function auto-implemented\n    /// by aztec macros is called instead.\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n\nstruct ValueNoteHidingPoint {\n  inner: Point\n}\n\nimpl ValueNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_value(&mut self, value: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(value.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for ValueNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n"},"57":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"74":{"path":"/Users/niallcheetham/dev/aztec/publicgroups/PublicGroupsRoot/publicgroups/src/main.nr","source":"// mod test;\n\n//this will be a little test to make public groups in noir\n\n\ncontract PublicGroups {\n\n    use dep::aztec::{prelude::{Map, PublicMutable, AztecAddress}};\n    use dep::std::hash::pedersen_hash;\n\n\n    #[aztec(storage)]\n    struct Storage {\n        admin: PublicMutable<AztecAddress>,\n        group_members: Map<AztecAddress, PublicMutable<bool>>,\n        group_balances: Map<Field, PublicMutable<Field>>,\n        member_count: PublicMutable<u64>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.group_members.at(admin).write(true);\n        storage.member_count.write(1);\n    }\n\n    //helper functions to read variables when testing\n\n    //read the admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    //read the group members\n    #[aztec(public)]\n    #[aztec(view)]\n    fn in_group(group_member: AztecAddress) -> bool {\n        storage.group_members.at(group_member).read()\n    }\n\n\n    //read the member count\n    #[aztec(public)]\n    #[aztec(view)]\n    fn member_count() -> u64 {\n        storage.member_count.read()\n    }\n\n    //read the balance between two addresses\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance(creditor: AztecAddress, debtor: AztecAddress) -> Field {\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        storage.group_balances.at(key).read()\n    }\n\n    //functional methods\n\n     #[aztec(public)]\n    fn add_to_group(member: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        storage.group_members.at(member).write(approve);\n        if (approve) {\n            storage.member_count.write(storage.member_count.read() + 1);\n        }\n    }\n\n     #[aztec(public)]\n    fn remove_from_group(member: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        storage.group_members.at(member).write(approve);\n        if (approve) {\n            storage.member_count.write(storage.member_count.read() - 1);\n        }\n    }\n\n    //this set balances but only between two people\n    #[aztec(public)]\n    fn set_balance(creditor: AztecAddress, debtor: AztecAddress, amount: Field) {\n        assert(creditor == context.msg_sender(), \"cannot adjust someone elses balances\");\n        assert(storage.group_members.at(creditor).read() == true, \"Creditor is not in group\");\n        assert(storage.group_members.at(debtor).read() == true, \"Debtor is not in group\");\n\n        //cant store the addresses in a tuple in storage so hash them together,\n        //easy to know who owes who as hash a,b is different from hash b,a\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance = storage.group_balances.at(pedersen_hash([creditor.to_field(), debtor.to_field()])).read();\n        let amount_to_write = amount + balance;\n        storage.group_balances.at(key).write(amount_to_write);\n\n        //adjust the balances\n        //balance between creditor and debtor\n        let creditor_debtor_hash = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance_creditor_debtor = storage.group_balances.at(creditor_debtor_hash).read() as u64;\n\n        //balance between debtor and creditor\n        let debtor_creditor_hash = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let balance_debtor_creditor = storage.group_balances.at(debtor_creditor_hash).read() as u64;\n\n        //if the balance is greater than 0, then the creditor owes the debtor that amount\n        if (balance_creditor_debtor > balance_debtor_creditor) {\n            let difference = balance_creditor_debtor - balance_debtor_creditor;\n            storage.group_balances.at(creditor_debtor_hash).write(difference.to_field());\n            storage.group_balances.at(debtor_creditor_hash).write(0.to_field());\n        }\n\n        //if the balance is less than 0, then the debtor owes the creditor that amount\n        if (balance_debtor_creditor > balance_creditor_debtor) {\n            let difference = balance_debtor_creditor - balance_creditor_debtor;\n            storage.group_balances.at(debtor_creditor_hash).write(difference.to_field());\n            storage.group_balances.at(creditor_debtor_hash).write(0.to_field());\n        }\n\n        if (balance_creditor_debtor == balance_debtor_creditor) {\n            storage.group_balances.at(creditor_debtor_hash).write(0.to_field());\n            storage.group_balances.at(debtor_creditor_hash).write(0.to_field());\n            //this is not setting them to 0\n        }\n        //if the balance is 0, then the creditor and debtor are even\n        //the values should never go below 0 as as you are subtracting a larger number from a smaller one.\n    }\n\n    #[aztec(public)]\n    fn make_payment(creditor: AztecAddress, debtor: AztecAddress, amount: u64) {\n        assert(storage.group_members.at(creditor).read() == true, \"Creditor is not in group\");\n        assert(storage.group_members.at(debtor).read() == true, \"Debtor is not in group\");\n        //make sure the payment is less than  or equal to the balance\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance = storage.group_balances.at(key).read() as u64;\n        assert(balance >= amount, \"Insufficient balance, or paying more than is owed\");\n\n        //subtract the amount from the creditor\n        let amount_to_write = balance - amount;\n        storage.group_balances.at(key).write(amount_to_write.to_field());\n    }\n\n    \n}\n"},"76":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/address-note/src/address_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: Field = 3;\n// ADDRESS_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[aztec(note)]\nstruct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"},"82":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"97":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\nuse crate::hash::ArgsHasher;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    args_hash: Option<Field>\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs, args_hash: Option::none() }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            let mut hasher = ArgsHasher::new();\n\n            // TODO: this should be replaced with the compile-time calldata size.\n            for i in 0..self.inputs.calldata_length as u32 {\n                let argn: [Field; 1] = calldata_copy((2 + i) as u32, 1);\n                hasher.add(argn[0]);\n            }\n\n            self.args_hash = Option::some(hasher.hash());\n        }\n\n        self.args_hash.unwrap()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"}}}