{"transpiled":true,"noir_version":"0.34.0+e0185e75e65df08b5334856f8bf63fa3aed7049a","name":"PublicGroups","functions":[{"name":"set_balance","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["set_balance"],"assert_messages":{"24":"cannot adjust someone elses balances","701":"Array index out of bounds","634":"Array index out of bounds","88":"Storage slot 0 not allowed. Storage slots must start from 1.","354":"attempt to subtract with overflow","479":"Array index out of bounds","723":"Array index out of bounds","525":"Array index out of bounds","510":"attempt to add with overflow","571":"Array index out of bounds","114":"Debtor is not in group","303":"attempt to subtract with overflow","44":"Storage slot 0 not allowed. Storage slots must start from 1.","370":"Storage slot 0 not allowed. Storage slots must start from 1.","556":"attempt to add with overflow","623":"attempt to add with overflow","690":"attempt to add with overflow","224":"Storage slot 0 not allowed. Storage slots must start from 1.","669":"attempt to add with overflow","602":"attempt to add with overflow","20":"Not initialized","712":"attempt to add with overflow","645":"attempt to add with overflow","72":"Creditor is not in group","191":"Storage slot 0 not allowed. Storage slots must start from 1.","319":"Storage slot 0 not allowed. Storage slots must start from 1.","392":"Storage slot 0 not allowed. Storage slots must start from 1.","438":"Storage slot 0 not allowed. Storage slots must start from 1.","502":"Array index out of bounds","487":"attempt to add with overflow","548":"Array index out of bounds","417":"Storage slot 0 not allowed. Storage slots must start from 1.","612":"Array index out of bounds","155":"Storage slot 0 not allowed. Storage slots must start from 1.","679":"Array index out of bounds","341":"Storage slot 0 not allowed. Storage slots must start from 1.","274":"Storage slot 0 not allowed. Storage slots must start from 1.","533":"attempt to add with overflow","594":"Array index out of bounds","661":"Array index out of bounds","734":"attempt to add with overflow","579":"attempt to add with overflow"}},{"name":"remove_from_group","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"approve","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/21UvYqUMRS9+W4mucmXfFO6xSoWNsLo7hR+g8IW4rpWCgviA1j4AILgK6wvYCmW9oIvYLWIrb1gIYK92HhOMoOLOJDMl597zrnnJjkUdcNa1B6IHIr6iE7suuBnaBF/9y5LsGM7PuXccW8yoDkunNhJWzjprS9sECW64VaP/r4sNlwNN7G45C7SicyNRBEzD2oXR/7C6FCc+H+ngihjrjShrU9HO9EJLSPKpSwuJ7shcg2MrhHmLQW2IdWhAZocOnUI0zSAxUZAo6VMM9IsKa5knUVjMsy4EYCfxVZya3YZDmkcCvqS6uxqvkoZMUvIsWDjkRQyQ/EQ56ZLlbulNFLKyUOZpdR5iBWjOuBrUdt8pcTpod8mhTjBgkxALwoOF30GxyPJ5NiXEDzUQtkp1Fri2gfJK3mMjycSVnJ2wWSoJHzgMDQxPZcwC2AGRYtwIyH+KeBywvbgA6DeCgx5NjvrAZCnPuns1PbFm4cOH/EV4ZZ3ccBc9BPHiuDnoluxPnb0Fw2dZXpFV1/S41Ycwidq6FWzC44ZymO7AmZjkTC1aCMY7aI1aemu23oH4LMDkGYshGCeRjBeiawNmSE26IxSIvVCGaUAr1RIey2VstuWVqZcZlf0TptCowl51Am9eux/I76fOGWG9IrknuReb++iAkk8STwPy7t+WDYojemaZTLPO/MN12fBANV+1DKKEzplJGVkWd5LaJTtLkWWDZQGv0LJu7PXtOMQ/XWyzlInXK+JUiZIsWkJsI+y3OabhyX6pU2zm2rLt/aXQW2sILcasf+TxJ5v5fHDxcBZCDQxOGwPtUwt6YnhO2djIdOXzoSk7T9JI0CnriCiLJXpx9HAG411+drrMg9Txs3lRd04UwsjhAVAUdt3zv8AnNpiJb83PA4LRz8NHq7bR6q8MeYtXxJn2TIfN/y1xy331h83AP6yjHBjwAi60YzDRRsOZjZymMCeVvJz7RSIJD7YyN753vkf4Xskb3QFAAA=","debug_symbols":"5Z3dbts6DMffJde9EEl9kH2Vg4Mh3dohQJAObXeAg6LvPqeLbLd2zDlNMxK+aZ2Wcn60ZP1FUbaeV99ub35+/7LZ3d0/rq7/eV5t77+unzb3u+bT88vV6uZhs91uvn/p/3kV9j8gvdo//ljv9h8fn9YPT6vrcLW63X1rfjdl7zbb29V1KS//Xq0gz7Ius6x5lrXMscYwyxpmWeMsa5plHWdZz6pLnFWXOKsucVZd4p/X5dXATKgcDCWV1hQSj9hGDPWszaF01iGMWGdBOFjn5lveWDfUFD5ADQHiwRICxYtyw0eudqF6tUW72oAs1UeKSaFmSNWaMeCAGs9C3Vzst9j7U9PnnTp+3qnT5516tGfAGPBQCJtWqLXvnNpvkM4YmEask0i1zgGy0lJSSfWWbw550FKKa3p2TS+e6WNwTQ+u6dE1Pbmmj67pk2t66z0mx5ae03v6ZLzdcztubg7zgP7y7Z5DS0+g0DcnbMfPELqWQ40ne/rkmj67pj8yxsTc0sc4TR8p1zF4pKLxlFDqhSmBBzFd0keNsbyLupPML5PDCWWOjEu4BqmYQlLCFWhj/NzzvcSxmku1mkG6ekORsfMmbsPZHLuYkyCOWnchey9ARXn1EhfhJS3Cy7gIL9MivMyL8LIswktehJeyBC9LWISXixj7lEWMfcoixj4lfthLCBG7uEwUP/8wY5FzDa3yPrzrhXp76OQROnuELh6h9XEDiAKNsZ0PwJLefMMIDXVzDSRa5pOkcsQQezMNuGdnuDh7pJY9a+wZUq3M5pDez0vweBtP0s4XZCjnneU549wsF9f07JpePNNLcE0PrunRNT25po+u6ZNreuv9/WQmEYLx23Y6lQjh8vftrHwWldp2gDi/H2U2Y3Lf+Mk3fvaDLzTEL77x2Te+PlJG6uPvC0E4pRCcUghPKUSnFDrSh7VV05SHvxfmA1I774G95dC1HqFcHP+MkT6MP2KBmWvjxQLKzBCHdgV4LgoOU+JqTBKHOGALB23hkC2caAsn2cLJtnCKLRy2hSOmcMhWr0y2emWy1SuTrV6ZbPXKZKtXPvKgjp3hmtTrkjGUIb4Yx2ecwj/yqI4ZfGxbWkbgIT74xkff+OQbP/rGT77xs29847MMGr5x1dXwjauugp98q27yrbrJt+om36qbjKsuZO7wtVeESGxJJPbzFdVZ4xo94ewrvnGN1vCtZwIUfOuR8TR+tr76aXodRba+jqJ9X1PiOAzss/H1T4w4iR+tr2KRDp81laBY85tCZZjyy8bXSylLdrLxxckavvHVyRq+8eVqGr7x9ckKfjG+QFnDN67RGr7vtY7FukYr+OY1ehrft+oW36pbfKtu8a26xbfqsm/VZf0J6L/7LOJ0ypujcfzplDcn2/jK/Cln3/jFNz77xhfX+BJ84xt/Bl3DR9/4xlVXwzeuuhq+b9UV36orvlVXfKuuGFfdc6a8MRjX6OmsJQbr74lR8I1rtIZvPTJW8K1v+DGZ8sZgfMeP6ZQ3BuNbfkynvDEYf4O9gg/GN/04Z8YewfgeIdMTkAjGNwnR8F3vloBHnq93g298nxAN37hGa/jWNVrBt67RCr51jZ7GR/MaPY3vW3XRt+qib9VF36qLvlUXHavuS/Pxv/XDZn2zvT3sA333c/e1ty300/8/fv+nMf4F","brillig_names":["remove_from_group"],"assert_messages":{"179":"attempt to add with overflow","77":"Storage slot 0 not allowed. Storage slots must start from 1.","195":"Array index out of bounds","214":"Array index out of bounds","113":"attempt to subtract with overflow","158":"attempt to add with overflow","203":"attempt to add with overflow","168":"Array index out of bounds","225":"attempt to add with overflow","60":"caller is not admin","150":"Array index out of bounds","35":"Not initialized"}},{"name":"in_group","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"group_member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zVSPU8kMQx9jvPhJMdVJ0Fxd/3pFphtZgQSFctSgUSLRIGQ6BH/kl/Fc2Z3JXvtJH7v2Z4JKmELtXtggmqmQ/kH/gotA3b7B9l2tntibrvVEGiy8BK6+Emkv0O64PHJAuLt9/7cnfwdaMPbzRHZaHWCiDVItXIO/EK5F5chUpmeIq5pDnUGostjlbJ0EpXIMAabYWUOlZBaAqNUpvHELxvD0B/igc5pG60TEqkhl0RQQaWCWDsp/6M7pbM5UfCoDhBP++CtDGvoM3ojG61GasgbLA2aLRFmj7TB9SxxVcUh+sUsKf5GjuXpOINyHCSPi9FZHHfxYONuRvQm9ZJ4iW+yci1F65W/pBgoBUr7QY7mPTyuPXAJyXTrXVj0tbxwQwkH9fQ9U7v6iCS5wKQ/6dUhng9jGK2pt7aIqeXOvWbi+bJerWzwRkw1Nvu5+IyTkA5G6dsR1BMWVIvWTsE9W/MviX/jS2qrrU0S8MMay80LOum6madppMHMuqeV7HWD960oEZ34csHZ19nXN4Bj4r7IAgAA","debug_symbols":"5ZvRbuIwEEX/Jc88eOyxPcOvrFZVaKGKFIUK6EorlH9fp0sS2ERxK5bKI7+AA5fJuZbtGZPkXLxsN++vT1Wz2x+L9Y9zUe+fy1O1b8LRuV0Vm0NV19Xr0/XHhepewHzoj29l0x0eT+XhVKzVqtg2L+E9/HZX1dti7X27msjY+IuQrR+kYGlGi1r1UUOTR7VSM2rHGi5qF85yo/65KgDvoAYFeFGCMvit3Pae3vam722O9TZo4t6jQRuhJrC9mrTSE2r3X6hDZ99id6H940LT40Lzw0Jr9enQnRq+pNZfUs+uDGE0DZPHOIpYhWF9cFdOPc6NWNuDAI9hNfNcXEvDVHA4jlcDOKsep/vV4Nb84RKzcGmzcOmycOmzcElZuOQcXBqVhUvIwqXOwmUWtY/BLFxmUfuYLGofc3/tAwr1cALmiM9P7umcc/2un8wYMrQ7aJIIzQKhUUmEBonQWiJ0PKuTj0E7O0KrmzNM1Za5VzsFrl3+F8562y/AoUntP//CIYqmt6LpnWh6L5qeRNOzZHqrRNODaHotmj719Z5woCc7oU98zaHhmmRougn99685pAZ6AzF6019stDiOGxM2e4HdKcHsIJhdS2G3bsKOgtmtXHafenWwuMb7xKsDGm6usYSTO0l84tUBab1En/hOnBSP9BRRs8F+RrHxZuIVJdcSPvE6LkKf+L49Qp/4vj1CL7qG9onv25fpKfHMHKFPPTMv06eemZfpk8/Mi/Sicy2JzrUkOteS6FxLonMtic61LDjXtuHwV3moyk29vTwqsntvnq+eHDn9fvv7TRD/AQ==","brillig_names":["in_group"],"assert_messages":{"77":"Array index out of bounds","42":"Storage slot 0 not allowed. Storage slots must start from 1.","89":"attempt to add with overflow","22":"Function in_group can only be called statically","19":"Not initialized"}},{"name":"member_count","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWRMU8DMQyFX+LEcdLCggQdChMSQir0uuQEEhNtEQNCsCP+b38Vz3fipORix/787AyQEHcQOwIDJGZu0HvwU64M2Os11Pa2/6Jt+3khcoWRl5DRPemRjuUIkg5HDzx4wM3Emfby8s8sfj0gBG0IpuUBuEB5Cy4gBKN5ieRmZxyBrMVTcnXqpmIIEhKPKWqHloGu2mMtPSZz/bWj5g1uGyRX5+9QNrjrwVhbyoTRmnvItkaysiak8lStwzxZth5Ld1bCE2tpUnnyDgSzlqBL0rWR/ozmctl8Mdm5YJvG8c7JZE8QiY17y0qF6smuI5d0zj054jgjehRKSK59DCamC85TyfMmPoxNfJIpxoDf0ceYg/MteYt+qGdMqJasXXG2zZq/HX/T27V5zW9H4I81ppsnLFhuYeZmnsxoZgs3K6vXDb53QUj0wtsRq9Pq9AfrUTk0OgIAAA==","debug_symbols":"1ZrbbsIwDIbfJddcxHGcOLzKNE3lqEpVQRwmTYh3X9hoORQ1QwwU30ACP+Zr1Ph3rO7UZDrazj/KerZYq+HbTlWLcbEpF3Wc7fYDNVqVVVXOP84/VvrwAuZHv14W9WG63hSrjRrqgZrWk/gefzsrq6kaer8fdGQB/VEYyLdSIL6htUY3UeMwnNRa31C7YOCodvFfLtTvAwX4ADVosEclaLQv5baPrLbHZrVDarXBcGiuES0lqBmoUbPRpkNN/0IdF/sS+xDaPS+0f15ofl7o8OfQUW30XWq4S30zMwBpavAJkzvNtWIdTmJgvKGmEBq10+AS9yx5apJPHPL1PWtQNL0VTU+i6Z1oei+ankXTB8n0qEXTg2h60V6LuWdMti09U4c+813L7fkjDt01vX39rmXd0iMk6AG9b88hfKLHeMo40INoeiOaHuXQB+zQW9H0JJo+9zqnN99T5nUOt001YtvpIFHmdQ4b00efeZ2ToM+8p8A6nOg5oQ5om4wQG5XYuVYruSqizDsQCfrM6+kEfeYdiAR95h2IBL3os4zL3Zn76XN35n763J25nz57Z+6lF+21TrTXOtFe60R7rRPttU6013rBXruP089iVRajanp8wGW2rcdnz7tsvpa/30TxNw==","brillig_names":["member_count"],"assert_messages":{"21":"Function member_count can only be called statically","18":"Not initialized","69":"attempt to add with overflow","57":"Array index out of bounds"}},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"],"assert_messages":{"576":"Storage slot 0 not allowed. Storage slots must start from 1.","701":"Array index out of bounds","442":"Array index out of bounds","311":"Array index out of bounds","372":"attempt to add with overflow","820":"Array index out of bounds","619":"Array index out of bounds","747":"Array index out of bounds","549":"Initializer address is not the contract deployer","543":"Initialization hash does not match","153":"attempt to add with overflow","342":"Array index out of bounds","665":"Array index out of bounds","729":"Array index out of bounds","714":"attempt to add with overflow","650":"attempt to add with overflow","455":"attempt to add with overflow","135":"Array index out of bounds","693":"Array index out of bounds","434":"Array index out of bounds","303":"Array index out of bounds","812":"Array index out of bounds","361":"Array index out of bounds","553":"invalid admin","800":"attempt to add with overflow","337":"Index out of bounds","142":"Array index out of bounds","642":"Array index out of bounds","319":"Array index out of bounds","828":"Array index out of bounds","758":"attempt to add with overflow","627":"attempt to add with overflow","880":"attempt to add with overflow","685":"Array index out of bounds","426":"Array index out of bounds","100":"attempt to add with overflow","673":"attempt to add with overflow","414":"attempt to add with overflow","213":"attempt to add with overflow","847":"attempt to add with overflow","332":"attempt to add with overflow","841":"attempt to add with overflow","131":"attempt to add with overflow"}},{"name":"split_group_balance","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"debtors","type":{"kind":"array","length":10,"type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},"visibility":"private"},{"name":"participants","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/41VzYokRRCO/KnKn6rpqsysnllwRgQRXOhxZkGqXcWD7Lh6UaYXRW9evCgKLqIXT+LRBxC8+yIe9yB49xEEwSfwi8jqdpCR3YbMzszKjO+LLyIzLskofY+Mf0R0SWYI6CjeJfwiWiDyD86o9Vf+aoe5v6qNNJo6I+uv/TX/7fxui61ktvzdon+bGrb7kFqYjGGGQQy6jgDQ0aUyCgAm6m5LsI9z1Hmco+CbV2D8dKbYwsw1OfQ78rx49yFzeMTsYBtDdwQI5xvvT0h5/JgrfsLV11a5nhO97L3Cdj4QtsoH3/LUylT71geeOtLebejs4nnRQPruzb0eYE/9JSnVRVJ9F89ZtfiOInpBNkZqm67H6qvU8yq87uC16dnrXrxmATrdz9RDj1YfzfqoChFn3bBE1MuOFYZ6eM8y4oK+QhtwSHBih6GiFYgMqxGQ79K4QA6Mpnk0spHE0yTgI4ajTjOlPOsObRxAJGzog0gm9BbblTkn9RHZDX08qwEJYIIGCWP7cVbjcErtYFlesksTebFsA7owyLdhafKN9Qog+CkNTPCSrMI36wa7Qm+Z+2eVe4tMsswobugLThvfc+ew4zEhKl9d8KLjRWex+A1ZPgZ2beUY3aychzq+w3e1Yze+gw7smGHnaRQdZLMeZxoT9GeBElTRPsl6YtXyQXqcg3xEGXbHzkJwu8pA/5HyIrg9CJ7/I3jGMIvgBYKjZQv34MpPENz1CSTfoLShn2dll+AwmT7PKlsWNYmeaWl7rdOIbrwlDqD1SxXlaV43z+o1Es7YxTXzf67ZglnRGI1F1gtbmw7W2BI+0AQNUwclVV5NIPsrTQvZfNBw4qNsBScYaMJwgmkqa2iINuWq4W+iYYGGL1HZ0O/QzGGvk8Oln2Y15VOyuUCs4jByALF5cMi77HCO/qCyh2fvboBW7xh0gneVAkbjJOtCcX3wTjxDW8O7ciND/qwZAnjHYUec/4oSXVBeUd7Q33ydHENLrNLe81TyLCEw0OXfi4sLmyTDmN2Yl3vcVK4Y+cPIyQ7wVyVLZNJbah9Qfm0MNMAlwt1T/f7dcHzrOLmwoy153Kcza0ruhioOe0UVfi4m3MY0rWHoOVovtzHrNfp14gi413nJ1YwySYCTAL94AGZhEDyOk4OOLezd51NrqtmgjgHijk/OOcFP+BAKRfGGi4D2FqVBfYkq0ZDA6hP0J+4YiXLM6WAKIF1BuqnXlnTTa+hbOIVw7xLDss9jLgJbatpX35z49qD6Bth0C2xNfgFnYfIksIlhE8f6/eWl0AVpkPj2Swz8annd1IfkqhSeY4B3l+9+gGBtHNP9/QvAr7nK4BQyJ/0nNXnByd7CqV5vYRb4oefQBYMn1wR+ctXni/o64cG1XAJQE41vOxTBlosg9jxGKVRfw5zxzUb9sOWq2iipvHZfggOX4IAyGrkERx+5BONPSnCsbf82qe99rCU4+A5wXa3IjUw16nbH0wD0sFHf3lMGFhn4Ykt3ntx58g8Z+bMOrQgAAA==","debug_symbols":"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","brillig_names":["split_group_balance"],"assert_messages":{"282":"Array index out of bounds","311":"attempt to add with overflow","340":"attempt to add with overflow","116":"Array index out of bounds","235":"Storage slot 0 not allowed. Storage slots must start from 1.","267":"attempt to add with overflow","104":"attempt to add with overflow","290":"attempt to add with overflow","322":"Array index out of bounds","51":"cannot adjust someone else's balances","333":"attempt to add with overflow","138":"Storage slot 0 not allowed. Storage slots must start from 1.","71":"Storage slot 0 not allowed. Storage slots must start from 1.","164":"Debtor is not part of the group","193":"Storage slot 0 not allowed. Storage slots must start from 1.","350":"Array index out of bounds","219":"attempt to add with overflow","47":"Not initialized","300":"Array index out of bounds","361":"attempt to add with overflow","99":"Must be part of the group"}},{"name":"balance","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/02SvY4UMRCEq93+abfhMsQGQI60cLPJDARELLckIJHwAEgECIkc8Yb3VFR77k43kj3dtvur6hkvUEknqH0GFmhunGCvwcc4Gl8fX6La2c7fYu28DyQO2bgJ3WIlc/6EwvkG9S03rzaQermJokscfjWZc+4f7vmdwxeIdId4tzfAM56XMCPiTA/Ika5ApjV1UuFYRCUzzMlXeF9TIUl7YlT7Mo/EpjFM40sOlTu1UB0LqpZ7ZA1kfYSsK+ogcjAbiVEfc30EzR5oNUhBJA3ZUWumtKCwlV6ilXd7KxQqoZEi6hMSqU3J3betMArlEKMxb0ecHdq8E/MV/YjLKnc9RrF5W6XxZIn+9To2X6A27tVq+X1837x7U9EnJOkg6TtGGOKv6aansGQ5ftZP/reCvfvZddM1mUZxaLZuV5wtED92BL1S3cLnJqZWB01V8hrP/Ir132SqlSP+bWGkCOVg1DjNoD9lQbds/hxibh63jK95y3wf+y0j8K85yy0KBuWGWaRlpsnMRqSd6vxQf06iJIbw9YbD7eH2P3sPlhXkAgAA","debug_symbols":"5ZvbbuIwEIbfJddceHyc4VVWqyq0UEWKQgV0pRXi3dfp5kST4lbUlUe+AQd+Zr6x8MzYSs7F03bz+vxQNbv9sVj/Ohf1/rE8VfvGX50vq2JzqOq6en6YflyI9gX0m/74Ujbt5fFUHk7FWqyKbfPk3/1vd1W9LdbOXVYzGSnXCcm4QQoGF7Rait6qH9KoFmJBbUlCp7bey5X696oAcwc1CNCdEoTSP8pt75ltp/rZptBsg0TqY1TaBKgRTK9GKeSM2n0LtZ/sa+zWNMYzTdFMSxHPNHzadKuWX1KrL6kXMwM4MD2+c4FQJTrZiSXB+L+S9ObAxHZgYztwsR1gbAcU2YESsR1AbAcytgMV20Hslaxir2QVeyWrD1Yy9tkRUJhAXoehGbKTtO70Unk2g13CCQot2TU41H2rR3AFelE99jZiFiVmESXlEKUWWUQJWUQps4hSZRGlziJKk0WUNosos+h9dBa9j86i9zH39z4gtBwcEAXi/OTRjrW2P/xDNZr04xYaOEJLjtCKI7TmCG04QoerOgShrRmhxZWHudoQ9WorwF6mx+sLamf6BOyHeKVu6R1remRNT5zprWBND6zpJWt6xZpes6Y3rOlTz/eoB3o07+ld4jkHh1sT/NDO6H8+5wymrVAQoAfSg22/2xv3g36719Ir1vSaNT3vVZt4l4bDXVMG9ewWIUy8S0Mpb9EnnzFppMeAmpTusUk5NYs18Z7udnXAxHu6AH3iPV2APvGeLkCf+PlJgD7x85MAfeKVOUCfemW+SU+pV+bb9Kz3MsS61hLrWkusay2xrrXEutYS61pLjGvtxV/+KQ9Vuam33TNAu9fmcfJI0Onvy/9vvPgf","brillig_names":["balance"],"assert_messages":{"85":"Array index out of bounds","55":"Storage slot 0 not allowed. Storage slots must start from 1.","20":"Not initialized","97":"attempt to add with overflow","23":"Function balance can only be called statically"}},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"7Z3bjiy9daTf5b/2BQ+Lh/SrDAYD+QgBgmxY8gADQ+8+9XftyqruzCS7lSwykituDMnK3c31xd7JiEUm+T+//cu//tN///v/+eOf/+0//vLbP/6v//ntT//xz3/46x//48+3//Y/f/uH3/7pv/74pz/98d//z+v/+zfz+/8R//H8X/7zD3/+/b/+5a9/+K+//vaPwaR/+O1f//wvt/+U0+3P/9sf//Svv/1jSn/73//wm8hP/0SMe38iW/vrTywmfP0T6ad/Ipm9P2Ftir/+iLXZfv0z9u/4M+7nfybnvT+zuLD+Ebu8/pF/2DwbbXiUHu3i14dz2HlYbHj8ZLHp+bCLH4NZgAazGKTBWKTBOKTBeKTBCNJgAtJgItJgEtJgkN7AC9Ib2BqkV7A1SO9ga5BewtYgvYWtQXoNW9P3bRPS0+0+f65b8sdgbN9/UtGYx7MmbgdjkQbjkAbjkQbT4J+TfxmMlAfzfNbK8+d6uf9rsgFpMBFpMKnvYJJ7/ODFbAeTkQazAA3Gma6Dcdb/etZ5ux2MRRqMQxqMf+NgPn6BvPsXhHf/gvjuX5De/Qvyu3/B8uZf4M27f4F99y9w7/4F7/6X7N/9L9m/+1+yf/e/ZH/+X7J7elRnw6lE5jPUaBak0YiBGo2FGo2DGo2HGs35l6B3+TEaH3LFvJl1wc0Z+eyyd8Zu7Dp28/Kj3bLzcIqPZ9NrA2WfyWPE8mIhdx/1Jj3spjevPzf+HawDWXdjHcm6G+tE1t1YZ7Luxnoh616sgyHr56MfRCyJfCHiSOQLEa+RSHwMQqLbEBES+UJEZeooElGZDZZHz0CW7XtEpYMvElHps4tENLrhsP7YYONXIlGjZy0T0ehZy0REIxEvDyJ+S0TjXBPlsbsvRrMhonGuKROBnmtuy1vPTsbrXs2PsSfoWeG2KF0aO/T729q0jj2bzdihuwOVsUPn+MrYe89w6TG5OGsyWlfmvV3SFMi6G+tI1t1YJ7LuxjqTdTfWC1n3Yp0NWX9OUdmSyBcijkS+EPEaiZRWh7KQyBciKlNHkYjKbFBaHcoqHXyRiEqfXSSi0Q0XV4cWjZ61TESjZy0TEY1ESiuIi8a5prhetmica8pEoOea4gqiM9CzQnEF0Rno93dxJcsZ6O5AZezQOb4y9s4znBW3jj1FtK7MW7ukzgSy7sY6knU31omsu7HOZN2N9ULWvVhbQ9afUpSzlkS+EHEk8oWI10iksDrkGhy8ORsRlamjSERlNiisDjmr0sEXiaj02UUiGt1waXXIOY2etUxEo2ctExGNRAoriM5pnGtK62XOaZxrykSg55ryCqKHnhXKK4ge+v1dXsny0N2Bytihc3xl7J1nuNuS5WPsThJaV+a9XVIfyLob60jW3Vgnsu7GOpN1N9YLWfdiLYasP6cosSTyhYgjkS9EvEYipdWh3rcyXICIytRRJKIyG5RWh0Slgy8SUemzi0Q0uuHi6lDQ6FnLRDR61jIR0UiktIIYNM41xfWyoHGuKROBnmvKK4gRelYoryBG6Pd3eSUrQncHKmOHzvGVsXee4UJ4jMYlU1v99NbER4vShpckKPexhwuPPV547OnCY88XHvty3bH3Ph286djthcfuLjx2f+GxX3heTReeV9OF59V04Xk1XXheTReeV/OF59V84Xk1X3hezReeV3ufUtt07BeeV/OF59V84Xk1X3hezReeV5cLz6vLhefV5cLz6nLhebX3aatNx37heXW58Ly6XHheXS48ry7XnVe9ue686s1151VvrjuvenPdedWb686r3lx3XvXmuvOqN9edV7257rzqzYXnVXvhedVeeF61F55X7YXn1d5nDTYd+4XnVXvhedVeeF61F55X7YXnVXfhedVdeF51F55X3YXn1d5n5jUd+4XnVXfhedVdeF51F55X3YXnVX/hedVfeF71F55XPfa8mt069iVuxo49r5bHjj2vlsfeYF5dHh8MRpFQHrtd5PE32Bn7LPTWr9h72tj1DCZrnPWfnv8Yfrr28PO1h79cevgtTuUaOXx77eG7aw/fX3v4Aj18Z5fn8L2rPR/DWm18OX3P/6o1KKoVez5vWyv25N+2Vmyn0LZWbFvRtNaA7UHa1optWNrWiu1u2taKbYXa1iqKalXkm4Ii3xQU+aagyDcFRb4pKvJNUZFviop8U1Tkm1qco3aZWhX5pqjIN0VFvikq8k1RkW9KinxTUuSbEvic87oclcOn5z+Gj/268f45fP96pOzf8fxHudhvnB+Wm+Rx3q5NL/eR/PqbmbHfOG1rxX7jtK1VZqo1r3uqbP506+zOw9k9LhLJTjZYsE3iG7H8Pos9f3bcgJnqFf8jMNaYtUhZNmCmmgwaglmmmjlagplqmmkJBrt7OBAMdqtxIBghmH0w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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"admin","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/zWRT0sEMQzFX5s2TbvqRdA9qCdBhHV35tLBg6f9I4ggXsVPvJ/KlxkcSKZpk19e0wES4gixEzBAYqaDPoOf0jJg+3uoHezwzdgOiyHSwsRDyOQ7acuNiwkkHU+eePSEh5kz+/L2zyx+PCAEbQim5QW4RnkPLiAEY3iD5GFnHoHsxVVydeqhYggSEpcpaoeWgVu1x1p6TOb6a0fNGzw2SK7O36Js8NSDsbeUGaM195Ctwzxbdn54B81KmsM1qby6ZMHSPOgFcdqIm9BcH29bTEZXaPP9TxxF9gKR2OhbVkpSL/bGuaQr+uSI/YLoUSghudgpmJiuOEAlz1V/GFV/kinGhN/J55aD840Cx3lRL1lQLVm75TCbNX8s/ubHaostj0XgjzWWmxes2G5l5mGew2hmKw8ru9cNvsYgJHrj3YT1eX3+A4vpCkQrAgAA","debug_symbols":"1ZrfboIwFMbfpdde9PTvqa+yLAsqGhKCRnHJYnz3lQ2KCqEzTtNzoy18HH5t2n7tCSe2yhfHzUdRrbcHNn87sXK7zOpiW/na6Txji31RlsXm4/Iy480PiB/9YZdVTfVQZ/uazfmM5dXK//tn10WZs7m159lA5qRthU7bIAWNI1oleBfVF12v5nxEbZyAVm38W67U7zMG8gFq4KBaJXCpXsqtHultK7vedrHeBoGua6NUOkKNoDs1Ci4G1PpfqH1nX2M3oc3zQtvnhcbnhXZ/Du3Vgt+lhrvUoysDgA2TB5yIzTSjQ1td/wJAOaLWznVqw8FExqy2ult8fBFvx6yQpOkVaXpNmt6Qprek6ZE0vaNMLzlpeiBNT9prZeorJqpAj3pAn/isxXD+8EVzS69eP2uRB3oJEXofMJxDgPcjR/qWNPRAml6Qpic9a1Xi+xwMqRGNapAHUInvc1CIKfrUV8xJep34Pge56+kxonZSdSuCTzfJQVsT3xVNe5tOfFcUoU88AxGhV6TpE89AROgTd+YIferOPE2fujNP05M+y5jknXmSnrTXGtJea0h7rSHttYa01xrSXmsIe+3ZVz+zfZEtyrz9TGF9rJYXXy3UX7vfO178DQ==","brillig_names":["admin"],"assert_messages":{"21":"Function admin can only be called statically","18":"Not initialized","66":"attempt to add with overflow","54":"Array index out of bounds"}},{"name":"add_to_group","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"approve","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/21UvYqUMRS9+W4mucmXfFO6xSoWNsLo7hR+g8IW4rpWCgviA1j4AILgK6wvYCmW9oIvYLWIrb1gIYK92HhOMoOLOJDMl597zrnnJjkUdcNa1B6IHIr6iE7suuBnaBF/9y5LsGM7PuXccW8yoDkunNhJWzjprS9sECW64VaP/r4sNlwNN7G45C7SicyNRBEzD2oXR/7C6FCc+H+ngihjrjShrU9HO9EJLSPKpSwuJ7shcg2MrhHmLQW2IdWhAZocOnUI0zSAxUZAo6VMM9IsKa5knUVjMsy4EYCfxVZya3YZDmkcCvqS6uxqvkoZMUvIsWDjkRQyQ/EQ56ZLlbulNFLKyUOZpdR5iBWjOuBrUdt8pcTpod8mhTjBgkxALwoOF30GxyPJ5NiXEDzUQtkp1Fri2gfJK3mMjycSVnJ2wWSoJHzgMDQxPZcwC2AGRYtwIyH+KeBywvbgA6DeCgx5NjvrAZCnPuns1PbFm4cOH/EV4ZYnqLfoJ64ogp+LbsX62NFfNHSW6RVdfUmPW3EIn6ihV80uOGYoj+0KmI1FwtSijWC0i9akpbtu6x2Azw5AmrEQgnkawXglsjZkhtigM0qJ1AtllAK8UiHttVTKbltamXKZXdE7bQqNJuRRJ/Tqsf+N+H7ilBnSK5J7knu9vYsKJPEk8Tws7/ph2aA0pmuWyTzvzDdcnwUDVPtRyyhO6JSRlJFleS+hUba7FFk2UBr8CiXvzl7TjkP018k6S51wvSZKmSDFpiXAPspym28eluiXNs1uqi3f2l8GtbGC3GrE/k8Se76Vxw8XA2ch0MTgsD3UMrWkJ4bvnI2FTF86E5K2/ySNAJ26goiyVKYfRwNvNNbla6/LPEwZN5cXdeNMLYwQFgBFbd85/wNwaouV/N7wOCwc/TR4uG4fqfLGmLd8SZxly3zc8Ncet9xbf9wA+Msywo0BI+hGMw4XbTiY2chhAntayc+1UyCS+GAje+d7538A/arXy3QFAAA=","debug_symbols":"5Z3dbts6DMffJde9EEl9kH2Vg4Oh3dohQJAObXeAg6LvPqeL5bT2xDpNMxK+aZ2Wsn+0ZP1FUY6eVt9urn9+/7Le3t49rC7/eVpt7r5ePa7vtt2np+eL1fX9erNZf/9y+OdV2P2A9GL/8ONqu/v48Hh1/7i6DBerm+237ndX9na9uVldlvL878UK8izrMsuaZ1nLHGsMs6xhljXOsqZZ1nGW9ay6xFl1ibPqEmfVJb6/Li9GZkJlbyipVFNIPGEbMfRn7Q5lsA5hwjoLwt46d1d5Zd1RU/gANQSIe0sIFM/KDR+524X6uy3a3QZk6X2kmBRqhtRbMwYcUeNJqLub/Rp7d2r6vFPHzzt1+rxTT/YMILF/0kBy0tp3TvUKMtAA04R1Eumtc4CstJRUUg/SHfKopRTX9OyaXjzTx+CaHlzTo2t6ck0fXdMn1/TWe0yOlZ7TW/pkvN1zHTd3h3lEf/52z6HSEyj03Qnr+BnC0HKo82RHn1zTZ9f0fxhjFqj0LG36SLkfg0cqGk8JBffWJfAopkv6qFHwTdSdZH6ZHI4oMzku6UK8vC+DIWnhCtQYPx/4XuJUzaUw1EG1RZGp8yau4WyOAzhBnLQeQvaDABXlxUtchJe0CC/jIrxMi/AyL8LLsggveRFeyhK8LGERXi5i7FMWMfYpixj7lPhhLyFEHOIyUfx8Z8Yi5x4g78K7g1BvB508QmeP0MUjtD5uyFGBxljnA7CkV1eYoKFhroFEy3yS9LMGMcSDmQbcsTOcnT1SZc8ae4bUV2Z3SG/nJXi6jUPN2SNkPO0szwnnZrm4pmfX9OKZXoJrenBNj67pyTV9dE2fXNNb7++bmUQIxh/bdioRwvmf21n5LCo1RUOc344yuzG5b/zkGz/7wRca4xff+Owb/x0jZT7E3xWCcEwhOKYQHlOIjin0hz4MQi1E+e+F+YBU5z3wYDl0X49Qzo5/wkgfpl+xQKT+GogZ2vgc6grwXBQcpsS9MUkc44AtHLSFQ7Zwoi2cZAsn28IptnDYFo6YwiFbvTLZ6pXJVq9MtnplstUrk61emdj4cE36sXLGUMb4YhyfsYUfg218rC0tI/AYH3zjo2988o0ffeMn3/jZN77xWQYN37jqavjGVVfBT75VN/lW3eRbdZNv1U3GVbebEB/wta8IkVhJJB7mK3pnjWt0w9kXfOMareFbzwQo+NYj4zZ+tr76qb2OIltfR1FBEsdxYJ+Nr39ixCZ+tL6KRQZ81lSCYv/ICpVxyi8bXy+lLNnJxhcna/jGVydr+MaXq2n4xtcnK/jF+AJlDd+4Rmv4vtc6FusareCb1+g2vm/VLb5Vt/hW3eJbdYtv1WXfqsv6G9B/913Edsqbo3H8dsqbk218Zf6Us2/84huffeOLa3wJvvGNv4Ou4aNvfOOqq+EbV10N37fqim/VFd+qK75VV4yr7ilT3hiMa3Q7a4nB+vfEKPjGNVrDtx4ZK/jWN/xoprwxGN/xo53yxmB8y492yhuD8W+wV/DB+KYfp8zYIxjfI6Q9AYlgfJMQDd/1bgk4/X69H3zj+4Ro+MY1WsO3rtEKvnWNVvCta3QbH81rdBvft+qib9VF36qLvlUXfasuOlbd5+7jf1f366vrzc1+H+jbn9uvB9tCP/7/4/d/OuNf","brillig_names":["add_to_group"],"assert_messages":{"179":"attempt to add with overflow","77":"Storage slot 0 not allowed. Storage slots must start from 1.","195":"Array index out of bounds","214":"Array index out of bounds","113":"attempt to add with overflow","158":"attempt to add with overflow","203":"attempt to add with overflow","168":"Array index out of bounds","225":"attempt to add with overflow","60":"caller is not admin","150":"Array index out of bounds","35":"Not initialized"}},{"name":"make_payment","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/31VvY4jRRCu/vG4pnu6p8crwUpwJEQg350dMBYrESD2di8hIOEBkMh5ER4AiZyAR0BCIr0n4AUIESEp31czNj60wnK3u7uq66v6qrp8kOD8UYK+FjlI2Cgm6T8SfHoMxfeLZ9Lpvd5/xf39MsRjuGcS9VEfT9CRcKIgYn4lG8wP0mF+lO0LaI4PvPuaVj8w0zanz84wCSMfxLk+ict9ei7yjqRHZz5JP5s0BKgF6B5ccBnL7NMsaThI58vsy4CjwQ+z3wwmhCD4+mW8woBAKvQlJ+lSxtLJAMg6jID8WEZCAq0SyHM10kjjthnuiOXo2yxtmn3GGOssve5lTiCxj1B34bm49yTu5W52FQwG9XAixH6c3Vjfl65GcilxHcYljqNi0mqyug6TkRmFgw9Szw6SDhqFAbpFh6uPs8QRTCxOYtWNdr4EcWGCvxBIAwkxF8RfhgrzX1/Ml0v89T/xL0CMH+YzRi2IP+3lG8SfephxG6l7+XZ2xYL2dsNCLwivPBGeMcL4i8nKOkwGt76TsrrF4gzmWzFnFm7hQInI+gKHVRcXzt/Of1kjr2dDluR6ZQiSiktdQFjjxVq5svYvh3W1Rg5rVnCoQ4Oz30s7O3vhsPHqVbJIZ7NkrTXUdOHwB+MwwsxfLJ8fZ6cs+bSWT5tdQ4lENbISVkkHbLcJ8GngvZ8kEt7baZW4VZ7+vJyeA79yZa1OuNIQ8+IYVqXZuTk+vVU3EMhkdbPEnGH+F8k0D6cSA0H2f03MeYHsdyl7+Q2iLQkMW050wjMwTXzagd/e3OEy+H722lOn57aHTcXRhruewu6yiqaBNuBSb0Tp527pWtK/ZFkh6SirgSVNg+wakg2KZVR8ntEKAJf4btMArxM7wR9LJzAVe0yVEPmOR3npI6GGXDHnAfp/yrAQnBk80sYMJXDV1TZ9yluTLHXgdgBJuxtc+ltueOkEYjUcWSwa0SzdEX1zwwth8jeYb9IOJbJjfKEBMjXk1Pk1p34CP43FgxfH5pJGxjw2g2W6+PrdRNhph4tFditsfQJ2KQGC7RK722SwlbAVzLjbtUf6hmdX+e7R4xitEjY9BasG++EFNv4/rJ5hFbRjHhnti3O0DY90ZLs9OQ3aZSh0MLWFzie63bsTzAXd7B3+lVAIG8fyUlTu0RZ9YZfWqOldVG/SxP82/Nh/W1rGufG4V5oc3cCFDLisyu3Gtl5VM7c90Pu9uzuieJ0BvzzJ7ZvbN/8ACRea9FoHAAA=","debug_symbols":"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","brillig_names":["make_payment"],"assert_messages":{"268":"Array index out of bounds","186":"Storage slot 0 not allowed. Storage slots must start from 1.","279":"attempt to add with overflow","69":"Creditor is not in group","290":"Array index out of bounds","246":"Array index out of bounds","301":"attempt to add with overflow","170":"attempt to subtract with overflow","228":"Array index out of bounds","257":"attempt to add with overflow","21":"Not initialized","85":"Storage slot 0 not allowed. Storage slots must start from 1.","111":"Debtor is not in group","140":"Storage slot 0 not allowed. Storage slots must start from 1.","41":"Storage slot 0 not allowed. Storage slots must start from 1.","236":"attempt to add with overflow","166":"Insufficient balance, or paying more than is owed"}}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"group_members","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"group_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"member_count","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"PublicGroups::admin_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"PublicGroups::balance_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"PublicGroups::balance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"debtors","type":{"kind":"array","length":10,"type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}}},{"name":"participants","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"PublicGroups::split_group_balance_parameters"}}],"kind":"struct","path":"PublicGroups::split_group_balance_abi"},{"fields":[{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"PublicGroups::member_count_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"group_member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"PublicGroups::in_group_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"PublicGroups::in_group_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"approve","type":{"kind":"boolean"}}],"kind":"struct","path":"PublicGroups::remove_from_group_parameters"}}],"kind":"struct","path":"PublicGroups::remove_from_group_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"PublicGroups::set_balance_parameters"}}],"kind":"struct","path":"PublicGroups::set_balance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"PublicGroups::constructor_parameters"}}],"kind":"struct","path":"PublicGroups::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"creditor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"debtor","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"PublicGroups::make_payment_parameters"}}],"kind":"struct","path":"PublicGroups::make_payment_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"member","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"approve","type":{"kind":"boolean"}}],"kind":"struct","path":"PublicGroups::add_to_group_parameters"}}],"kind":"struct","path":"PublicGroups::add_to_group_abi"}]}},"file_map":{"100":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\nuse crate::hash::ArgsHasher;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    args_hash: Option<Field>\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs, args_hash: Option::none() }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            let mut hasher = ArgsHasher::new();\n\n            // TODO: this should be replaced with the compile-time calldata size.\n            for i in 0..self.inputs.calldata_length as u32 {\n                let argn: [Field; 1] = calldata_copy((2 + i) as u32, 1);\n                hasher.add(argn[0]);\n            }\n\n            self.args_hash = Option::some(hasher.hash());\n        }\n\n        self.args_hash.unwrap()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"128":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"141":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"158":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"159":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::oracle::logs_traits::ToBytesForUnencryptedLog;\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (n as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"165":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{\n    header::Header, address::AztecAddress, constants::CANONICAL_KEY_REGISTRY_ADDRESS,\n    storage::map::derive_storage_slot_in_map\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{\n    public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys,\n    constants::{NULLIFIER_INDEX, OUTGOING_INDEX}\n},\n    state_vars::{public_mutable::PublicMutable, map::Map}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\n// A helper function that gets app-siloed nullifier secret key for a given `npk_m_hash`. This function is used\n// in unconstrained contexts only - in Note::compute_nullifier_without_context which in turn is called by\n// `compute_note_hash_and_optionally_a_nullifier` function that is used by the NoteProcessor. The safe alternative\n// is `request_nsk_app` function define on `PrivateContext`.\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n"},"174":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n\n"},"183":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"224":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n\n"},"233":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // We choose the last SELECTOR_SIZE bytes of the hash to avoid getting the first byte that is not full\n        let hash_bytes = hash.to_be_bytes::<SELECTOR_SIZE>();\n\n        FunctionSelector::from_field(field_from_bytes(hash_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector = FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"29":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n"},"296":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"298":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"299":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"301":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"302":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"305":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"306":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"314":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"346":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    protocol_types::{\n    traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    point::{Point, POINT_LENGTH}\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul};\nuse std::hash::from_field_unsafe;\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.value);\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> ValueNoteHidingPoint {\n        ValueNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    /// The following method needed to be implemented because the note is passed as an argument to a contract function\n    /// --> the serialize method is called by aztec-nr when computing an arguments hash.\n    /// Note that when the note is about to be encrypted and emitted as a log the to_be_bytes function auto-implemented\n    /// by aztec macros is called instead.\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n\nstruct ValueNoteHidingPoint {\n  inner: Point\n}\n\nimpl ValueNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_value(&mut self, value: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(value.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for ValueNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"77":{"path":"/Users/niallcheetham/dev/aztec/publicgroups/PublicGroupsRoot/contracts/publicgroups/src/main.nr","source":"// mod test;\n// mod types;\n\n//this will be a little test to make public groups in noir\n\n\ncontract PublicGroups {\n\n    use dep::aztec::{prelude::{Map, PublicMutable, AztecAddress}};\n    use dep::std::hash::pedersen_hash;\n    use dep::std::collections::bounded_vec::BoundedVec;\n    use dep::std::collections::vec::Vec;\n    // use crate::types::bounded_vec_wrapper::AddressVec;\n\n\n\n\n    #[aztec(storage)]\n    struct Storage {\n        admin: PublicMutable<AztecAddress>,\n        group_members: Map<AztecAddress, PublicMutable<bool>>,\n        group_balances: Map<Field, PublicMutable<Field>>,\n        member_count: PublicMutable<u64>,\n       \n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.group_members.at(admin).write(true);\n        storage.member_count.write(1);\n\n        //emit event for the admin assignment\n        context.emit_unencrypted_log([admin.to_field()]);\n    }\n\n    //helper functions to read variables when testing\n\n    //read the admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    //read the group members\n    #[aztec(public)]\n    #[aztec(view)]\n    fn in_group(group_member: AztecAddress) -> bool {\n        storage.group_members.at(group_member).read()\n    }\n\n\n    //read the member count\n    #[aztec(public)]\n    #[aztec(view)]\n    fn member_count() -> u64 {\n        storage.member_count.read()\n    }\n\n    //read the balance between two addresses\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance(creditor: AztecAddress, debtor: AztecAddress) -> Field {\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        storage.group_balances.at(key).read()\n    }\n\n    //functional methods\n\n     #[aztec(public)]\n    fn add_to_group(member: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        storage.group_members.at(member).write(approve);\n        if (approve) {\n            storage.member_count.write(storage.member_count.read() + 1);\n\n            //emit event for the member addition\n            context.emit_unencrypted_log([member.to_field()]);\n        }\n    }\n\n     #[aztec(public)]\n    fn remove_from_group(member: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        storage.group_members.at(member).write(approve);\n        if (approve) {\n            storage.member_count.write(storage.member_count.read() - 1);\n\n            //emit event for the member removal\n            context.emit_unencrypted_log([member.to_field()]);\n        }\n    }\n\n    //this set balances but only between two people\n    #[aztec(public)]\n    fn set_balance(creditor: AztecAddress, debtor: AztecAddress, amount: Field) {\n        assert(creditor == context.msg_sender(), \"cannot adjust someone elses balances\");\n        assert(storage.group_members.at(creditor).read() == true, \"Creditor is not in group\");\n        assert(storage.group_members.at(debtor).read() == true, \"Debtor is not in group\");\n\n        //cant store the addresses in a tuple in storage so hash them together,\n        //easy to know who owes who as hash a,b is different from hash b,a\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance = storage.group_balances.at(pedersen_hash([creditor.to_field(), debtor.to_field()])).read();\n        let amount_to_write = amount + balance;\n        storage.group_balances.at(key).write(amount_to_write);\n\n        //adjust the balances\n        //balance between creditor and debtor\n        let creditor_debtor_hash = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance_creditor_debtor = storage.group_balances.at(creditor_debtor_hash).read() as u64;\n\n        //balance between debtor and creditor\n        let debtor_creditor_hash = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let balance_debtor_creditor = storage.group_balances.at(debtor_creditor_hash).read() as u64;\n\n        //if the balance is greater than 0, then the creditor owes the debtor that amount\n        if (balance_creditor_debtor > balance_debtor_creditor) {\n            let difference = balance_creditor_debtor - balance_debtor_creditor;\n            storage.group_balances.at(creditor_debtor_hash).write(difference.to_field());\n            storage.group_balances.at(debtor_creditor_hash).write(0.to_field());\n        }\n\n        //if the balance is less than 0, then the debtor owes the creditor that amount\n        if (balance_debtor_creditor > balance_creditor_debtor) {\n            let difference = balance_debtor_creditor - balance_creditor_debtor;\n            storage.group_balances.at(debtor_creditor_hash).write(difference.to_field());\n            storage.group_balances.at(creditor_debtor_hash).write(0.to_field());\n        }\n\n        if (balance_creditor_debtor == balance_debtor_creditor) {\n            storage.group_balances.at(creditor_debtor_hash).write(0.to_field());\n            storage.group_balances.at(debtor_creditor_hash).write(0.to_field());\n            //this is not setting them to 0\n        }\n        //if the balance is 0, then the creditor and debtor are even\n        //the values should never go below 0 as as you are subtracting a larger number from a smaller one.\n\n        //emit event for the balance set\n        context.emit_unencrypted_log([creditor.to_field(), debtor.to_field(), amount.to_field()]);\n    }\n\n    #[aztec(public)]\n    fn make_payment(creditor: AztecAddress, debtor: AztecAddress, amount: u64) {\n        assert(storage.group_members.at(creditor).read() == true, \"Creditor is not in group\");\n        assert(storage.group_members.at(debtor).read() == true, \"Debtor is not in group\");\n        //make sure the payment is less than  or equal to the balance\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance = storage.group_balances.at(key).read() as u64;\n        assert(balance >= amount, \"Insufficient balance, or paying more than is owed\");\n\n        //subtract the amount from the creditor\n        let amount_to_write = balance - amount;\n        storage.group_balances.at(key).write(amount_to_write.to_field());\n\n        //emit event for the payment\n        context.emit_unencrypted_log([creditor.to_field(), debtor.to_field(), amount.to_field()]);\n\n    }\n\n\n    //same as the above but with a fixed vector of addresses\n    #[aztec(public)]\n    fn split_group_balance(creditor: AztecAddress, debtors: [AztecAddress; 10], participants: u64, amount: u64) {\n        assert(creditor == context.msg_sender(), \"cannot adjust someone else's balances\");\n        assert(storage.group_members.at(creditor).read() == true, \"Must be part of the group\");\n\n        // //calculate the amount per participant\n        let amount_per_participant = amount / (participants as u64 + 1);\n\n        // //update the balances\n        for i in 0..10 {\n            let debtor = debtors[i as u32];\n            if (debtor.is_zero()) {\n                continue;\n            } else {\n                assert(storage.group_members.at(debtor).read() == true, \"Debtor is not part of the group\");\n                let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n                let current_balance = storage.group_balances.at(key).read() as u64;\n                let new_balance = current_balance + amount_per_participant;\n                storage.group_balances.at(key).write(new_balance.to_field());\n\n                //emit event for the split\n                context.emit_unencrypted_log([creditor.to_field(), debtor.to_field(), amount_per_participant.to_field()]);\n            }\n        }\n\n    }\n}\n\n//can bypass the whole making a bounded vec and just use an array of addresses\n//skip if the address is zero."},"79":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/address-note/src/address_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: Field = 3;\n// ADDRESS_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[aztec(note)]\nstruct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"},"85":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"}}}