{"noir_version":"0.34.0+e0185e75e65df08b5334856f8bf63fa3aed7049a","name":"PublicGroups","functions":[{"name":"set_balance","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["set_balance"]},{"name":"remove_from_group","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"approve","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"5Z3dbts8DIbvJcc9EEn9kL2VDx+GdGuHAEE6tN2Aoei9z+kiO40dc07TlIRP2qSlnIeWolcUJet58e325uf3L6vN3f3j4vq/58X6/uvyaXW/ad49v1wtbh5W6/Xq+5f9Py/C9gfQq/3jj+Vm+/bxafnwtLgOV4vbzbfmd1P2brW+XVyX8vL/1QLiJOs0yTpPsi6TrHmStUyxxjDJGiZZ4yTrSXWJk+oSJ9UlTqpL/Pe6vOqZCZWdoaTSmkLiAduIoV61eSmddQgD1lkQdta5+ZQ31ltqfgc1BIg7SwgUL8ot77nbherdFu1uA7JUHykmhZohVWvGgIfUFM5C3dzst9jbS8PHXRo/7tL0cZce7BkwBtwVwqYVau07p/YTpDMGpgHrJFKtc4CstJRUUv3KNy+511KSa/rsmr64pmfX9OKZPgbX9OCaHl3Tk2t66z0mx5ae0yF9Mt7uuR03Ny9zj/7y7Z5DS0+g0DcXbMfPELqWQ40nW3pyTR9d0x8ZY2Ju6WMcp4+U6xg8UtF4Sij1xpTAvZgu6aPGWA6i7lROKMMnlDkyLuEapGIKSQlXoI3x857vJQ7VXKrVDNLVG4oMXTdxG87m2MWcBHHQugvZ9wJUlK2XOczCS5iFlzgLL2kWXsZZeJlm4WWehZdlFl7yLLycxdinzGLsU2Yx9invH/tAiNjFZaL4+Y8Zi5xraJW34d1eqLeFJo/Q0SN08gitjxtAFGiM7XwAlvTmEwZoqJtrINEynySVI4a4N9OAr+xycfZILXvW2DOkWpnNSzqcl+DhNp6knS/IUM47y3PGuVlOrumza/rimp5d04tnegmu6cE1PbqmJ9f01vv70Uxi88s2/ngqEcLlv7eT8llUatsB4nw4yoSAvvHJN370gy/Ux0++8bNvfH2kjLSP/1qITykkJxSCcEohOKXQkT6srZqmPHxemA9I7bwH7i2HrvUI6eL4Z4z0YXiLBWaujRcLKDNDHNoV4LkoOEyJqzFJ7OOIKZzhTSKfhwO2cNAWDtnCibZwki2cbAun2MKx1SujrV6ZbPXKZKtXJlu9MtnqlY9s1LEzXJN6XzKG0scvxvEZR/HZNj62LS0jcB9fXOMf2azjBh9846NvfPKNH33jG59l0PCNq66Gb1x1NXzfqht9q27yrbrJt+om46oLmTt87REhElsSifv5iuqscY0ecfYV37hGa/jWMwEKvvXIWMG3vvppfB1Ftr6Oon1eU+LYD+yz8fVPjDiKb3wBVDcD1uCzphIUa35TqPRTftn4eillyc6RrYFu8I2vTtbwjS9X0/CNr0/W8I0vUNbwjWu0gl98r3Us1jVawTev0eP4vlW3+Fbd4lt1i2/VLb5Vt/hWXdZ3QH/uXsTxlDejcfzxlDeTbXxl/vTIVlA3+Mk3fvaNX3zjs29843vQFXwJvvGNq66Gb1x1NXzfqiu+VVd8q674Vl0xrrpnTXmLcY1WspZi/Tkxo/gYjGu0hm89Mlbw48UfxnzGlDcG4yd+jKe8MRg/8mM85Y3B+BPsNXzjh36cM2OPwfgZIeMTkAjGDwnR8F2floBg/JgQDd/4OSEavnGN1vCta7SCb12jFXzrGq3gm9focXzfqou+VRd9qy76Vl30rbroWHVfmre/lg+r5c36dncO9N3Pzde9Y6Gffv/4+5/G+A8=","brillig_names":["remove_from_group"]},{"name":"in_group","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"group_member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VXS2/TQBC2Y7uxY6qGFhBIHPYKh+IUxEPi0KqPA0hFAgkkDoAbO8WS463sTR/8erzpTv1l6yRFsQ+slOx4d+abb2dn1mvTuG5W+TOV7MCY3khnV/XBam3QIFbQJk/zP+HZaZCnCTwtImvjACyiU7MoqeNoY7Jtgryh+mMuWJIlIgnT5E8cofpDkF+o/miSDUXCs9Lm52nOJ2dsGGaMZ+kVO4lLOU3jiBUiFImUrxDuGcjvVf9F8Dw8jVmRljQClpX/pRm/iKNthnMFG08KIYFzwUY5H7PBNmJ/APmJ6vfyPLwqeUbxJeMTwfiInfBJFhVo+BXkp6oPhYjHZ4IJzsIoYheJ+M34eZyPSmI38eSq94xqD2ifdtVzsFobeECuUey3r95I7LV2eL+U2N12sAOJu+9eYxF/8iXz/kDNUW+q37pR1Q7ZrxtVXR3AGNXOoRqT3T2jmj9yK3+ybcEY5YfU7ys5PB9/OhvyKN6LojwuZhIQ47So3RXP/Qe8xzre8SRNk1ES54eXSSFmcL0aXDp/OjXrQS44b2iYroa1q56D1dr0xUFcbIXtabwc0NlS/eYcnrj+Bl9KA8eocvDRHTkYzfnfwRpAX7gvTZ4Nel6ib/LZg/Gmz1QT/JB/8kV5KmPS1Tj1YQxzoathdTUstHPAvqX4Ti8PvSXrk/79dvzv3Ff+iYOvxRFj6ADPhvwHBqzXmRP7lmp5Gnsf4o73Ng94kM5z1dfVe11dLqodzF1P02tzvxdxIp89YzbmTdezr/n3amKi52MfxhwY0/dL2tI9g3JYPr+G9Tjg267Rd0BnHzDeKVnexfFdRbiEQ+P62YK+jTm+N4zZepDNmuPPVHN6rZKNrWHj3crV8PC+RXO+4uNouhbo4pplw1zGe55s8g7zQMk3dxj12fA5DqNbH1LG7Rpadseh8R7MtZW/dBegGGB+ks5H1c87Myy3siHuttsK9x0J+x1835xx4G9Zbda9r8iG4oC1asG68Bu36T2xNE7EBX0iT9SxQJd0vqm+bt+WnTtYG3TuyDpao+8QiHfXrTjboNMBTqTzA3B/gV9Hw5XzWc08tUXvAMq96Xu3nTy8vvNA3tvgy4b1k04PeDjwnMJ6fHd2PRQLwpXxd5Xsu/PtHM2uDzou2Hmanaftm9yDoZJ7xmyNNZn7uNcyd/8CkqU6D6kUAAA=","debug_symbols":"5ZvdbuIwEIXfJddceDz+meFVVqsqtFBFikIFdKUVyruv0yUJbKK4FUvlkW8ggcPkO5btGZvkXLxsN++vT1Wz2x+L9Y9zUe+fy1O1b8LZuV0Vm0NV19Xr0/XHhepeQH/oj29l050eT+XhVKzVqtg2L+E9/HZX1dti7X27msgY/UXI1g9SsDSjNVr1UcMhj2qlZtSONVzULlzlRv1zVQDeQQ0KzEUJCs23cpt7Wttj39oca23QxL1HNDZCTWB7NWmlJ9T2v1CHxr7F7kK7x4X2jwtNjwvNnw4d1Fp9SQ1fUs/ODKE3DYMHHUWswjA/uCun3sz1WNuDAI9hNfNcXEvDUHBm7K8IZlY9Dverzq35wyVm4dJk4dJm4dJl4dJn4ZKycMk5uESVhUvIwmUWtQ9mUfugycJlFrUP3l/7gDJ6uABzxOcn13TOuX7VTziGDMcdtJcITRKhWSC0URKhQSJ0PKuTj0E7O0KrmytM1Za5VzsFrl3ehbPe9hNwOKT2n104g6LpjWh6K5reiab3oulJND1LprdKND2Ipk99vicz0JOd0Cc+59Dwn2Q4dBP6759zSA30CDF67P9stGbsNxgWex07y2V3SjA7SGG3bsKuBbOjYPbUK7PFOd4lXpnRcHONJTO5k8QlXpmR1gv0PvHKjBSP9BRRM5p+RDF6nHhNvI5briV84nsmEfrE90wi9EY0feJ7JhH6xPdMIvSi1y8+9cy8TJ96Zl6kp+Qz8yK96FxLonMtic61JDrXkuhcS6JzLQnOtW04/VUeqnJTby+Piuzem+erJ0dOv9/+fhPEfwA=","brillig_names":["in_group"]},{"name":"member_count","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/7VX34/SQBDeQgulSA5/JZr4sImJzwUv5nzjohgfDEZ9MxpT6KJNSnspy93hX2+X27l+3SvEC+0kZKbdmW++nd2dLha7kVb+s7TtwDtTyGeitX+cjGrE8pvkadXI0wKeLSJr4wtjEmi3wBfHH4J9ovUslTxKIhkFcfRXhOj+BOzXWn/YJAsZpQlfidVcZL8W6SaRfBEkPE3iLZ+L3I5jEfK1DGSk7C1CnoH9XOvzLAu2OYdQXPN0I3m65PMcNVxj4HuwX2gdSClWF5LLlAdhyK8i+YenlyJbxunV7bx/at1jRd2olhP97B8nox6QqxX77PSNwnaa4T1W2J1msP1ujvHOvcEi/pSrrRZUj5G29G+gxxnED1ixn8lfqT4rxqduga3kMbyjvfAg/w21HVyuPl8s0lCch2Em1qXNhjU5JP+L170H3jMTb7aJ42gZiWx6Ha1lCdetwFV2i5V7RKeCS1XjVmLuCeU30c/+cbJrkJTf1tiuwdEBn0eGNnni/GtsviOHFfvt6QEOA+DAgAuKDXYL4mx2dz4NncXxIU6U02Plb0ad/dFi5T1os7vfMlWTrsGpp38kk3r4+EPIRfjqnWvUB/PX3R/VfB2Dg5r3S8jXNepl+uNZ8QHjlbZPYBzPirkWZk+wIBf54JoQtgs8lLT35HP0GMV2AbsNvj0jZgDvyAe/DzTW3zPXNiv3FQZxeAYmWvvHySkDbgxyEAfV3+lSddvfv8k0C36LryIoXb6q7m/mc3uPT4O9ZHeWPVbUFPcl1pp83mq9r3+29WLhebTdRriPFexHzE18IZ8H/GzwwbNhnh+sh5Ih+GAvwXtA3WtiG5yIC+Yknh3Dxwb+5DPVumrdsFdSfQYVeNjP1Pns0B0N6t11ixgbfFrAiXw+Ae4M8xq4avxHxTjJoe8h7b1d729mH+7+3HlwN7Yhlw3zJx8PeDjw/B3m03fL86FaEO6uX2u77+6Pc4y4Ifi4ENcz4nrGuqk1+KJtj5XPWJ17H9dafQf+AZKqwzutEAAA","debug_symbols":"1ZrbbsIwDIbfJddcJHGcOLzKNKFyVKWqIA6TJsS7L916gLVqhhgovoEEfszXqPHvWD2L5Wp+2szycr09iOnbWRTbRXbMt2WYnS8TMd/nRZFvZtcfC1m9KPWtP+yyspoejtn+KKZyIlblMryH367zYiWmzl0mPZkHVws9ulaqkAa0Rssmahj6Ti3lgNp6rWq1Df9yo36fCKUfoFZSmVqpJJiXcsMjq+2gWW0fW22lyTfXCAYj1KSwUZOWukdt/oU6LPYtdhUanxfaPi+0e15o+nPoSu3vUWt5l3owMyiU2OAjRHeabcXSd2JFMKBG7xu1lcpG7ll02CSfMKTf96zWrOmBNb1hTY+s6S1reseanljTe870IFnTs/ZaSD1jkmnpCXv0ie9aas8fYWh79K/ftSRbelARegXOtecQ6ughnDICvZGs6RVres2H3kOPHljTG9b0qdc5o/neJF7nUNtUQzK9DhImXueQ1mP0idc5EfrEewokfUdPEbUH02SE0KiE3rUm3oEYr4rQsKZPvJ6O0CfegYjQJ96BiNCzPstg6s48Sm9Td+Zx+tSdeZw+eWcepWfttZa111rWXmtZe61l7bWWtddaxl57CdOPbJ9n82JVP+CyPpWLq+ddjp+7n2+C+As=","brillig_names":["member_count"]},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"admin","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"]},{"name":"split_group_balance","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debtors","type":{"kind":"array","length":10,"type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"participants","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["split_group_balance"]},{"name":"balance","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VYW0/bMBR22qSNk1V0Y9pF2oN/AUoBbTzsAcRlT2PSLu8LTToypQlKU6D79avBp/lqksBEMglL5Tj28Xe+c3yOnWCw22Yuf4bqWzCmN9LZV9J7XBs1iOW1ydN4Ijw7T4Rnt0GeBvA0iayJA+CEDFC3xDGpZ2ljsm1Cf0PJ0zQXURLlkR9Hf8IA1V9Bf0vJk3kyzqM0EWd+7CfjUIz9RKRJvBBnsh/HYSBmuZ9Hsr9AtPfQ/6jktzzN/F+hmMVLFp5Iln+Xy9KrMNgSODcT0/ksl8BZLiZZOhWjLcT+Dv23Sh5kmb9YuhaE1yKd5yKdiLN0ngQzXPgT+u+U9PM8nF7kIk+FHwTiKsrPRXoZZpMlsVU4F0pydrsNstFW7atn73FtxIFco9h7u3sSu98O712JbbeD7UnOhwqc+JMtWQpH6oGkoX4DVpQKrR+woqSOYIxK5xjGemrsxC5sDlgx/8kuOMi2CWOUM8+Wv6Hq+5fTLxfjNAgPgiALZ2tJibGraw/F4/+A90bHO53HcTSJwuz4Oprla7hOCS4dSx121x/kgvNMm+ca1r569h7Xbu494mIqbEfjZYHOSyVfVPBE/xu8U0cWK/LydQ0HzN8qXg3W3o6eP2jbAWm2Y/9m/xzNPtnqQEy4xmnI1veXuHENS89NXEf132J8PczPKv+kfbcd+9vPlW/EwdXiyEFawLMh+ztV+dxrx9/afO6B723mc0+zX5bPrsZpCGOYz66G5WpYuI7XrCvLuZbu81XOEQey42g+c7a+Pw3Z9wibYtmDONAcxrjJbyf9PjLY3XMK76MPSlbdBZY2VpffZeclA5/b2u86Trj3vB37o7IzlpfERM9HrB0TxiyIGa3tgx+yyZw6BH844Jgl+hbofAaME9XfYOX32X1+GWCLdPR62wDMPviE3Gisq611K7h1wQ7aJw7UqPZIV76P0jvY6n1UfRZ+Df3gIe/Md76nS3Q4K3xpI9/wrMb97sI46fxQsqrGu3bBmaRpt8J9W8IGYJviZ4G9++4Og63/iwLvJYrDEHRs8Ot/ngF9sKv71tN0aC3um69k2b7hOUHxGZTg4Tkh66hH35QQ775d4Jig0wFOpHMOuL/BrqXhyvnrknlqdWe2CfnI28nDm3vSsQv/TLBlgv+k4wAPC54vwR/XXvdnVVdKyvjbqu/a1essbd0QdGxYx7V1XNs3uQdT1XfYeo01mfu41zJ3/wJobDR3NBcAAA==","debug_symbols":"5ZvbbiIxDIbfZa65iBMnsXmV1aqCFqqREFRAV1oh3n0zXeZAZ0pa0VSxcgMZ+LE/R8R2oplT9bRavj4/1Nv17lDNf52qze5xcax323B1Os+q5b7ebOrnh+HHlWpewLzpDy+LbXN5OC72x2quZtVq+xTew2/X9WZVzb0/z0YyNv4iZOs7KVia0KJWrdUw5F6t1ITasYaL2gUvV+rfswrwDmpQgBclKIM/ym3vmW1v2tnm2GyDJm5jNGgj1AS2VZNWekTtvoU6TPY1dmPapzNN6UxzMtNafdp0o4YvqfWX1JOZATzYFt/7SKiavL6INUP/v9L85gBTO7CpHbjUDnxqB5TaASd2YFRqB5DagU7tIPVKNqlXskm9ks0HK5na7AikbCSvQ9cMuUFa9zhVnm1nl2mAwlN2LXV132EPbgAn1X1vo0ZR+iKipCKi5BKiRFVElFBElLqIKE0RUWIRUdoioiyi98Eieh8sovfB+3sfUKg7B8yROD95tOOcaw//yPQmwzhAWyURGiRCa4nQRiI0SoSOV3WIQjvbQ6srD2O1ZW7VToE7D4/XJ9Tetgk4DOlK3dA70fReND2JpmfJ9E6JpgfR9Fo0vRFNj6Lpc8/3hB092ff0PvOcQ92tCWHoRvQ/n3M6004ZiNADY2c77Pb6/WDY7jX0WjS9EU0ve9Vm3qVRd9eUJRzdIuQz79JI6xv0lH3G5J6eImo22GKz8WYUa+Y93e3qQJn3dBH6zHu6CD2Kps/8/CRCn/n5SYQ+88ococ+9Mt+mz70y36Rn0XsZFl1rWXStZdG1lkXXWhZda1l0rWXBtfYcLv8s9vViuVldngFav24fB48EHf++/P8miP8B","brillig_names":["balance"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"7Z3bjiy9daTf5b/2BQ+Lh/SrDAYD+QgBgmxY8gADQ+8+9XftyqruzCS7lSwykituDMnK3c31xd7JiEUm+T+//cu//tN///v/+eOf/+0//vLbP/6v//ntT//xz3/46x//48+3//Y/f/uH3/7pv/74pz/98d//z+v/+zfz+/8R//H8X/7zD3/+/b/+5a9/+K+//vaPwaR/+O1f//wvt/+U0+3P/9sf//Svv/1jSn/73//wm8hP/0SMe38iW/vrTywmfP0T6ad/Ipm9P2Ftir/+iLXZfv0z9u/4M+7nfybnvT+zuLD+Ebu8/pF/2DwbbXiUHu3i14dz2HlYbHj8ZLHp+bCLH4NZgAazGKTBWKTBOKTBeKTBCNJgAtJgItJgEtJgkN7AC9Ib2BqkV7A1SO9ga5BewtYgvYWtQXoNW9P3bRPS0+0+f65b8sdgbN9/UtGYx7MmbgdjkQbjkAbjkQbT4J+TfxmMlAfzfNbK8+d6uf9rsgFpMBFpMKnvYJJ7/ODFbAeTkQazAA3Gma6Dcdb/etZ5ux2MRRqMQxqMf+NgPn6BvPsXhHf/gvjuX5De/Qvyu3/B8uZf4M27f4F99y9w7/4F7/6X7N/9L9m/+1+yf/e/ZH/+X7J7elRnw6lE5jPUaBak0YiBGo2FGo2DGo2HGs35l6B3+TEaH3LFvJl1wc0Z+eyyd8Zu7Dp28/Kj3bLzcIqPZ9NrA2WfyWPE8mIhdx/1Jj3spjevPzf+HawDWXdjHcm6G+tE1t1YZ7Luxnoh616sgyHr56MfRCyJfCHiSOQLEa+RSHwMQqLbEBES+UJEZeooElGZDZZHz0CW7XtEpYMvElHps4tENLrhsP7YYONXIlGjZy0T0ehZy0REIxEvDyJ+S0TjXBPlsbsvRrMhonGuKROBnmtuy1vPTsbrXs2PsSfoWeG2KF0aO/T729q0jj2bzdihuwOVsUPn+MrYe89w6TG5OGsyWlfmvV3SFMi6G+tI1t1YJ7LuxjqTdTfWC1n3Yp0NWX9OUdmSyBcijkS+EPEaiZRWh7KQyBciKlNHkYjKbFBaHcoqHXyRiEqfXSSi0Q0XV4cWjZ61TESjZy0TEY1ESiuIi8a5prhetmica8pEoOea4gqiM9CzQnEF0Rno93dxJcsZ6O5AZezQOb4y9s4znBW3jj1FtK7MW7ukzgSy7sY6knU31omsu7HOZN2N9ULWvVhbQ9afUpSzlkS+EHEk8oWI10iksDrkGhy8ORsRlamjSERlNiisDjmr0sEXiaj02UUiGt1waXXIOY2etUxEo2ctExGNRAoriM5pnGtK62XOaZxrykSg55ryCqKHnhXKK4ge+v1dXsny0N2Bytihc3xl7J1nuNuS5WPsThJaV+a9XVIfyLob60jW3Vgnsu7GOpN1N9YLWfdiLYasP6cosSTyhYgjkS9EvEYipdWh3rcyXICIytRRJKIyG5RWh0Slgy8SUemzi0Q0uuHi6lDQ6FnLRDR61jIR0UiktIIYNM41xfWyoHGuKROBnmvKK4gRelYoryBG6Pd3eSUrQncHKmOHzvGVsXee4UJ4jMYlU1v99NbER4vShpckKPexhwuPPV547OnCY88XHvty3bH3Ph286djthcfuLjx2f+GxX3heTReeV9OF59V04Xk1XXheTReeV/OF59V84Xk1X3hezReeV3ufUtt07BeeV/OF59V84Xk1X3hezReeV5cLz6vLhefV5cLz6nLhebX3aatNx37heXW58Ly6XHheXS48ry7XnVe9ue686s1151VvrjuvenPdedWb686r3lx3XvXmuvOqN9edV7257rzqzYXnVXvhedVeeF61F55X7YXn1d5nDTYd+4XnVXvhedVeeF61F55X7YXnVXfhedVdeF51F55X3YXn1d5n5jUd+4XnVXfhedVdeF51F55X3YXnVX/hedVfeF71F55XPfa8mt069iVuxo49r5bHjj2vlsfeYF5dHh8MRpFQHrtd5PE32Bn7LPTWr9h72tj1DCZrnPWfnv8Yfrr28PO1h79cevgtTuUaOXx77eG7aw/fX3v4Aj18Z5fn8L2rPR/DWm18OX3P/6o1KKoVez5vWyv25N+2Vmyn0LZWbFvRtNaA7UHa1optWNrWiu1u2taKbYXa1iqKalXkm4Ii3xQU+aagyDcFRb4pKvJNUZFviop8U1Tkm1qco3aZWhX5pqjIN0VFvikq8k1RkW9KinxTUuSbEvic87oclcOn5z+Gj/268f45fP96pOzf8fxHudhvnB+Wm+Rx3q5NL/eR/PqbmbHfOG1rxX7jtK1VZqo1r3uqbP506+zOw9k9LhLJTjZYsE3iG7H8Pos9f3bcgJnqFf8jMNaYtUhZNmCmmgwaglmmmjlagplqmmkJBrt7OBAMdqtxIBghmH0w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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"admin","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/7VX34vTQBDepEm7TS1Xf4GCDwuCTwrpoYePrVpBhAr6IPqWa1INpMmRbu+u/vVmezuXL3tpUZoMhJlkZ7/5dnZ2kljsRuzisrTtwjNTyGeitX+cjBvE8tvkaTXI0wKeNpF18IGxCLRt8MXx+2CfaD3PpIjTWMZBEv+JQnR/BPZLrT9u0oWMs1QE4SpOxSJIRZYmW3EeFXaSRKFYy0DGyt4i1huwn2o9zfNgWwQPo2uRbaTIluI826ThGidOwX6mdSBltLqQQmYFjVBcxfK3yC6jfJlkV7cL/ql1n5UJoyRO9L1/nIz7QK5R7LevzxS22w7vU4XdbQfb7xUY7/kNFvGnWJ3i+qDHSFv6GupxBvOHrCxk8ldqwMrxGS+xlTyEZ1QL94prpO3gcvXlYpGF0TQM82hdKTbMySH5V7zef+A9MfHmmySJl3GUz67jtazg8hpcZdus2hy6NVzqOrYSsyaU30Tf+8fJrjNSfEdjc4OjCz4PDG3yxPU32HXHLivr7fEBDkPgwIALigO2DfMcdnc9LZ3F00OcKKbHqi+LJvujxao16LC7LzGVk57Bqa8vkkkzfPwRxCJ89Ywb+cH4TfdHtV7X4KDW/Rzi9Yx8mf54Vl4Bxgttn8A4nhVzL8yeYEEs8sE9IWwOPJQMYZzDs44xd7CHW4dV+wCDeVizE63942TMgBuDGMRB9WP6+rntx99klge/oq9RUPlKqvvQMu87e3xaPPu7s+exMqdYR5hr8jnTel+/6+jNwvPj8Fa4nyrYGcYmvhDPA34O+GAtm/WO+VAyAh88+/jebnpPHIMTccGYxLNr+DjAn3zeaV23b9jbKD/DGjzsP+p8dumbCvLd4+UcB3xs4EQ+nwD3M8Y1cNX4j5pxkkPvL6q9Xa9upw53f2EefMs6EMuB9ZOPBzxcuP8O6xnw6nooF4S766/aHvD981xj3gh8OMzrG/P6xr6pPZhr22PVM9Zk7eNeq/fAXyN18dhWEAAA","debug_symbols":"1ZrfboIwFMbfpdde9PTvqa+yLAsqGhKCRnHJYnz3lQ2KCqEzTtNzoy18HH5t2n7tCSe2yhfHzUdRrbcHNn87sXK7zOpiW/na6Txji31RlsXm4/Iy480PwI/+sMuqpnqos33N5nzG8mrl//2z66LM2dza82wgc9K2QqdtkILGEa0SvIvqi65Xcz6iNk5Aqzb+LVfq9xkD8QA1cFCtErhUL+WWj/S2lV1vu1hvg0DXtVEqHaFG0J0aBRcDavUv1L6zr7Gb0Pp5oc3zQtvnhcY/h27U7h614HepR1cGABsmDzgRm2lGh7a6/gWAckStnevUhoOJjFltdbf4+CLejlkhSNNL0vSKNL0mTW9I01vS9Eia3lGml5w0PWmvlamvmKgCPeoBfeKzFsP5wxfNgP71sxZ5oJcQofcBwzkEeD9ypG+Jp1ecND2Qpic9a1Xi+xwMqRGNapAHUInvc1CIKfrUV8xp+sT3OchdT48RtZOqWxF8uknetlUnviua9jad+K4oQp94BiJCn3gGIkKvSNMn7swR+tSdeZo+dWeepid9ltHJO/MUvSHttYa01xrSXmtIe60h7bWGtNcawl579tXPbF9kizJvP1NYH6vlxVcL9dfu944XfwM=","brillig_names":["admin"]},{"name":"add_to_group","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"approve","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"5Z1tT9tADMe/S1/z4mzfg81XmaapbDBVqsoEbNKE+O5LWXMpTYhJKcVW3kAKvuTn3PX+5/Ml97j4cX31++e31ebm9n5x+eVxsb79vnxY3W6aT49PF4uru9V6vfr5bf/Pi7D9AfRsf/9rudl+vH9Y3j0sLsPF4nrzo/ndlL1Zra8Xl6U8fb1YQJxknSZZ50nWZZI1T7KWKdYYJlnDJGucZD2pLnFSXeKkusRJdYlvr8uLnplQ2RlKKtUUEg/YRgztWZtD6axDGLDOgrCzzs1VXlhvqfkd1BAg7iwhUDwrt7znbhdq77ZodxuQpfWRYlKoGVJrzRjwkJrCSaibm/0Se3tq+LhT48edmj7u1IM9A0hsv2kgOWntO6d6BelogGnAOom01jlAVlpKKqkFaQ6511KSa/rsmr64pmfX9OKZPgbX9OCaHl3Tk2t66z0mx0rP6ZA+GW/3XMfNzWHu0Z+/3XOo9AQKfXPCOn6G0LUcajzZ0pNr+uia/pUxZoFKzzJOHym3Y/BIReMpoeDOugTuxXRJHzUKHkTdqRxRho8oMzguaUK8vCuDIWnhCtQYP+/5XuJQzaXQ1UG1RZGh8yau4WyOHThBHLTuQva9ABVl62UOs/ASZuElzsJLmoWXcRZepll4mWfhZZmFlzwLL2cx9imzGPuUWYx9yvvHPhAidnGZKH6+MWORcwuQt+HdXqi3hSaP0NEjdPIIrY8bclSgMdb5ACzpxRUGaKibayDRMp8k7axBDHFvpgGf2eXs7JEqe9bYM6S2MptDOpyX4OE2DjVnj5DxtLM8J5yb5eSaPrumL67p2TW9eKaX4JoeXNOja3pyTW+9vx/NJDa/bOOPpxIhnP97OymfRaWmaIjz4SgTAvrGJ9/40Q++UB8/+cbPvvHfMFLmffznQnxMITmiEIRjCsExhV7pwyDUQpQ/L8wHpDrvgXvLodt6hHR2/BNG+jD8iAUitddAzDCOz6GuAM9FwWFK3BqTxD6OmMIZfkjk83DAFg7awiFbONEWTrKFk23hFFs4tnpltNUrk61emWz1ymSrVyZbvTJl48M1acfKGUPp4xfj+Iyj+GwbH2tLywjcxxfX+DH4xgff+Ogbn3zjR9/4xmcZNHzjqqvhG1ddDd+36kbfqpt8q27yrbrJuOo2E+IdvvaKEImVROJ+vqJ11rhGjzj7jG9cozV865kABd96ZKzgW1/9NL6OIltfR1FBEsd+YJ+Nr39ixFF84wuguhmwBp81laDYfmWFSj/ll42vl1KW7LzyaKAbfOOrkzV848vVNHzj65M1fOMLlDV84xqt4Bffax2LdY1W8M1r9Di+b9UtvlW3+Fbd4lt1i2/VLb5Vl/UnoD/3WcTxlDejcfzxlDeTbXxl/vSVR0Hd4Cff+Nk3fvGNz77xjT+DruBL8I1vXHU1fOOqq+H7Vl3xrbriW3XFt+qKcdU9acpbjGu0krUU6++JGcXHYFyjNXzrkbGCH8/+MuYTprwxGN/xYzzljcH4lh/jKW8Mxt9gr+Eb3/TjlBl7DMb3CBmfgEQwvkmIhu96twQE49uEaPjG9wnR8I1rtIZvXaMVfOsareBb12gF37xGj+P7Vl30rbroW3XRt+qib9VFx6r71Hz8s7xbLa/W17t9oG9+b77vbQv98PfX//80xv8A","brillig_names":["add_to_group"]},{"name":"make_payment","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"calldata_length","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["make_payment"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"PublicGroups::admin_abi","fields":[{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"PublicGroups::balance_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::balance_parameters","fields":[{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"PublicGroups::split_group_balance_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::split_group_balance_parameters","fields":[{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debtors","type":{"kind":"array","length":10,"type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}},{"name":"participants","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}}]}}]},{"kind":"struct","path":"PublicGroups::member_count_abi","fields":[{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":64}}]},{"kind":"struct","path":"PublicGroups::in_group_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::in_group_parameters","fields":[{"name":"group_member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"boolean"}}]},{"kind":"struct","path":"PublicGroups::remove_from_group_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::remove_from_group_parameters","fields":[{"name":"member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"approve","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"PublicGroups::set_balance_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::set_balance_parameters","fields":[{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"PublicGroups::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::constructor_parameters","fields":[{"name":"admin","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"PublicGroups::make_payment_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::make_payment_parameters","fields":[{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}}]}}]},{"kind":"struct","path":"PublicGroups::add_to_group_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::add_to_group_parameters","fields":[{"name":"member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"approve","type":{"kind":"boolean"}}]}}]}]},"globals":{"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"}]}],"storage":[{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"group_members","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"group_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"member_count","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}}]}]}},"file_map":{"24":{"source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n","path":"std/embedded_curve_ops.nr"},"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"29":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"34":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"58":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"77":{"source":"// mod test;\n// mod types;\n\n//this will be a little test to make public groups in noir\n\n\ncontract PublicGroups {\n\n    use dep::aztec::{prelude::{Map, PublicMutable, AztecAddress}};\n    use dep::std::hash::pedersen_hash;\n    use dep::std::collections::bounded_vec::BoundedVec;\n    use dep::std::collections::vec::Vec;\n    // use crate::types::bounded_vec_wrapper::AddressVec;\n\n\n\n\n    #[aztec(storage)]\n    struct Storage {\n        admin: PublicMutable<AztecAddress>,\n        group_members: Map<AztecAddress, PublicMutable<bool>>,\n        group_balances: Map<Field, PublicMutable<Field>>,\n        member_count: PublicMutable<u64>,\n       \n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.group_members.at(admin).write(true);\n        storage.member_count.write(1);\n\n        //emit event for the admin assignment\n        context.emit_unencrypted_log([admin.to_field()]);\n    }\n\n    //helper functions to read variables when testing\n\n    //read the admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    //read the group members\n    #[aztec(public)]\n    #[aztec(view)]\n    fn in_group(group_member: AztecAddress) -> bool {\n        storage.group_members.at(group_member).read()\n    }\n\n\n    //read the member count\n    #[aztec(public)]\n    #[aztec(view)]\n    fn member_count() -> u64 {\n        storage.member_count.read()\n    }\n\n    //read the balance between two addresses\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance(creditor: AztecAddress, debtor: AztecAddress) -> Field {\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        storage.group_balances.at(key).read()\n    }\n\n    //functional methods\n\n     #[aztec(public)]\n    fn add_to_group(member: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        storage.group_members.at(member).write(approve);\n        if (approve) {\n            storage.member_count.write(storage.member_count.read() + 1);\n\n            //emit event for the member addition\n            context.emit_unencrypted_log([member.to_field()]);\n        }\n    }\n\n     #[aztec(public)]\n    fn remove_from_group(member: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        storage.group_members.at(member).write(approve);\n        if (approve) {\n            storage.member_count.write(storage.member_count.read() - 1);\n\n            //emit event for the member removal\n            context.emit_unencrypted_log([member.to_field()]);\n        }\n    }\n\n    //this set balances but only between two people\n    #[aztec(public)]\n    fn set_balance(creditor: AztecAddress, debtor: AztecAddress, amount: Field) {\n        assert(creditor == context.msg_sender(), \"cannot adjust someone elses balances\");\n        assert(storage.group_members.at(creditor).read() == true, \"Creditor is not in group\");\n        assert(storage.group_members.at(debtor).read() == true, \"Debtor is not in group\");\n\n        //cant store the addresses in a tuple in storage so hash them together,\n        //easy to know who owes who as hash a,b is different from hash b,a\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance = storage.group_balances.at(pedersen_hash([creditor.to_field(), debtor.to_field()])).read();\n        let amount_to_write = amount + balance;\n        storage.group_balances.at(key).write(amount_to_write);\n\n        //adjust the balances\n        //balance between creditor and debtor\n        let creditor_debtor_hash = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance_creditor_debtor = storage.group_balances.at(creditor_debtor_hash).read() as u64;\n\n        //balance between debtor and creditor\n        let debtor_creditor_hash = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let balance_debtor_creditor = storage.group_balances.at(debtor_creditor_hash).read() as u64;\n\n        //if the balance is greater than 0, then the creditor owes the debtor that amount\n        if (balance_creditor_debtor > balance_debtor_creditor) {\n            let difference = balance_creditor_debtor - balance_debtor_creditor;\n            storage.group_balances.at(creditor_debtor_hash).write(difference.to_field());\n            storage.group_balances.at(debtor_creditor_hash).write(0.to_field());\n        }\n\n        //if the balance is less than 0, then the debtor owes the creditor that amount\n        if (balance_debtor_creditor > balance_creditor_debtor) {\n            let difference = balance_debtor_creditor - balance_creditor_debtor;\n            storage.group_balances.at(debtor_creditor_hash).write(difference.to_field());\n            storage.group_balances.at(creditor_debtor_hash).write(0.to_field());\n        }\n\n        if (balance_creditor_debtor == balance_debtor_creditor) {\n            storage.group_balances.at(creditor_debtor_hash).write(0.to_field());\n            storage.group_balances.at(debtor_creditor_hash).write(0.to_field());\n            //this is not setting them to 0\n        }\n        //if the balance is 0, then the creditor and debtor are even\n        //the values should never go below 0 as as you are subtracting a larger number from a smaller one.\n\n        //emit event for the balance set\n        context.emit_unencrypted_log([creditor.to_field(), debtor.to_field(), amount.to_field()]);\n    }\n\n    #[aztec(public)]\n    fn make_payment(creditor: AztecAddress, debtor: AztecAddress, amount: u64) {\n        assert(storage.group_members.at(creditor).read() == true, \"Creditor is not in group\");\n        assert(storage.group_members.at(debtor).read() == true, \"Debtor is not in group\");\n        //make sure the payment is less than  or equal to the balance\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance = storage.group_balances.at(key).read() as u64;\n        assert(balance >= amount, \"Insufficient balance, or paying more than is owed\");\n\n        //subtract the amount from the creditor\n        let amount_to_write = balance - amount;\n        storage.group_balances.at(key).write(amount_to_write.to_field());\n\n        //emit event for the payment\n        context.emit_unencrypted_log([creditor.to_field(), debtor.to_field(), amount.to_field()]);\n\n    }\n\n\n    //same as the above but with a fixed vector of addresses\n    #[aztec(public)]\n    fn split_group_balance(creditor: AztecAddress, debtors: [AztecAddress; 10], participants: u64, amount: u64) {\n        assert(creditor == context.msg_sender(), \"cannot adjust someone else's balances\");\n        assert(storage.group_members.at(creditor).read() == true, \"Must be part of the group\");\n\n        // //calculate the amount per participant\n        let amount_per_participant = amount / (participants as u64 + 1);\n\n        // //update the balances\n        for i in 0..10 {\n            let debtor = debtors[i as u32];\n            if (debtor.is_zero()) {\n                continue;\n            } else {\n                assert(storage.group_members.at(debtor).read() == true, \"Debtor is not part of the group\");\n                let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n                let current_balance = storage.group_balances.at(key).read() as u64;\n                let new_balance = current_balance + amount_per_participant;\n                storage.group_balances.at(key).write(new_balance.to_field());\n\n                //emit event for the split\n                context.emit_unencrypted_log([creditor.to_field(), debtor.to_field(), amount_per_participant.to_field()]);\n            }\n        }\n\n    }\n}\n\n//can bypass the whole making a bounded vec and just use an array of addresses\n//skip if the address is zero.","path":"/Users/niallcheetham/dev/aztec/publicgroups/PublicGroupsRoot/contracts/publicgroups/src/main.nr"},"79":{"source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: Field = 3;\n// ADDRESS_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[aztec(note)]\nstruct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/address-note/src/address_note.nr"},"85":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"100":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\nuse crate::hash::ArgsHasher;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    args_hash: Option<Field>\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs, args_hash: Option::none() }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            let mut hasher = ArgsHasher::new();\n\n            // TODO: this should be replaced with the compile-time calldata size.\n            for i in 0..self.inputs.calldata_length as u32 {\n                let argn: [Field; 1] = calldata_copy((2 + i) as u32, 1);\n                hasher.add(argn[0]);\n            }\n\n            self.args_hash = Option::some(hasher.hash());\n        }\n\n        self.args_hash.unwrap()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"128":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"141":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"158":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/initializer.nr"},"159":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::oracle::logs_traits::ToBytesForUnencryptedLog;\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (n as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/hash.nr"},"165":{"source":"use dep::protocol_types::{\n    header::Header, address::AztecAddress, constants::CANONICAL_KEY_REGISTRY_ADDRESS,\n    storage::map::derive_storage_slot_in_map\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{\n    public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys,\n    constants::{NULLIFIER_INDEX, OUTGOING_INDEX}\n},\n    state_vars::{public_mutable::PublicMutable, map::Map}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\n// A helper function that gets app-siloed nullifier secret key for a given `npk_m_hash`. This function is used\n// in unconstrained contexts only - in Note::compute_nullifier_without_context which in turn is called by\n// `compute_note_hash_and_optionally_a_nullifier` function that is used by the NoteProcessor. The safe alternative\n// is `request_nsk_app` function define on `PrivateContext`.\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"174":{"source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"183":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"224":{"source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"233":{"source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // We choose the last SELECTOR_SIZE bytes of the hash to avoid getting the first byte that is not full\n        let hash_bytes = hash.to_be_bytes::<SELECTOR_SIZE>();\n\n        FunctionSelector::from_field(field_from_bytes(hash_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector = FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"296":{"source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"298":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"299":{"source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"301":{"source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"302":{"source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"305":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"306":{"source":"use crate::{\n    crate::address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"314":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"346":{"source":"use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    protocol_types::{\n    traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    point::{Point, POINT_LENGTH}\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul};\nuse std::hash::from_field_unsafe;\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.value);\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> ValueNoteHidingPoint {\n        ValueNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    /// The following method needed to be implemented because the note is passed as an argument to a contract function\n    /// --> the serialize method is called by aztec-nr when computing an arguments hash.\n    /// Note that when the note is about to be encrypted and emitted as a log the to_be_bytes function auto-implemented\n    /// by aztec macros is called instead.\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n\nstruct ValueNoteHidingPoint {\n  inner: Point\n}\n\nimpl ValueNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_value(&mut self, value: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(value.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for ValueNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.55.1/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}