{"noir_version":"0.34.0+02fea6abe8637b9fb8f9535d1709b367d5e1da5c","name":"PublicGroups","functions":[{"name":"in_group","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"group_member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/7VXTW/TQBBd13ZiO0QNXxJIHPYIl5IUkCrBoVUBCZCKRCWQOABu7BRLjl3Zm37w6/G2O+3z1IkKtVdydmLPvnkzszNeW+JiWObSw4V7fNC9bTOPbzcmLWKNLc5T/zg3cMZa4vR6g7yXK5lkiUrCNPkTR6j+AOTnZn6/yKYqybNqzc/DIl8cyWmYyTxLz+RBXMlpGkeyVKFKtHyGcE9BfmPmfZUX4WEsy7SiMZZZ9Vsty0/iaEPis1LOF6XSwIWSsyKfy8kGYn8E+bGZd4oiPKt4RvGpzBdK5jN5kC+yqMSFX0F+YuZQqXh+pKTKZRhF8iRRv2V+HBezithlPHMz+9W1ZmTKz7b5P77dmPhArlXsrZevfFHfS23zdrvBHvcrjF3vAov4k61hddlGJh3P5IievzX3Se8+3KPc3qmukZHD4/nno2kexTtRVMRlbfOsaiw4borX+we8Rxxvb5GmySyJi3enSalquP0GXC2viau9i/4gF3yOw2d8td62+T++3Zhg/3IMdp/xckGHYnuvgaeO1UMjX8bqQ7l/3qJ2q2bzPwnwgZAQ7b49XHCQ+PQbnH64wumO+G0OgRPa6qjYX/A8OCCTzUDU89ZmI8ONSPZ5YeiYeIzTCO5h8XkMy2NYuI4aVJfN1BJXzXGZf76JcQf2N+8afOIQsDh6wAH3XUv2x0LUa4vs9cCuDb5bLcc+gLhbwMUGTqTzzMxN9T4U9Xpv4t5m3lbVJdkMRH3vt12XNrNPtrAuA8ZpBPcox+vwHPlyfJvhj8T1fA3ZOsISDEs0YHEOQ3H9gKM5bwFuHzCdBn0XdHYB47WR12EN7pUe4+swvmibdPDFTNjcJ3uJPYo3vvQF6NkMm9YMjB2eBxv4IJYe2O94vevDAn31XB4WzHfIlziMbnJWsBpsWQ0cOuqpE4qLHq6o5w/7K+l8MvOyvmKbIPWBu+N1wn1Tw34H2xQ/F+wNgJ8DOrg3A6YzAFmPpj7AD7Rt54TXi8Pso289poPvKNL5ZuamvGE/wY8fjof9RNdRjz6OIN59r86ZdNaAE+n8ANxfYNdluPp51vCcxqqeSXvv/NzQzT68eDd7V/45YMsB/0knAB4u/E/Bn4FX94diQbg6/p6RB97ydS5bNwIdD9b5bJ3P8qZzMDVyIOo11ubex1zrvfsXCF+Ii6ITAAA=","debug_symbols":"5ZvRjtowEEX/Jc88zHjGY5tfqaoV7MIqEoIVsJUqtP/ehBKHhtTRLqXyyC8ogZv4jBP7jofkVL2slu+vT/V2vTtU82+narN7Xhzr3bbZO33MquW+3mzq16frrytoP8JZfnhbbNu9w3GxP1ZzdIZn1Wr70m4SNydY15tVNXfN5o04kLtog3VRigIjWobgL2JG6NXBjYhFQC5iEWOuxd9nFcLd5AgYxXAlfjw73t/rjrpeD1O9jobjiQkgTe4ChovYBbkhN/+QvOn0P9HbBujRDfCjG7CPbkDubsASdGJLZuqOsAG6O0KQhneE+yRNe4z/wjHh88cY+MIx42OTfDf4kdFMXD6D3dh02F89Z8fGpu36FoOPWoKxCxGsj4NeuIegdoIZUfeTG/RiE85RmiKipCKi5CKitEVEKUVE6YqI0hcRZSghSoIioiwi96Eich8qIvchLiLK+3MfBO4KEtgsKifiZMRY6vDpE4vrukT81VLVnxdTJFrBnVZwrxU8KAVn0Ao+7faEU+DOj4L70aqT+A7HOsB01ckym07MPKw6sVHMTorZWTG7VcwuitmdYnavmD3oZbegmF2xr1rFvmoV+6rNfH6XENkdDNkzn2e8jewBB+zy/+cZiTgOZYLddI9WWOqlhOe/gQX1ohu96KQEnfkGnfWiW73omWe/qZld8s5+rYmOamn4pJLk7UoW3N/ZXebZb+CendLiYCBWwQ3JMNDMU+VU6uAyT5WT7Jmnykl2VsyeeQkqyZ75EiXJnrkJJ9kzL0El2RUvDX3mJpxkV+yrXrGvesW+6hX7qlfsq16xr3q1vvrR7P1Y7OvFcrO6vCS1ft8+X70zdfz59vuXRvwL","brillig_names":["in_group"]},{"name":"add_to_group","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"approve","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"5Z3bbtswDIbfJde9ICmRovoqwzCkWzsECNKh7QYMxd59ThfLObg0lp5I+KZIGsr6ZMv6JYoCHxffrq9+fv+y2tzc3i8uPz0u1rdflw+r20337fHPxeLqbrVer75/2f/3ArZ/EJ7s738sN9uv9w/Lu4fFJRbKF4vrzbftx5S7K9ys1teLy9J9PDGuqexsK5dmigIjthmq7owzwmBdy4ixCMjOWIRo3/jzxQLxxeQI2Ixhz/jt2enld72k/q7XqbuOlNuFE4BNXirWnXGpckKeXpG8u+mH6NsK8ltXwG9dgbx1BWW0gircF6qapnp+6fsydlUMNeiYNYvCzpoLoN1/OGfqjXNOx/1HA7PXuOwEgdkxMDsFZk+B2XNgdg7MLoHZA+sqBdZVCqyrKbCuJudjpNTGXuCY3Xl/V27sFY/Z37+/t0tzQbHZt9drl8Zh/Zcwb+EzRIbHyPDPTCW1f00I9rwSo/CZBHsXBkmdcGEU7h07UsqxIyBPTQ4JEPZptmXyGWX4jDKjkxCC5gUhEJ1YgVN/o2oZ3l8sPPbcGIbuMzw1GLuplbX5bSTvPeOtj2jEevBPwWBM9amVZRat1Fm0ss6hlQyzaCXOopU0i1amWbQyz6KVPItWzmLuw7OY+/As5j788rkPQpbRRdloOzO2RRBOXFhKf0tEy8FarwMXiAqOUcEpKniKCp4nwZUmwEl6JySS6kENIzTQVvYCOhGrkErv+0h131/ytE0u5d3RSRs6T6B342fvXek+6pF3pYx3dOR+0CUsk/3lg9zKJQVmz4HZOTC7BGYvgdk1MHuNy64QmB0DswfWVQ2sqxpYV9X5+G5tk1fn76q1TV7f/139n83aNGwap5KPFx81RYbPkeE5DLziCbxEhi+R4adnwnoQtb8tU/+/TOcAPacQnlOIzin0zMBF0grxxzl8kKj5qCml44eIIO9O/2o+H4Tx7kTNLU809f4U6Z1benjo6NRUEXtyRc7HMOMHwz4KBj3BkCeY5Akme4JhTzDiCaZ4glFPMJ5GYPI0ApOnEZg8jcDkaQQmTyMwFd+TMW1OH62nJ7TVN7wUC776hq99F+MKJ6dsE0SGx8jwFBk+RYbPkeE5Mrxzj4EN71xhbXjnCmvDR1bYHFlhc2SFzZEVNjtX2ObX7uCzbVwT9hw18WlLncvxsy19gncuxza8czm24Z3LsQnPzkOSrDAHZN9xDkzN1cDpZLXOvoOSGIoF7zwqaVA0TmlCFKidv6+U5KSlOW4sDbLz4GAb3nl0sA3vPHzMhnceH2zDOw8QNuHFuRzb8IHDDlGcxwjb8M7l2IaPrLASWWElssJKZIWVyAorkRW2TB8mVrfb0yX5hje3p585ZekG3vSCFo4ML5HhnR/otuE1MnwNDK8QGR4jwztXWBveucLa8JEVViMrrEZWWI2ssOpcYV9ve1qdy7G5z1idy7EN71yObXjncmzDO0+KYW5PV99ZMezt6eo7LYa9PV195wmYgHeeGOPV9tYJnKfRsByJBM7zU9nwzhNU2fDOM1TZ8DkyvHM5tuGdJ6my4Z1nqbLhA6ftIXAuxyY8RlZYjKywGFlhMbLCYmSFxbAK+6f79mt5t1pera93Cchvfm6+7uUjf/j9498vnfFf","brillig_names":["add_to_group"]},{"name":"member_count","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/7VWTW/TQBDdNLZjJ4REFCSQOOwFiWNScgBOqapW6oFWao8IkBNvwJITV86mbfj1eMNO8rzelNI4K1k7tmfevPnYsWtss2p6d1lx1ZjlgcPsC5Udy7PnIHf0fpFKHs9iGYdJ/FtEqH4I8ge9ny1mYxmnMz4V05HIfozTxUzycTjj6SxZ8pHI5SQREZ/LUMZKXiLkJ5Df6P04y8JlziES9zxdSJ5O+ChHjeZoeAryW72HUorpjeQy5WEU8btY/uLprcgmSXq3jvu73oP8OoCcqPwM9X1vt9UPgFyl2B8HA4Vd3w/vXsCKfVIldiPHOPH/YhF/8uXrS622Re8QnlEdn+VXlwp/O728GaeROI6iTMzn/+p723osnvsfeK9NvItFksSTWGSn9/FcFnA9C66SD9imTzEe5ILvcQUGX6U31Pe93VYf546jsT2Dlws6NF9eWHiqXL3S8jpX5/Pr1cg4yWfGUwoQACFWYeAUMHEhPp4l6JcPBN1m5emOnCs+gEdmvrCRyGeTFfNb5VCssWI9HFZu4Dbw8iAnDbAbVsOn1wVfhN9h5Sa28fYM3l1W7oO2YUdYzMBiFiyTA+ag6sGseNaNPCj/78CfC3wdiz6egz5gvNdyh5XzY/642PqhBr7QP/rGmtVht/lz9TvkzcDGM7DJBnNEOq0tcdWBI3JXNfThfqj33m5rQNi0yAdxUMOV5tB6uF7LNAt/iisRRo/5WNaMOGw6GN8+ZkdTY9F8rRvxuqDzWe/b5m7d39gQd8ffC/cjBXsOvil/LvhrAj8HdPAc+IYO2VAeuqxce/MHoOqamOeXuKBP4ukZOvgNJZ0zvdvqhnOR8tO24OHsWs0G+pmEfDf8jY0DOgfAiXS+AO4l+HUNXPX+m+U9rYdmP/WeiivYTx/2VrWAvnfAlwPxk04TeLhw/xXiafnFeCgXhKvy72u55W+3cw27Luj4YBcYdoFRN1WDKy03WfGMVdn7WGv1HfgDyL4CnroPAAA=","debug_symbols":"1ZrbbsIwDIbfJddcxHFiN7zKNE3lqEpVQRwmTYh3X8vawAoKAtYpvkEN/Gk+cvDvWj2o2XyyX34U1WK1VeO3gypX03xXrKq6dTiO1GRTlGWx/Lj8WunmIzvJt+u8alrbXb7ZqTGwsSM1r2bNJdr6BouinKsx15dXYo/car3jIAXSN7RW+6wVW9BntecbYiJNrZjImEvx+0j5l8FBQxDrC/Hg6KBfn3TGbtL9vUkHY8ONUes4OXvwrZg9XZHDH5LXk/4bvRnADD0ADj2AHXoA9/IADnUndmju7QjndbcjCLC/I+hBmqYPP9Ene6KPf7yPuX02HXanAhzdjSvcRQqoF/C8ftnNtaCsm17HGuJr4aw1ndja/loYEMxuBLOjYHYrmN0JZifB7CyYPRPM7uWyo2BfRcG+ioJ9FQX7KiYeI8kHdtY9dpv4Wc1cYPfQZ///s0oBh4Hi7IBBDMhnDoTTo501kuFRMrwVA5/BFbyTDE+S4RPPyGJR3qUd5Z0J7lrXqPrsaWdkTnOEPe2MLM6eeEbm7Zkd42JvdCihG6T+H7VyUyCXeFkkyp54WSTKnnjKH2VPvCwSZU/chGPsJPhRixIvi0TZEy+LRNkTN+Eou2BfJcG+SoJ9lQT7Kgn2VRLsqyzWV4916zPfFPmknLdvby321fTiZa7d1/rnl1r8DQ==","brillig_names":["member_count"]},{"name":"set_balance","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["set_balance"]},{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"parameters":[{"name":"admin","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"]},{"name":"balance","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/7VY30/bMBB2mzQk6Sq6n9qkPfgvQAU2tIc9gBjT9sKkoe09bdItWpqgxAXKX784+OjXIy1jJJaKL875u+/O57NDR9y0bvnrGLkHY7yRzqHpR49ruw1ijdrk2WmQZwd4domsjQPMCZS7sED4fgjytulPMyXjNFZxkMTXUYjqL0HeMf3neTpRcZbKcZAE6SSSkyCVWZos5FjLSRKFslCBirW8QLT3IH80/ZnK8uBXJIukZDGSafm3nJZdRuGOxHeFnM0LpYFzJad5NpO7O4j9A+Q3pj/K82BRuhZGVzKbK5lN5Tibp2GBEwOQ39KYUtHsXEmVySAM5WWsfsvsIsqnJbHbcF6b3hPL5aAlOjTPo8e1XQ/INYr94d2Bxu61w3tPYzvtYI+2Soxj9waL+JOtQfmzjEw6A7HcNp/MmO58mHNixmnucxij9X4iltsnuJh9O59kYXQUhnlUrCQU+r2p/Sve1gPwXnO803mSxNM4yk+u4kKt4Lo1uFruitXy4tRwqav5unmMr9Y7NM+jx7WqthIX22C7jFcPdJ6a/lkNTx0rqm23sfpanFVl67gsQP+zAB4QEqLZw88BB4mPW+P0qw1ODxg/4oz+NbhR93m8bJDJpi9WE7HJ4tkBO2SfbHUhJg7jNIQxC7g5DMthWDiPfG0xvtUFwbvHP08sC13TRf6pwScOPoujAxxa2Bf7WNgF2LLa8XdjPlsQA7sd+1U+W8w+vw8OxHIdSHcIY7jXfIblMyyc52yYxzlgTrSVcz7Y0m2L+YwXECGa/Xggf3tgry7XO+bXlG3c77ZY/R7As4B0Dkz/kLOgpdzd27R3SG77LOA2684Cj3Eawhit8ba4G/c6fL4vhqBvg01ewzbFCrE4B41FF2KswSeA6zB+XB/vEqeA8cXI2+LuGdcBHBrnZ2Nd7eK2Ma4W+GQxe/01PLQe7gNseE4SHunqy+ALI99eBs235/coCO+7NPNnb41Oi2dxld998B3j68M46fw0/braYBlHsa7Zbivc9zRsBLYpfj2w1wd+NuhgfvFzCeOhW9052OKHarUmLuPEP1jRN4fpYC6Tztj0deuGNYHiM6jBw5pQ7SP6+IV4b7lLzjbodIET6cSA+wftMlz9flHzntrGM8Jd+uW1k4fV+erDPxZssGWD/6TjA48ePF+CP3131R+KBeHq+LtG7rvr5/XYvCHouDDPY/M8tm56DVIj+2J1jzWZ+7jWOnf/Aj6A0qVBFgAA","debug_symbols":"5ZvdjtowEIXfJddczPhn7OFVqmoFu7BCQrACtlKF9t2b0MRJQ+pol7ryyDcoIceZb6zYczRKrtXLZv3++rQ7bI/navntWu2Pz6vL7nioz64fi2p92u33u9en4d8VND8IN/35bXVoTs+X1elSLdEps6g2h5fmUJv6DtvdflMtXX14J2btWi1bF6RIMKE1wL4VG4RezW5CTATUiomUGoq/LyrEh8kRMIhhIE7Prh6fdae7Wee5WUdlwo01QJzcMXIrdkx35PofkteT/id6E8CkDmBTB6DUAdzDAayGTmy1mnsiLEP3RBDq8RPhP0nTjOHPj1HwhTH4hTF/WZsGwhi28dlV3qlWrBj7JaT4FkCnDmBSB7CpA1DqAC51AJ86ACcOoCF1AEwdIPVK1qlXsk69kvX0SvZguwBew0ytUtgZEYd9qXJ2yojYAM4+aDVMVR22PjgcMj24btzUhLp3cnCXJRWRpSsiS19EllxClgaKyBKLyFIVkaUuIktTRJZFeB9ThPcxRXgf87j3QTBdXxLr3tJMngYxdDx9/MbkuikhP+hY+VtPxbBQcAtSwVEquJIKrqWCm1lwMwvu/CS4n2w+k+9wrIN+r51sPltjuv5FfThuPlsrmJ0EszvB7F4wO8tlJxDMjoLZlWB2LZhdcF0lwXWVBNdVynx/Jw7sDkbsLvN9xtvAzjhm///7DAUchxRnR9bhfRAethDw9j6IM5LhrWT4zK1kdLnmvdVYFbZJq8dvofm8raQFF2HP3Eqy6dl1XMwKQmtTaRonKrge+Mx9Z5Q9c98ZZc/cd0bZM/edUfbM+zlR9syLcJQ9c78fY+fM+zlR9syLcJRdcF1lwXWVBddVFlxXWXBdZcF1lcXW1Y/67MfqtFut95v2C7jt++F58EHc5efb7yu1+Bc=","brillig_names":["balance"]},{"name":"split_group_balance","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debtors","type":{"kind":"array","length":10,"type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"participants","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["split_group_balance"]},{"name":"make_payment","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["make_payment"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":6,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"12265343917440897559":{"error_kind":"fmtstring","length":20,"item_types":[]}}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"admin","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/7VWTW/TQBC143X8EUoiChJIHPaCxAGhtCqIY0JVpAopSPSA4ObGDlhy7MretA2/Hm/ZSZ6XTVJUZ6Rox97ZN28+dhzbWoutVtdqim0ZXjDLLGjMDO8eg95X66QQPM1TkUZZ+juJ0fwQ9Ddq/bTIpyItch7F8zTn0yjnRZ4t+WVS61mWxLwSkUilvkSsd6C/UOu4LKNl7TxObnmxELyY8ctikccVHhyD/lKtkRDJ/EpwUdQ0Yn6Til+8uE7KWVbcrAL+odag/nUgGTIxI/U8fJgcBUCuVewPJycS29kP72FgNRukTWyvxjj1/2IRf/Llq5+UA4PdIbyjOj6qfwMq/PX8y9W0iJNxHJdJVe1qeJPcF8/9D7znOt5kkWXpLE3Ks9u0Eg3crgFX6h1r3acYD3LBfZRA4yvtRup5+DA5woHDFHZX4+WCDQ2WJwaeMlfPlL7K1Xl1cTcyTuuZsStRu4K3WgycAqYAtwX9dEvQB3AWOe/pAh7r+WIGPbSa+W1zKNoGn+SrAznxNE4yJz6cG7XDZzgAX4TfB796HpA303gPwJ5BLPoXeVsNEEvngDloezBLno6WB+n3FfjztNh1exds3gLGa6X3rX/ralvN/mdggx9mV7Ppar6xZmSLMdFebwMPBzAdqyn4IXchLilyaNH9Xg2tC1GU0c/kaxLF95lZtsGXbeAQwl7bd7IH8WFtQ3hPNu/VummeOaooHnBn/l64H0vYM/BN+XPBXw/4MbDB/go1GzpDeRiADd7Hfc5JT+PkaP4xtq5mQ2exbh/VaqobzhvKz4EBD2eCvEdd+pMG+fb8NWcGNh3gRDbngPsZ/Loartz/btgn2fpd89dxBfvpw+FdD/nr+Bj4YhA/2YTAw4XnbxBPz2/GQ7kgXJl/X+k9f/M5Vzs3ABsfzgXauUCrm6zBROmh1bxjbfY+1lr27h+HVXLwCw8AAA==","debug_symbols":"1ZrdbsIwDIXfJddcxHHi1LzKNE1lA1SpKoifSRPi3ZeyNrCCgoAxxTeohZPkI4l93Kg79TGdbOdvVTNbrNX4ZafqxXu5qRZNuNvtR2qyquq6mr+dfq10+1Ec5Otl2bR360252qgxeGNHatp8tJdoQwezqp6qsQ+XZ2JG32nZ+SgF0he0VnPRiS3oo5r9BTGRpk5MZMyp+HWk+GFw0BDF+kT8dHTQj0+6x37S+dqkg7GxY9Q6Te4ZuBN7pjNy+EPyMOm/0dsBzLMHwGcPYJ89gHt4AIe6Fzs013aEY93vCAIc7gi6kaZt4+9oU9zRhm9vYy7HpjF9kgvR5K7lFd9nCggLeFy/4uJaUNFPr/Ma0mvhrDW92NrhWhgQzG4Es6NgdiuY3QlmJ8HsXjB7IZid5bKjYF9Fwb6Kgn0VBfsqZp4jiSO71wN2m3msFi6yMwzZ/z9WKeJ4oDR721/sGo5P1wiHhw9rJMOjZPjMy7FkuOadapyJaTIcNgzZ8y7HnPYJ9szLMbZHdkyL2cToYIM0+KNOsB+4zGu3JHvmtVuSPfPaLcluBbNnfiaSZM/chJPsmdf7SfbMz0SS7JmbcIqdBPsqCfZVEuyrJNhXSbCvkmBfJbG+ug93n+WqKif1tHuVZbZt3k/ebNl8LX9+CeJv","brillig_names":["admin"]},{"name":"remove_from_group","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"approve","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/71azY7jRBDuTOyM4ySTLD8SCA6GAzdG8bBIHJDIahnEAS0SK7QHTt6xZzBK4pHj2R8O8ABwA3GDM0g8ANxAHOEMEgeExBXBK2w6U5V8rrSTmUl6SxpVx66/rq6uqm5PTZ1Djf40uIR31DIwzYBwfzMItyirb9POmg07tVDH4OyaWoa24V0Pxl3Ct7IiSMdpkUbD9OMkRvKXYfwk4aNoOEzyIJ0E4yljFI/SMbK8AePXCd8usjw6SYLJcMrRP+cbDrP7Sbwf4LtJMDqbFMGkiPIiOM6zURDuo+xjGL9AOCqKZHRaBEUWTM7uFnl0VAT30+LDILuX5MdTJSjgMxg/S/hGnkcPpw6IkwdBdlYE2XFwNzsbxxNk/ALGzy9rjuK4WunXV1X67QZKf7iq0p82UPrrVZX+fkml85j+n3BTLfYD75EB/e5vBmETjNuq7Neuv6plu3bsPtCyG3Zk93enMm5657LYftZVn/69Se8Yc7Ho0HsF/B21yGlMr5FPz3TiOaTnDDq3cS6L7o3ePT3K4uRGHOfJpBRYOP9VcFF5u5eQ94yUd+tsOEyP0yQ/fJBOipJczyBXj3dUOc83DLaYiq6GprBX0w3od38zmBU3tsUh2Z6wywWaa4SfMNjZAR60HX2yzX0h186BMev0he+2mU9qoIf1y7XsgO888AnmosF27On3QBfL76rl9TTZ7Qm7e0DvwVzE9lWr1gBlSRtkTG8zp2k7XaFP++VF0Icx7xjotX2+HftC3E+/gH0v0bgL9uDeaSlV8rNs1jVNW9C0xLwwHtqAuYec57jbybTS57i8WN7WQQt4PMHvwvt9wlXpRIabxTL7yqpQZp2+spbOZunEFfrltuyosm/ZJ7jsg+3Yc9ADXXgEkWHYEjYiX30Fn5xbk+antu/bg2skvwV+1IAljgHjFX3MGH2xzbNhDexyVDlNt8EmpmG9pr1TB16MYyxHmBpvwpxawOcY6HH/fg8y3oL3rPNteP+JwQYGm+3zRfe1pRbbuK9ZF+5rR9jUg2dYzmWbbpIvSwO2Bi7oRD6WpYQsZZAlbcBcjXF1B+Q2QaajzC0BxsWAcH8zuO6C7q/Atg9ojCVRxiD6QeYrU05zxJxwvTAnOgZ9rqret3Vlbgl4bvLZgH73N4MQ/cCyV7UmDbW+5p8Qvmze4jXE+PpI2MZ8joEebf8UZIxobPGoElo8ws/yGx67MFYbBv8psEMJPiV85gOfjbwo7WZdq44hFo8OB6ajkYyjjsEmtBN7nsaa+XVVOZ6ZT9og64XuB56j8bxlPxylxfvjZHyUPzwtkvid7EQJwBsGH57JVCxvpPlmQIYMlnW9vTFNyXBzBJ9Sq0sRtmuPsyVgnb6y1pKEFznNaZ+0hU09eIbboW3RTm43ua3jdTW1pJ8TNqV2lFU1Z9MJtgPz1NBVy8cSjZ+m8eIEe/5B4k6eFokSsCOUMLQM7+Uk5MKxYfK6QEND0ODZjWm+JFx1Bpa8WPe68J6dif2FPD+j7XgFokE78SkaSye+l0Sl70nYEyDUDLokjcVaGGIAsY9lLXSB5hvCVb6vewubGTueFdsPtNg/Qfc8VkBf1fUObiBZc2TCwLMArmNT8OEVKs5XqUVcYxKa2Qo03xE2+RbPEHgml/LwDFFX5T2AgH4xyW0Jept3DauKC+v0lbXiFpoSrYwT/X5P2NSDZ7gOexbt5GtHjhte1z14zjQ/Eq4qLt01c66BXKZhHtbbBX8w7UbFBQOzY3gvJyEXjg3DTdgGo5EGKzXT/Ey4KsFJXrwM6qrlbxe4CbFjs3QJGaJtSi13RJcpWqb/o5C/OxU0FrvREAOTN4JMYi7Q/EZ4XdHCb0GPq2jNYxD0yU0n94GpqUJ/aKi6jJYFES/0mIb90BA02CgwzR+Eq4oWfgtjLOXht6bZHiKmOvhk11vY7ADNDtjENH+B3L9Rr5Cr3/9neM+wqjA50Og07cTK7ILbh/81cECXA/NnGh/scOH3vzCflleez7xhIzy73KNxy6vmcwVfD2g84GsKvqZYN70G/9DYV+V9sM2cgWut98UjQIJz880nAAA=","debug_symbols":"5Z3bbtswDIbfJde9ECmRFPsqwzCkWzsECNKh7QYMxd59dhfbaezQWHoi4ZvBWSnpoy3rlykKelx9u776+f3LZndze7+6/PS42t5+XT9sbnfNr8c/F6uru812u/n+5fC/V6n9B9KT/f2P9a79ef+wvntYXYJguVhd7761l7k0NdxstterS2kuR8aaZW+rJL0pcJqwLUnr3rhAGqxVJoyZE++NmREPjT9frABeTA4JeuN0YPz27Pjyuy65u+s6d9cBS19xTskmFwXdG4vyiDy/Inlz05+jtw2Ut26A3roBfusGZKoBLAD7QlhQ53q+dH0ZmiaGFuqUNXFNe2uSBHb/oVKwMy4lH/efGphd47JjCswOgdkxMHsOzF4Cs1Ngdg7MHlhXMbCuYmBdzYF1NTsfI1l7dknH7M77e6WeXeGY/f37O/c4Amyzt/X1VcPw/ZehtPAlRYaHyPAnppKZenjKNnxB7jxtLnUmhCHUBXZY5DgQUOYnh8SHNG2ZckYZOqPMiUmIdm8wEsx9gWNXv8rw/oLQ1HOjrl7QOjy1NHVTlWoft+Fy8IzbGNGE9RCfSoNx00dbL2URXtZFeKlL8JLSIryERXiJi/AyL8LLsggvaRFeLmLuQ4uY+9Ai5j708rkPpMKTH2WTfg7fDgWqXTFLB8FVnn3rNeCcooJDVHCMCp6jgpdZcJypH5C7ICRgrc9amKBJfcSEU53JVcjShQizHsZLnpbJWd4dHWuPTjPozfjZRVeay3oUXZHpjk7a+duAzfaXDworSw7MXgKzU2B2DswugdlrYHaNy15TYHYIzB5YV2tgXa2BdbU6H9+tZXJ1/q5ay+T6/u/q/yzW5t4YspTjjw/NkeFLZHgKA19hBM+R4SUy/PxMOKdD+LaM/n+ZJgB6TiE4pxCeU+jEwCXYR0304wI+gNjHqDHn44cIid+d/tViPpCmuxNrn+AjOJPgI9wF2uvzTUdj0wrQkVegcgwzvTHso2DAEwx6gsmeYIonGPIEw55gxBNM9QTjaQRGTyMwehqB0dMIjJ5GYPQ0Ap/YT+NmMlb7oE/V8Q7t6huexYJX3/DadTHSNNple2JLTRB4iAyPkeFzZPgSGZ4iwzuPGNjwzhXWhneusDZ8ZIUtkRW2RFbYEllhi3OFpTzAF9tYM3QcmmnsqXM5PunpE7xzObbhncuxDe9cjk14cp6SZKU5APnOcyDsQw2UR1/r5DspiZJY8M6zkgZFo5xnRAH7/feKmUeelri5NEDOk4NteOfZwTa88/QxG955frAN7zxB2IRn53JswwdOOwR2niNswzuXYxs+ssJyZIXlyArLkRWWIyssR1ZYmd9M/KH7Q83lacm+4c3l6RO7LN3Am1FQocjwHBne+YZuG75GhtfA8DVFhofI8M4V1oZ3rrA2fGSFrZEVtkZW2BpZYatzhX295enqXI7NdUZ1Lsc2vHM5tuGdy7EN7/xQDHN5Wn2fimEvT6vvYzHs5Wn1fU7ADLzzgzFebW0dk/NjNKxAIibn51PZ8M4PqLLhnZ9QZcOXyPDO5diGd35IlQ3v/JQqGz7wsT2YnMuxCQ+RFRYiKyxEVliIrLAQWWEhrML+aX79Wt9t1lfb6/0B5Dc/d18PziN/+P3j318a478=","brillig_names":["remove_from_group"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"PublicGroups::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::constructor_parameters","fields":[{"name":"admin","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"PublicGroups::add_to_group_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::add_to_group_parameters","fields":[{"name":"member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"approve","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"PublicGroups::in_group_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::in_group_parameters","fields":[{"name":"group_member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"boolean"}}]},{"kind":"struct","path":"PublicGroups::remove_from_group_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::remove_from_group_parameters","fields":[{"name":"member","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"approve","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"PublicGroups::admin_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::admin_parameters","fields":[]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"PublicGroups::set_balance_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::set_balance_parameters","fields":[{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"PublicGroups::make_payment_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::make_payment_parameters","fields":[{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}}]}}]},{"kind":"struct","path":"PublicGroups::balance_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::balance_parameters","fields":[{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debtor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"PublicGroups::split_group_balance_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::split_group_balance_parameters","fields":[{"name":"creditor","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debtors","type":{"kind":"array","length":10,"type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}},{"name":"participants","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}}]}}]},{"kind":"struct","path":"PublicGroups::member_count_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PublicGroups::member_count_parameters","fields":[]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":64}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"group_members","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"group_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"member_count","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}}]}],"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"}]}]}},"file_map":{"24":{"source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n","path":"std/embedded_curve_ops.nr"},"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"29":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"34":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"58":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"59":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"74":{"source":"mod test;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract PublicGroups {\n\n    use dep::aztec::{\n        prelude::{Map, PublicMutable, AztecAddress},\n        macros::{storage::storage, events::event, functions::{public, initializer, private, internal, view}}\n    };\n    use dep::std::hash::pedersen_hash;\n    use dep::std::collections::bounded_vec::BoundedVec;\n    use dep::std::collections::vec::Vec;\n\n    #[storage]\n    struct Storage<Context> {\n        admin: PublicMutable<AztecAddress, Context>,\n        group_members: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        group_balances: Map<Field, PublicMutable<Field, Context>, Context>,\n        member_count: PublicMutable<u64, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.group_members.at(admin).write(true);\n        storage.member_count.write(1);\n\n        // Emit event for the admin assignment\n        context.emit_unencrypted_log([admin.to_field()]);\n    }\n\n    // Helper functions to read variables when testing\n\n    // Read the admin\n    #[public]\n    #[view]\n    fn admin() -> pub Field {\n        storage.admin.read().to_field()\n    }\n\n    // Read the group members\n    #[public]\n    #[view]\n    fn in_group(group_member: AztecAddress) -> pub bool {\n        storage.group_members.at(group_member).read()\n    }\n\n    // Read the member count\n    #[public]\n    #[view]\n    fn member_count() -> pub u64 {\n        storage.member_count.read()\n    }\n\n    // Read the balance between two addresses\n    #[public]\n    #[view]\n    fn balance(creditor: AztecAddress, debtor: AztecAddress) -> pub Field {\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        storage.group_balances.at(key).read()\n    }\n\n    // Functional methods\n\n    #[public]\n    fn add_to_group(member: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        storage.group_members.at(member).write(approve);\n        if approve {\n            storage.member_count.write(storage.member_count.read() + 1);\n\n            // Emit event for the member addition\n            context.emit_unencrypted_log([member.to_field()]);\n        }\n    }\n\n    #[public]\n    fn remove_from_group(member: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        storage.group_members.at(member).write(approve);\n        if approve {\n            storage.member_count.write(storage.member_count.read() - 1);\n\n            // Emit event for the member removal\n            context.emit_unencrypted_log([member.to_field()]);\n        }\n    }\n\n    // This sets balances but only between two people\n    #[public]\n    fn set_balance(creditor: AztecAddress, debtor: AztecAddress, amount: Field) {\n        assert(creditor == context.msg_sender(), \"cannot adjust someone else's balances\");\n        assert(storage.group_members.at(creditor).read() == true, \"Creditor is not in group\");\n        assert(storage.group_members.at(debtor).read() == true, \"Debtor is not in group\");\n\n        // Hash the addresses together\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance = storage.group_balances.at(key).read();\n        let amount_to_write = amount + balance;\n        storage.group_balances.at(key).write(amount_to_write);\n\n        // Adjust the balances\n        let creditor_debtor_hash = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance_creditor_debtor = storage.group_balances.at(creditor_debtor_hash).read() as u64;\n\n        let debtor_creditor_hash = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let balance_debtor_creditor = storage.group_balances.at(debtor_creditor_hash).read() as u64;\n\n        if balance_creditor_debtor > balance_debtor_creditor {\n            let difference = balance_creditor_debtor - balance_debtor_creditor;\n            storage.group_balances.at(creditor_debtor_hash).write(difference.to_field());\n            storage.group_balances.at(debtor_creditor_hash).write(0.to_field());\n        }\n\n        if balance_debtor_creditor > balance_creditor_debtor {\n            let difference = balance_debtor_creditor - balance_creditor_debtor;\n            storage.group_balances.at(debtor_creditor_hash).write(difference.to_field());\n            storage.group_balances.at(creditor_debtor_hash).write(0.to_field());\n        }\n\n        if balance_creditor_debtor == balance_debtor_creditor {\n            storage.group_balances.at(creditor_debtor_hash).write(0.to_field());\n            storage.group_balances.at(debtor_creditor_hash).write(0.to_field());\n        }\n\n        // Emit event for the balance set\n        context.emit_unencrypted_log([creditor.to_field(), debtor.to_field(), amount.to_field()]);\n    }\n\n    #[public]\n    fn make_payment(creditor: AztecAddress, debtor: AztecAddress, amount: u64) {\n        assert(storage.group_members.at(creditor).read() == true, \"Creditor is not in group\");\n        assert(storage.group_members.at(debtor).read() == true, \"Debtor is not in group\");\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let balance = storage.group_balances.at(key).read() as u64;\n        assert(balance >= amount, \"Insufficient balance, or paying more than is owed\");\n\n        let amount_to_write = balance - amount;\n        storage.group_balances.at(key).write(amount_to_write.to_field());\n\n        // Emit event for the payment\n        context.emit_unencrypted_log([creditor.to_field(), debtor.to_field(), amount.to_field()]);\n    }\n\n    #[public]\n    fn split_group_balance(creditor: AztecAddress, debtors: [AztecAddress; 10], participants: u64, amount: u64) {\n        assert(creditor == context.msg_sender(), \"cannot adjust someone else's balances\");\n        assert(storage.group_members.at(creditor).read() == true, \"Must be part of the group\");\n\n        let amount_per_participant = amount / (participants as u64 + 1);\n\n        for i in 0..10 {\n            let debtor = debtors[i as u32];\n            if debtor.is_zero() {\n                continue;\n            } else {\n                assert(storage.group_members.at(debtor).read() == true, \"Debtor is not part of the group\");\n                let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n                let current_balance = storage.group_balances.at(key).read() as u64;\n                let new_balance = current_balance + amount_per_participant;\n                storage.group_balances.at(key).write(new_balance.to_field());\n\n                // Emit event for the split\n                context.emit_unencrypted_log([creditor.to_field(), debtor.to_field(), amount_per_participant.to_field()]);\n            }\n        }\n    }\n}\n","path":"/Users/niallcheetham/dev/aztec/publicgroups/PublicGroupsRoot/contracts/publicgroups/src/main.nr"},"76":{"source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext,\n    macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/address-note/src/address_note.nr"},"82":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"97":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\nuse crate::hash::ArgsHasher;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn () -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        panic(f\"'delegate_call_public_function' not implemented!\")\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained pub fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"123":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"136":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"160":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"161":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::oracle::logs_traits::ToBytesForUnencryptedLog;\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (n as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"166":{"source":"use dep::protocol_types::address::AztecAddress;\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"175":{"source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"184":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"229":{"source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"238":{"source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE: u32 = 4;\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // We choose the last SELECTOR_SIZE bytes of the hash to avoid getting the first byte that is not full\n        let hash_bytes = hash.to_be_bytes::<SELECTOR_SIZE>();\n\n        FunctionSelector::from_field(field_from_bytes(hash_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector = FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"304":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"306":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"307":{"source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"309":{"source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"310":{"source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"313":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"314":{"source":"use crate::{\n    crate::address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"322":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"354":{"source":"use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}