{"transpiled":true,"noir_version":"0.34.0+02fea6abe8637b9fb8f9535d1709b367d5e1da5c","name":"DiffieH","functions":[{"name":"constructor","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"group_members","type":{"kind":"array","length":2,"type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_contract_instance_internal","get_public_keys_and_partial_address","unsafe_rand","decompose_hint","notify_created_note","get_key_validation_request","lt_32_hint","lte_16_hint","build_msg_block_iter","pad_msg_block","attach_len_to_msg_block","build_msg_block_iter","emit_encrypted_note_log","directive_invert","directive_integer_quotient"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"12265343917440897559":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":12,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"make_generator","is_unconstrained":false,"custom_attributes":["internal"],"abi":{"error_types":{},"parameters":[{"name":"seed","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+1dB3hcxbWelbTSSrIKuGFjQMZgTLP3rrTSilBsMMa922DANitp1za4W+422Kb33jsEAqEmhN5bkhcSEpK8AHmB5IXyICEhjSQvJHnvjDRjnR0dFWvPyDvfvePv+F79M/fMf87M3HN35s5uSLSmVAj+y2s9l6f56ihTBCSszvNFW5kqkZl0+dHqGM0ueYy6ogHHgGM0uxRwDDgGHAOOAceAY8Ax4BhwDDgGHAOOAceAY8Ax4Bhw3M0cceLRHbOoOxrNQ77VOiUm51gLROucayFIkWidgy0GKQEpBekDUgZSDlIBUgmyB8ieIH1B+oH0BxkAMhBkL5BBIINB9gYZArIPyL4g+4nWudyhIPuDDAM5AORAkOEgB4GMADkY5BCQQ0EOAzkcZCTIKOkLENmoMZBqkBqQOEgtSB1IAqQe5AiQr4AcCXIUyNEgxyj7xygfHKudoieh85QDMJZPYAUEFiawQgIrIrAIgRUTWAmBlRJYHwIrI7ByAqsgsEoC24PA9iSwvgTWj8D6E9gAAhtIYHsR2CACG0xgexPYEALbh8D2JbD9CKyKwIYS2P4ENozADiCwAwlsOIEdRGAjCOxgAjuEwA4lsMMI7HACG0lgowgsSmAegcUIrJrAaggsTmC1BFZHYAkCqyewIwjsKwR2JIEdRWBHE9gxBDaawMYQ2LGiLUDopIOHxqujtTU1qbpYyqv2ktFYfUMiHq2JN9QmvIQXT8SbYonq6lSiJlFX31BfF633aqpTXjpeX51WwQjrimaXvDxhJ7jnss35PrS5wIc2h31oc6EPbS7yoc0RH9pc7EObS3xoc6kPbe7jQ5vLfGhzuQ9trvChzZU+tHkPH9q8pw9t7utDm/v50Ob+PrR5gA9tHuhDm/fyoc2DfGjzYB/avLcPbR7iQ5v38aHN+/rQ5v18aHOVD20eymizXPsKIXtDSLdAGCd/Rl3BC3cBx4BjwDHgGHAMOAYcA44Bx4BjwDHgGHAMOAYcA44Bx4Cj4xwFK8eENduHOdA+BzjA8UAHOA53gONBDnAc4QDHgx3geIgDHA91gONhDnA83AGOIx3gOMoBjlEHOHoOcIw5wLHaAY41DnCMO8Cx1gGOdQ5wTDjAsd4Bjkc4wPErDnA80gGORznA8WgHOB7jAMfRDnAcY4EjTjy6Yy3fgaPt1zqPAxkLcjzIOJATQMaDTACZCDIJZDLIFJCpINNApoPMAJkJMgtkNsgckLkgJ4KcBDIP5GSQU0BOBZkPsgBkIchpIEmQBpBGkCaQFEgaZBHIYpAlIKeDnAGyFGQZyHKQFSArQVaBrAZZA9IMshZkHch6kA0gG0E2gWwG2QKyFeRMkLNAtoFsB9mhfHC2dor+ciPpFPMLj8YS2PEENo7ATiCw8QQ2gcAmEtgkAptMYFMIbCqBTSOw6QQ2g8BmEtgsAptNYHMIbC6BnUhgJxHYPAI7mcBOIbBTCWw+gS0gsIUEdhqBJQmsgcCaCCxFYGkCW0RgiwlsCYGdTmBnENhSAltGYMsJbAWBrSSwVQS2msDWEFgzga0lsHUEtp7ANhDYRgLbRGCbCWwLgW0lsDMJ7CwC20Zg2wlsB4GdLdqCgU46UGg8lzYPHCfsBNtctnmsD20+3oc2j/OhzSf40ObxPrR5gg9tnuhDmyf50ObJPrR5ig9tnupDm6f50ObpPrR5hg9tnulDm2f50ObZPrR5jg9tnutDm0/0oc0n+dDmeT60+WQf2nyKD20+1Yc2z/ehzQt8aPNCH9p8mg9tTvrQ5gZLNocMm6PZJa+RwX+ptEwJz2bbDGO0uUm40R8ZN3R6KUdsZtwg6qUdsZlxw6m3yBGbGTeweosdsXkEo81LHLGZcYOtd7ojNjNu2PXOcMRmxg3A3lJHbGbcUOwtc8Rmxg3K3nJHbGbc8OytcMRmxg3U3kpHbGbckO2tcsRmxg3e3mpHbGbcMO6tccRmxg3oXrMjNjNuaPfWOmIz4wZ5b50jNjNuuPfWO2Iz4wZ+b4MjNjN+IYC30RGbGb9gwNvkiM2MX1jgbXbEZsYvQPC2OGIz4xcqeFsdsZnxCxq8Mx2xmfELH7yzHLGZ8QskvG2O2Dya0ebtjtg8htHmHYw2h5Wt+UpfCOkWCBOM/Bl1WftCkoBjwDHgGHAMOAYcA44Bx4BjwDHgGHAMOAYcA44Bx4BjwDHg2DscBSvH4Me/cp1j8ONfPByDH//i4Rj8+BcPx+DHv3g4Bj/+xcMx+PEvHo7Bj3/xcAx+/IuHY/DjXzwcgx//4uEY/PgXD8fgx794OAY//sXDMfjxLx6OYyxwxIlHd8yzqDsaQr7VOs8BORfkPJDzQS4AuRDkIpCLQS4BuRTkMpDLQa4AuRLkKpCrQa4BuRbkOpDrQW4AuRHkJpCbQW4BuRXkNpDbQe4AuRPkLpC7Qb4Kcg/IvSBfA7kP5H6Qr4M8APIgyEMgD4M8AvIoyDdAvgnyGMi3QB4HeQLkSZCnQJ4GeQbkWZDnQJ4HeQHkRZCXQF4GeQXkVe0M/SM70hnmD++cS2DnEdj5BHYBgV1IYBcR2MUEdgmBXUpglxHY5QR2BYFdSWBXEdjVBHYNgV1LYNcR2PUEdgOB3UhgNxHYzQR2C4HdSmC3EdjtBHYHgd1JYHcR2N0E9hyBPU9gLxDYiwT2EoG9TGCvENirCsMpTx1Hq2MufcnZOcLODT6XbT7Xhzaf50Obz/ehzRf40OYLfWjzRT60+WIf2nyJD22+1Ic2X+ZDmy/3oc1X+NDmK31o81U+tPlqH9p8jQ9tvtaHNl/nQ5uv96HNN/jQ5ht9aPNNPrT5Zh/afIsPbb7Vhzbf5kObb/ehzXf40OY7fWjzXT60+W5LNnO/FPRVBv9RPzjFzfMeR/x5ryM8v+YIz/sc4Xm/Izy/7gjPBxzh+aAjPB9yhOfDjvB8xBGejzrC8xuO8PymIzwfc4Tntxzh+bgjPJ9whOeTjvB8yhGeTzvC8xlHeD5riWdBtjy9zD+fy45nhrbns7UZaXtB8M3LxEI52hbRTKtfFAw8lbaXBIvNLdpeZmyL6txui6i2+hXBdy94lVEXY1/2cFtkN3cX9eQPFMh9L3mifWJrG8t9O5pNyt0+Y2Oz5c57Fm7v19Txdfkf3gglM943MFmoSgQdJetfy3Phhmp06B7aHFM2e68x+u91RhtttUUec1tw+u/bhK6GaGNT3GuobarzUsl4orGxvtrzYsnaZG1DLJFONcS9RDwBOhuTsQRUF0s2eqlosjYVVv0uJNon7gf0b/PpimK+37FJ+DsW9H6XsTPYsvu7yMFMekmuHDcTyZVrwGq9nG30H4K34+uALvUOBenNJ8HnBF+Af17wBfgX+HzsvSjsBBWm8UQ+CX5PHd8QIvOpT2aYT4KyUJWw1FEUSezEbJ8+vif4BuMbSFesKZ6K1icaErGGZHVdQ011Q319EvTWel4i3RSLNtXE0nGvtraxPlWf9qrTDfFUsjaerK9taomeTTFHnj44/fd94ebTx/eFnaePH9gk/AMLet8Uuf30Ie1+EzmYSa+Vp483FFfupw/ONvqhsPP0IfV29fTB1je81n8sulQi6FqJzD9Sx7e0Q7QDZYYZmWWhKoNUvkUnZhuZfyT4Oupbwo1oymnzj4Wb0fTHwk40/YlNwj+xoPenIrejqbT7p8jBTHqtRNO3FFfuaMrZRv8p7ERTqTeIpgZLlbAvfqaOb2uHaAfKDDOaykJVBqlcjqY/E3wd9W3hRjTltPkd4WY0fUfYiabv2iT8rgW9Pxe5HU2l3T9HDmbSayWavq24ckdTzjb6L2Enmkq9QTQ1WKqEffELdXxPO0Q7UGaY0VQWqjJI5XI0/YXg66jvCTeiKafN7ws3o+n7wk40/aVNwr+0oPdXIrejqbT7V8jBTHqtRNP3FFfuaMrZRv8t7ERTqTeIpgZLlbAvfq2OH2iHaAfKDDOaykJVBqlcjqa/Fnwd9QPhRjTltPlD4WY0/VDYiaYf2ST8kQW9H4vcjqbS7o+Rg5n0WommHyiu3NGUs43+R9iJplJvEE0NliphX3yijp9qh2gHygwzmspCVQapXI6mnwi+jvqpcCOactr8G+FmNP2NsBNNf2uT8G8t6P1M5HY0lXZ/hhzMpNdKNP1UceWOppxt9DthJ5pKvUE0NViqhH3xe3X8XDtEO1BmmNFUFqoySOVyNP294Ouonws3oimnzX8QbkbTPwg70fSPNgn/0YLeP4ncjqbS7j8hBzPptRJNP1dcuaMpZxv9WdiJplJvEE0NliphX/xFHb/QDtEOlBlmNJWFqgxSuRxN/yL4OuoXwo1oymnzX4Wb0fSvwk40/ZtNwn+zoPfvIrejqbT778jBTHqtRNMvFFfuaMrZRv8r7ERTqTeIpgZLlbAv/qGOX2qHaAfKDDOaykJVBqlcjqb/EHwd9UvhRjTltPmfws1o+k9hJ5r+yybhf1nQ+2+R29FU2v1v5GAmvVai6ZeKK3c05Wyj/xN2oqnUO1RkJm7/SoXZck9oXRZ5hkJ2AgE3zzwGnrXJaH2qtrbOJs98Bp4NDbV1yVQibpNnAQPP6sbaVLq6LmaTZ5iBZzJek07Hq5M2eRYy8Ix70VQ8Vpe2ybOIgWd9QzRem0g02uQZYeDppRPVTfXJBps8iznavSEFj6FeveQ2UGR+OMHTfnhBDb+qgl8Cxdsr5Pnb6PwtdC7/0+ehLM7fQDpfR+d5qEw+Oi9A52F0XojOi9B5BJ0Xq/MSOJaC9AEpAykHqQCpBNkj1P7TMfdz3h6MMVN/WdKeoLMvSD+Q/qFW0viZReZHRCbWl8D6EVh/heHE/SVN2CfZjqk9GXTp77bty8grYelZyZx0yMZm2Rb9WPzX2q79+Wz2OP1ne4xXWhjjA0DnQJC9QAYRY3wAMXYHEtheBDaoF8Z4JeNYGsA4xgcy8jrCkTG+F+MYH8Q4xo9waIxXWBjjg0Hn3iBDQPYhxvhgYuzuTWBDCGyfXhjjFYxjaTDjGN+bkdeRjozxIYxjfB/GMX6kQ2O83MIY3xd07ic/i4AMJcb4vsTY3Y/AqghsaC+M8XLGsbQv4xjfj5HX0Y6M8SrGMT6UcYwf7dAYL7MwxvcHncNADgA5kBjj+xNjdxiBHUBgB/bCGC9jHEv7M47xYYy8Rjsyxg9gHOMHMo7x0Q6N8T4Wxvhw0HkQyAiQg4kxPpwYuwcR2AgCO7gXxngfxrE0nHGMH8TI61hHxvgIxjF+MOMYP9ahMV5qYYwfAjoPBTkM5HBijB9CjN1DCewwAju8F8Z4KeNYOoRxjB/KyGusI2P8MMYxfjjjGB/r0BgvsTDGR4LOUSDyJR+PGOMjibE7isCiBOb1whgvYRxLIxnH+ChGXuMcGeNRxjHuMY5xW/4rYPJfrq7dcq6JahvH53hbUGu32b58nvV6Xc1O/7Gu103I3baIIp7ZrdfFMmzOWK/bRV1Rw3/eYMa2mJiDbVGbbsezp2tJCcLmnq3RJEj/ZazRZNsWk3KrLeo64Ont8vpBXYc27+r6QawT/7HMy+u2mJwrbVHXKc+M9YMudDV2YbPX7Tnjui79xzpnPGX3t0W0Gzy7N2cc7ZbNGXPGHeiKd9N/3nDGtpi6O9uipts8u5jPrEnvgs2dzxPW7ZL/MuYJs22LabunLRK7yNPraA6rPr3LNnc0hxXtgf9Y5oZ0W0zv7baI9ohnxhyW0uX10Gav3bxFU4/9xzpvMaP32qI6C54Z8xaxdFY2s85bjGdsi5m91BbR7JLH+JnUY/xM5U1ibItZjrQF47O3x/js6E1lbIvZjrQF4zOGxxgjvRmMbTHHkbZgvJd6jPcCbzZjW8ztpTWHaHapZcmKSxdj//M4/RdCfTgk2qcQOu6BzjW+CJUdoo7J5ubUspXNVc0rqpJNTVXrlzQvrlqxLrU6vXTFenztuejaQeo4ZvXq5MaqJcubUhuqVqxtrlqRrmpYsXZ50xp84aU9vfDmLNje1YNr9Vbc63eVsL7wniwqfbAH136oym1C1w5tf+2ytUubl6xcurFjBQ9lUfnjWVz7jNhFT+sLX+nphW9mwfadnlb6URaVfraL17Z8uxX2bbFo28ur7x+j1d/R7JJXjMix6k4ka6XuQiu8YzGpu8iOT6JS73HqZQfNX9eVj/L0MaTaR+aNVdhYIu94hR1P5I1T2Dgi7wSFnUDkjVfYeCJvgsImEHkTFTaRyJuksElE3mSFTSbypihsCpE3VWFTibxpCptG5E1X2HQib4bCZhB5MxU2k8ibpbBZRN5shc0m8uYobA6RN1dhc4m8ExV2IpF3ksJOIvLmKWwekXeywk4m8k5R2ClE3qkKO5XIm6+w+UTeAoUtIPIWKmwhkXeawk4j8pIKSxJ5DQprIPIaFdaI8vQ3AjYprAnlyXtDsWh7XuW9z9VUW7zPRctE271HJ1lfxE59nvlMWoDOdZ0lwtq9t6X+iFG/rkvHQOmTfFUoH2EFkUyeEgsb93H55zFYjzovwnrUue5fLXoU1oTqmIh8oPM153yDs7U+kqiN24uFNVHs6zDh60LC10Ud+PqeSJt/ZOoLklLYGOSnoogNW1o/e0WQLQWoLs09D5WJGPcX/fcE0YYXo87a0u7aB+pYIX2kzosjHV9XYFxXicoUouuKjOuKEO+WsshfpaLV74UiM1nsL53eP3SdJcLW/bL1/lFk1K/rwmMR3z/z+OqPFiv9Fnzb0n+LDduKDd+WKf9iTF5Xqs51vy9BvtC+0WVK0XVh9Pc8daxE12M/akwYdeC+OUudVyB+uC+YbWfe+ytF+2dyKkZ21g+xLpNDmWj/nnN3dJn3d+m30ervaJapEnEq7KA+2/0sbNSP27vQKKOvDaMyi9VxT9E+Ufeo7rYf9oc+liAdnM9i3RlHeLysUEfJcRXBuYTIrzBwofyD9eu8ZmRnocGr2KgjjMpsQTrWo3rNcYXHKH6mykfXa6zAuLZUlTPbR48N/MwUNvgVGLhM21Cdt3XBOWxwlnX3QfVz94kyxBf7vg/CdZnz1JEaB1iX9oP5HBlCenWZMmSn9kGpwSHf4Il9Yc8/rfeSclQv5ov9o8tcJjr2D34Wxf2qwMrzYo0n1d6D6t7ZX1F95Ygfvgd21l7lSKdMlahMKcKKkH9k6qhvW4o7ntkf8XjEdZYiDJfB/U2XuUUdqfbFca4M6bytA1u5nxvNz3DFiANlKy4TJmy9uxNbu7qn488N+cTzf4GSQuP5P4zK3I/0PoDqDRt6Zf7TRL5OncViPfZannstfm4rMT636boKkP26TInxuU3//SSyp7SDz23F6HOb/rxXGun4urBxXSUqE+nk814x8bntYXVeIjLvMZz9HLe17KevqXM31xgaW+Y+wlZ413gW7zcZawzmPTVYY2jFgjWGYI0hl9YYdB61xqDz9HxmishLKyxN5C1S2CIib7HCFhN5SxS2hMg7XWGnE3lnKOwMIm+pwpYSecsUtozIW66w5UTeCoWtIPJWKmwlkbdKYauIvNUKW03krVHYGiKvWWHNRN5aha0l8tYpbB2Rt15h64m8DQrbQORtVNhGIm+TwjYReZsVtpnI26KwLUTeVoVtJfLOVNiZRN5ZCjuLyNumsG1E3naFbSfydihsB5F3tsLORnkyTtpex7P0LBEN5uHbz8N3tY6H53f18zD+/Dsf61Hn1JyU7kPysBjZu/vW7BI1ubxmh/36WqTNPzLJNbtzFDYG+SnX1+wWIV/n4prdAnWu1+xw39R6cOpoPlxfh8dTtnPrOh/PB+N7cHfWbMx1drP/881bVbf8foh2uZ6PMuen80T7uW3NQ+Pr1FH6YYd13q1zpV3xDqMym7rBj28sVtdT8/yy7q3W627vm4IufHMR4red8FOFyFxn0Jj5WRyvMeA+b8YFM7bhPo/vtxorQJjJo1TQ66PmujXjmEmHROZ8JPYlNWbM9RyNX4E436fOsS3Y1xFUVijfaL3YzgJhf82+1KiPR3drv8XrHHjOGK8l6jI3qGNX6x+4HWyufzyC6t65lojqM9c2zDV/PGeuy/RB3GWqRGUiCNN9Reuk1kbtjYn2z7B4PRvXidcJcBnc53WZe9Wxo/UPcz0TjyOL7zyT792Z91fTVlwmQtj6UCe2lhHX4ljCsf7xGNL7OKqXWv94lcjXqbPnJZfWP15G9uTi+sdT6tz2+odua3nPGaga1+X1D0vvAQV7LESw/hGsfwTrH2ZesP4RrH+YecH6R++sf8g8Pf96jpHn5h6nml7e41Tjiz1OC7AedU7tcdL9C885n4PqWGL4AHOm1kusrJ8lEnHb/U/7uoDwdbibvpZrI+eq/NHIJ7m+NrJYtOG5uDayUJ3rtZFs93rg8RTpoa6IkY/nk817MNZVQOgy54SL0TnznFYCz+Hkicw1Brx/o9RO/a1zGche/L4sfodWl9mMeJQh/+J5JnzP6WPoLkN/67J9DN3U/FS+EO32s+hzK/u7vGjLfajU4GFvP0u0vrO+XoKOdubGW+OguWdM14VjSpklf8vv1+kn2r+vbs7xWtwgEU3g4FOCiOgbaB9E5nN1jheqzIGKnWluRsAT7bhz23npJZrx0gteWLsM1W2nc2duYtM3OXPjFb6J3ID4XSXa/NzZpihqEVzb0Z1FcOrFFb34Z3ZC88bDuPiXwH1HL/6ZG9vMtuJcaAmj+t9C/sAbvYoJf4St8Gm/aEcFGxxI7kacP7HOr3VcUZtH7jXqo/gXGLhMjyId94s2n3e22KV1lBh6QwYnqi/huvWmh642BOGFp08QR60Hj098z9SczI1M5iKkLFNu8NZl8EYmXeaJTnjnd6BfL/5WGNho9Xc0u9QyjisRV7zYWoFwXebZTmzAuoSgg3MI6dVl9DW43nJ0bvqnjPBPpRX/tI5r7AfsH+w3XeZV0bF/qJfsbC/G54Xa6t7ZJ1F9ZlvoMri9zDbV12A/6DLlCMMxS+syx5S56ZgaU8WGHjymfqiOXW2Yw5sD9T0Px4jONgPjvmc+95j3bO6XTMqN+nh0d96v8eZbXeZd0bmfdy4Gi7ZjrvdrcyMu1a+xLzRm9usKdI7jB362xh8scV83XwQxN1zj/v+xOnYV93Asxc8Wlj4UemaMp56bzRiPy1Ax/ned2FpGXGt+Rii0M4EWa7EDTbLiiatCNDGqJ8p298seeFKvq5c9QqE2PGJwjRiTbBLvzgsh2iedvRCSb0w2tnxe2oXrqBdJinahPnxdYScTlNQLKH9W56WC5wWkwlCb7gi6x1EvIA0g8nUKZf7p7AtI/VCfzMUXkEoVP9svIOm2lv0Mf76xdE+P2XvBtfVFHp00fzyJmYd8LhAH8zxPZN6PzHwKKyPq6Utg+DmmH9LB/ZJXfzu6M3ys+fdHNuWhfK46pQ49NxUmfBpG+bgPh/i5eEhlS53m/RC3uc77f97s1K6Y8AEA","debug_symbols":"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","brillig_names":["build_msg_block_iter","pad_msg_block","attach_len_to_msg_block","directive_integer_quotient","directive_invert"]}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000029ac11aa"},{"kind":"string","value":"StringNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000fc6f65d4"},{"kind":"string","value":"NewAddressNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"group_members","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"shared_secrets","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}},{"name":"group_members","type":{"kind":"array","length":2,"type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress"}}}],"kind":"struct","path":"DiffieH::constructor_parameters"}}],"kind":"struct","path":"DiffieH::constructor_abi"}]}},"file_map":{"102":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr","source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::IvpkM};\n\npub struct EncryptedLogIncomingBody<let N: u32> {\n    plaintext: [u8; N * 32 + 64]\n}\n\nimpl<let N: u32> EncryptedLogIncomingBody<N> {\n    pub fn from_note<T>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T>(event: T, randomness: Field) -> Self where T: EventInterface<N> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use dep::protocol_types::{\n        address::AztecAddress, scalar::Scalar, point::Point, traits::Serialize,\n        abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n        encrypted_logs::incoming_body::EncryptedLogIncomingBody, event::event_interface::EventInterface,\n        context::PrivateContext, keys::public_keys::IvpkM\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: u32 = 3;\n\n    impl NullifiableNote for AddressNote {\n        fn compute_nullifier(\n            _self: Self,\n            _context: &mut PrivateContext,\n            _note_hash_for_nullify: Field\n        ) -> Field {\n            1\n        }\n\n        unconstrained fn compute_nullifier_without_context(_self: Self) -> Field {\n            1\n        }\n    }\n\n    struct AddressNoteHidingPoint {\n        inner: Point\n    }\n\n    impl NoteInterface<ADDRESS_NOTE_LEN> for AddressNote {\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader {\n            self.header\n        }\n\n        fn set_header(&mut self, header: NoteHeader) {\n            self.header = header;\n        }\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] {\n            [self.address.to_field(), self.owner.to_field(), self.randomness]\n        }\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote {\n                address: AztecAddress::from_field(fields[0]),\n                owner: AztecAddress::from_field(fields[1]),\n                randomness: fields[2],\n                header: NoteHeader::empty()\n            }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_LEN * 32 + 64] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_LEN * 32 + 64] = [0; ADDRESS_NOTE_LEN * 32 + 64];\n\n            let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n            let note_type_id_bytes: [u8; 32] = AddressNote::get_note_type_id().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes: [u8; 32] = serialized_note[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n\n        fn compute_note_hash(_self: Self) -> Field {\n            crate::generators::Ga1.x\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    unconstrained fn test_encrypted_note_log_incoming_body_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        // 1. `EncryptedLogIncomingBody::from_note` calls `note.to_be_bytes(storage_slot)` function which serializes\n        // the note to bytes - note that in the case of `AddressNote` the `to_be_bytes` function was automatically\n        // implemented by Aztec macros.\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        // 2. `body.compute_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: u32 = 3;\n\n    impl EventInterface<TEST_EVENT_LEN> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            comptime\n            {\n                EventSelector::from_signature(\"TestEvent(Field,Field,Field)\")\n            }\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_LEN * 32 + 64] {\n            let mut buffer: [u8; TEST_EVENT_LEN * 32 + 64] = [0; TEST_EVENT_LEN * 32 + 64];\n\n            let randomness_bytes: [u8; 32] = randomness.to_be_bytes();\n            let event_type_id_bytes: [u8; 32] = TestEvent::get_event_type_id().to_field().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes: [u8; 32] = serialized_event[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_LEN * 32 + 32] {\n            let mut buffer: [u8; TEST_EVENT_LEN * 32 + 32] = [0; TEST_EVENT_LEN * 32 + 32];\n\n            let event_type_id_bytes: [u8; 32] = TestEvent::get_event_type_id().to_field().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes: [u8; 32] = serialized_event[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    unconstrained fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_event_log_incoming_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let event_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 201, 247, 40, 80, 60, 188, 158, 251, 242, 103, 197, 79, 165, 195, 10, 160, 255, 35, 167, 152, 25, 233, 77, 145, 214, 243, 210, 119, 0, 20, 29, 95, 15, 63, 33, 190, 184, 67, 254, 96, 128, 243, 220, 228, 201, 130, 86, 163, 52, 127, 111, 10, 212, 7, 160, 16, 87, 13, 39, 11, 5, 1, 164, 65, 8, 56, 82, 245, 13, 68, 176, 90, 100, 69, 243, 78, 117, 188, 221, 34, 178, 31, 155, 89, 143, 176, 129, 118, 36, 236, 64, 179, 52, 239, 184, 51, 51, 199, 221, 49, 81, 197, 17, 199, 192, 99, 49, 168, 157, 164, 190, 33, 240, 182, 214, 173, 7, 156, 102, 95, 65, 217, 225, 123, 42, 21, 124, 144\n        ];\n\n        assert_eq(event_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..event_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], event_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n"},"103":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::ToPoint};\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = crate::keys::public_keys::IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"},"104":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::{getters::{get_public_keys, get_ovsk_app}, public_keys::{OvpkM, IvpkM}},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{hash::sha256_to_field, address::AztecAddress, abis::note_hash::NoteHash};\n\nfn compute_raw_note_log<Note, let N: u32, let M: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    num_public_values: u8 // Number of values to be appended to the log in public (used in partial note flow).\n) -> (u32, [u8; M], Field) where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note,\n        num_public_values\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32, let M: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    num_public_values: u8 // Number of values to be appended to the log in public (used in partial note flow).\n) -> (u32, [u8; M], Field) where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient, num_public_values)\n}\n\npub fn encode_and_encrypt_note<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(AztecAddress, AztecAddress, &mut PrivateContext)](NoteEmission<Note>) -> () where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_public_keys(ov).ovpk_m;\n        let ivpk = get_public_keys(iv).ivpk_m;\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        // Number of public values is always 0 here because `encode_and_encrypt_note(...)` is only called\n        // in the non-partial note flow.\n        let num_public_values = 0;\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, iv, num_public_values);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(AztecAddress, AztecAddress, &mut PrivateContext)](NoteEmission<Note>) -> () where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        // Note: We could save a lot of gates by obtaining the following keys in an unconstrained context but this\n        // function is currently not used anywhere so we are not optimizing it.\n        let ovpk = get_public_keys(ov).ovpk_m;\n        let ivpk = get_public_keys(iv).ivpk_m;\n\n        // Number of public values is always 0 here because `encode_and_encrypt_note_unconstrained(...)` is only called\n        // in the non-partial note flow.\n        let num_public_values = 0;\n\n        // See the comment in `encode_and_encrypt_note_with_keys_unconstrained` for why having note hash counter\n        // and log hash unconstrained here is fine.\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, iv, num_public_values)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        // Number of public values is always 0 here because `encode_and_encrypt_note_unconstrained(...)` is only called\n        // in the non-partial note flow.\n        let num_public_values = 0;\n\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient, num_public_values);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        // Number of public values is always 0 here because `encode_and_encrypt_note_with_keys_unconstrained(...)` is only called\n        // in the non-partial note flow.\n        let num_public_values = 0;\n\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient, num_public_values)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n"},"105":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash_with_separator\n};\nuse std::aes128::aes128_encrypt;\n\nuse crate::{keys::public_keys::IvpkM, utils::point::point_to_bytes};\n\npub struct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk: IvpkM) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk }\n    }\n\n    /// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n    /// be able to derive the key with which the incoming log can be decrypted.\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 144] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer = [0 as u8; 128];\n\n        let serialized_eph_sk_high: [u8; 32] = self.eph_sk.hi.to_be_bytes();\n        let serialized_eph_sk_low: [u8; 32] = self.eph_sk.lo.to_be_bytes();\n\n        let address_bytes: [u8; 32] = self.recipient.to_field().to_be_bytes();\n        let serialized_recipient_ivpk = point_to_bytes(self.recipient_ivpk.to_point());\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n        }\n        for i in 0..32 {\n            buffer[i + 96] = serialized_recipient_ivpk[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash_with_separator(\n            [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ).to_be_bytes();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::{encrypted_logs::outgoing_body::EncryptedLogOutgoingBody, keys::public_keys::IvpkM};\n    use dep::protocol_types::{address::AztecAddress, scalar::Scalar};\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n\n    #[test]\n    unconstrained fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        assert_eq(outgoing_body_ciphertext_from_typescript, ciphertext);\n    }\n}\n"},"107":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\nuse std::{\n    embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n    utils::point::point_to_bytes, note::note_interface::NoteInterface,\n    encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n},\n    keys::public_keys::{OvpkM, IvpkM}\n};\n\npub fn compute_encrypted_event_log<Event, let N: u32, let OB: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<N> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note,\n    num_public_values: u8 // Number of values to be appended to the log in public (used in partial note flow).\n) -> [u8; M] where Note: NoteInterface<N> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    encrypted_bytes[64] = num_public_values; // TODO(#8558): This can be just a single bit if we store info about partial fields in ABI\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[65 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[97 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[145 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[193 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 337;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[337 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // num_public_values (1 byte)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(unsafe_rand());\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::payload::compute_encrypted_note_log, keys::public_keys::{OvpkM, IvpkM},\n        test::mocks::mock_note::MockNoteBuilder\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point};\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_note_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let storage_slot = 0x0fe46be583b71f4ab5b70c2657ff1d05cccf1d292a9369628d1a194f944e6599;\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let note_value = 0x301640ceea758391b2e161c92c0513f129020f4125256afdae2646ce31099f5c;\n        let note = MockNoteBuilder::new(note_value).contract_address(contract_address).storage_slot(storage_slot).build();\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n        let num_public_values: u8 = 0;\n\n        let log: [u8; 449] = compute_encrypted_note_log(\n            contract_address,\n            storage_slot,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            note,\n            num_public_values\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_note_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 205, 103, 212, 60, 151, 141, 10, 151, 222, 151, 180, 43, 91, 148, 201, 110, 165, 10, 238, 32, 134, 235, 99, 216, 200, 182, 31, 22, 156, 18, 209, 222, 172, 239, 193, 212, 86, 99, 62, 70, 182, 45, 175, 241, 91, 202, 179, 225, 236, 95, 71, 66, 151, 225, 203, 53, 216, 85, 102, 130, 6, 8, 25, 180, 86, 58, 140, 198, 105, 102, 177, 42, 94, 115, 247, 145, 147, 24, 231, 39, 73, 27, 10, 219, 130, 115, 188, 74, 114, 5, 177, 199, 83, 183, 106, 87, 204, 238, 231, 72, 45, 240, 39, 174, 25, 98, 53, 187, 156, 159, 244, 38\n        ];\n        assert_eq(encrypted_note_log_from_typescript, log);\n    }\n\n    #[test]\n    unconstrained fn test_encrypted_note_log_of_finalized_partial_note_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let storage_slot = 0x0fe46be583b71f4ab5b70c2657ff1d05cccf1d292a9369628d1a194f944e6599;\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let note_value = 0x301640ceea758391b2e161c92c0513f129020f4125256afdae2646ce31099f5c;\n        let note_public_value1 = 0x14172339287e8d281545c177313f02b6aa2fedfd628cfd8b7f11a136fd0d6557;\n        let note_public_value2 = 0x0834d81e3f73c7e2809b08ae38600ffc76a2554473eeab6de7bff4b33a84feac;\n        let note = MockNoteBuilder::new(note_value).contract_address(contract_address).storage_slot(storage_slot).build();\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n        let num_public_values: u8 = 2;\n\n        // First we compute the encrypted log without the public values\n        let log_without_public_values: [u8; 449] = compute_encrypted_note_log(\n            contract_address,\n            storage_slot,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            note,\n            num_public_values\n        );\n\n        // Then we \"append\" the public values to the log by copying both the original log and the current log into a new byte array\n        let mut log: [u8; 513] = [0; 513];\n        for i in 0..449 {\n            log[i] = log_without_public_values[i];\n        }\n        let note_public_value1_bytes: [u8; 32] = note_public_value1.to_be_bytes();\n        let note_public_value2_bytes: [u8; 32] = note_public_value2.to_be_bytes();\n        for i in 0..32 {\n            log[449 + i] = note_public_value1_bytes[i];\n            log[481 + i] = note_public_value2_bytes[i];\n        }\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_note_log_of_finalized_partial_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 205, 103, 212, 60, 151, 141, 10, 151, 222, 151, 180, 43, 91, 148, 201, 110, 165, 10, 238, 32, 134, 235, 99, 216, 200, 182, 31, 22, 156, 18, 209, 222, 172, 239, 193, 212, 86, 99, 62, 70, 182, 45, 175, 241, 91, 202, 179, 225, 236, 95, 71, 66, 151, 225, 203, 53, 216, 85, 102, 130, 6, 8, 25, 180, 86, 58, 140, 198, 105, 102, 177, 42, 94, 115, 247, 145, 147, 24, 231, 39, 73, 27, 10, 219, 130, 115, 188, 74, 114, 5, 177, 199, 83, 183, 106, 87, 204, 238, 231, 72, 45, 240, 39, 174, 25, 98, 53, 187, 156, 159, 244, 38, 20, 23, 35, 57, 40, 126, 141, 40, 21, 69, 193, 119, 49, 63, 2, 182, 170, 47, 237, 253, 98, 140, 253, 139, 127, 17, 161, 54, 253, 13, 101, 87, 8, 52, 216, 30, 63, 115, 199, 226, 128, 155, 8, 174, 56, 96, 15, 252, 118, 162, 85, 68, 115, 238, 171, 109, 231, 191, 244, 179, 58, 132, 254, 172\n        ];\n        assert_eq(encrypted_note_log_of_finalized_partial_from_typescript, log);\n    }\n}\n"},"120":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr","source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n"},"123":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"125":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter)\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) -> Field {\n    notify_nullified_note_oracle(nullifier, note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n"},"127":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::{PublicKeys, public_keys::{NpkM, IvpkM, OvpkM, TpkM}};\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained pub fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"132":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(_contract_address: AztecAddress, _randomness: Field, _encrypted_event: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<let N: u32>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n"},"136":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"143":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"},"160":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"161":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::oracle::logs_traits::ToBytesForUnencryptedLog;\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (n as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"164":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"},"166":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::address::AztecAddress;\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"},"167":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH},\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\n\nglobal PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m: NpkM { inner: Point::empty() },\n            ivpk_m: IvpkM { inner: Point::empty() },\n            ovpk_m: OvpkM { inner: Point::empty() },\n            tpk_m: TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x: serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x: serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x: serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"183":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr","source":"use dep::protocol_types::{constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(\n        self,\n        note: &mut Note\n    ) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note where Note: NoteInterface<N> + NullifiableNote {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot).0\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    unconstrained pub fn view_note<let N: u32>(self) -> Note  where Note: NoteInterface<N> + NullifiableNote {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"},"229":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"29":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    /// \n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    /// \n    /// example\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    /// \n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    /// \n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    /// \n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    /// \n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    /// \n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Ord + Eq {\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Eq {\n    /// Returns a new sorted array by sorting it with a custom comparison function. \n    /// The original array remains untouched. \n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    /// \n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    /// \n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]), \"Array has not been sorted correctly according to `ordering`.\"\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n"},"306":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"309":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"313":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"314":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"316":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress}, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"317":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"322":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"323":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    crate::sha256::digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u64, msg_start: u32) -> ([u8; 64], u64) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr: u64 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    for k in msg_start..msg_end {\n        if k as u64 < message_size {\n            msg_block[msg_byte_ptr] = msg[k];\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n    (msg_block, msg_byte_ptr)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u64,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u64 {\n    let mut msg_byte_ptr: u64 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    let mut extra_bytes = 0;\n    if msg_end > N {\n        msg_end = N;\n        extra_bytes = msg_end - N;\n    }\n\n    for k in msg_start..msg_end {\n        if k as u64 < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\nglobal ZERO = 0;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start as u64 < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start as u64 < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start as u64 < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if msg_byte_ptr == 64 {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start as u64 < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start as u64 < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start as u64 < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE as u64 {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..64 {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..64 {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(mut msg_block: [u8; 64], mut msg_byte_ptr: u64) -> ([u8; 64], u64) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        if msg_byte_ptr < 64 {\n            for _ in 57..64 {\n                if msg_byte_ptr <= 63 {\n                    msg_block[msg_byte_ptr] = 0;\n                    msg_byte_ptr += 1;\n                }\n            }\n        }\n    }\n    (msg_block, msg_byte_ptr)\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; 64], mut msg_byte_ptr: u64, message_size: u64) -> [u8; 64] {\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for _i in 0..64 {\n        // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n        if msg_byte_ptr < 56 {\n            msg_block[msg_byte_ptr] = 0;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        } else if msg_byte_ptr < 64 {\n            for j in 0..8 {\n                msg_block[msg_byte_ptr + j] = len_bytes[j];\n            }\n            msg_byte_ptr += 8;\n        }\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; 64], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n"},"354":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"70":{"path":"/Users/niallcheetham/dev/aztec/publicgroups/PublicGroupsRoot/contracts/diffie_h/src/types/CSPRNG.nr","source":"use dep::std;\nuse dep::std::hash::{sha256, blake2s, pedersen_hash, pedersen_commitment, keccak256};\nuse dep::std::hash::poseidon::bn254::{hash_1, hash_2};\nuse dep::std::hash::mimc::{mimc, mimc_bn254};\nuse dep::std::hash::hash_to_field;\n\nstruct CSPRNG {\n    seed: [u8; 32],\n}\n\nfn convert_from_field(field: Field) -> [u8; 32] {\n    let mut bytes = [0 as u8; 32];\n    let num = field as u64;\n    for i in 0..32 {\n        bytes[i] = ((num >> (8 * (31 - i))) & 0xff) as u8;\n    }\n    bytes\n}\nimpl CSPRNG {\n    fn new(seed: [u8; 32]) -> CSPRNG {\n        CSPRNG { seed }\n    }\n\n    fn generate(&mut self, hash_method: u8) -> Field {\n        if hash_method == 0 {\n            // Using SHA-256\n            self.seed = std::hash::sha256(self.seed);\n        } else if hash_method == 1 {\n            // Using Blake2s\n            self.seed = std::hash::blake2s(self.seed);\n        } else if hash_method == 2 {\n            // Using Keccak256 (specify message_size as appropriate)\n            let message_size = 32; // Example size\n            self.seed = std::hash::keccak256(self.seed, message_size);\n        }\n\n        CSPRNG::convert_to_field(self.seed)\n    }\n\n    fn convert_to_field(hash_output: [u8; 32]) -> Field {\n        let mut result: Field = 0;\n        let mut v: Field = 1;\n\n        for i in 0..32 {\n            let index = 31 - i;  // Start from the end of the array\n            result += hash_output[index] as Field * v;\n            v *= 256;\n        }\n\n        result\n    }\n    fn reseed(&mut self, new_seed: [u8; 32]) {\n        self.seed = new_seed;\n    }\n}"},"71":{"path":"/Users/niallcheetham/dev/aztec/publicgroups/PublicGroupsRoot/contracts/diffie_h/src/types/NewAddressNote.nr","source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Serialize,Deserialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: u32 = 3;\n// CARD_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: u32 = 3 * 32 + 64;\n\n#[note]\n#[derive(Serialize)]\n#[derive(Deserialize)]\nstruct NewAddressNote {\n    address: AztecAddress,\n    shared_secret: Field,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n}\n\nimpl NullifiableNote for NewAddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl NewAddressNote {\n    pub fn new(address: AztecAddress, shared_secret: Field, npk_m_hash: Field) -> Self {\n        let header = NoteHeader::empty();\n        NewAddressNote { address, shared_secret, npk_m_hash, header }\n    }\n}\n\nimpl Eq for NewAddressNote {\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address)\n            & (self.shared_secret == other.shared_secret)\n            & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\n//serialize is a macro now?\n// impl Serialize<3> for NewAddressNote {\n//     fn serialize(self) -> [Field; 3] {\n//         [self.address.to_field(), self.shared_secret, self.npk_m_hash.to_field()]\n//     }\n// }\n\n"},"72":{"path":"/Users/niallcheetham/dev/aztec/publicgroups/PublicGroupsRoot/contracts/diffie_h/src/types/StringNote.nr","source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\n//going to make the max length 10 characters just to keep it simple\n//pretty sure the only thing that this changes is the amount of compute needed\nglobal STRING_NOTE_LENGTH: Field = 3;\nglobal STRING_NOTE_BYTES_LENGTH: Field = 3 * 32 + 64;\n\n#[note]\n#[derive(Serialize)]\nstruct StringNote { \n    string: Field,\n    randomness: Field,\n    npk_m_hash: Field,\n}\n\nimpl NullifiableNote for StringNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl StringNote {\n    pub fn new(string: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        StringNote { string, randomness, npk_m_hash, header }\n    }\n}\n\nimpl Eq for StringNote {\n    fn eq(self, other: Self) -> bool {\n        (self.string == other.string)\n            & (self.randomness == other.randomness)\n            & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\n//dont think i need serialise because of new macro\nimpl Serialize<3> for StringNote {\n    fn serialize(self) -> [Field; 3] {\n        [self.string, self.randomness, self.npk_m_hash.to_field()]\n    }\n}\n"},"74":{"path":"/Users/niallcheetham/dev/aztec/publicgroups/PublicGroupsRoot/contracts/diffie_h/src/main.nr","source":"mod types;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract DiffieH {\n    use dep::aztec::{\n        prelude::{Map, PublicMutable, AztecAddress, PrivateImmutable, PrivateSet, PrivateMutable},\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note_with_keys,\n        keys::getters::get_public_keys,\n        macros::{storage::storage, events::event, functions::{public, initializer, private, internal}}\n    };\n    use dep::aztec::note::note_viewer_options::NoteViewerOptions;\n    use crate::types::StringNote::StringNote;\n    use crate::types::NewAddressNote::NewAddressNote;\n    use aztec::note::note_getter::NoteGetterOptions;\n    use dep::address_note::address_note::AddressNote;\n    use crate::types::CSPRNG::CSPRNG;\n\n\n    use dep::value_note::{balance_utils, utils::{increment, decrement}, value_note::ValueNote};\n    use std::hash::pedersen_hash;\n    use dep::std::println;\n\n    global ZERO_ADDRESS: AztecAddress = AztecAddress::from_field(0x0000000000000000000000000000000000000000000000000000000000000000);\n\n    #[storage]\n    struct Storage<Context> {\n        admin: PrivateImmutable<AddressNote, Context>,\n        group_members: Map<AztecAddress, PrivateSet<NewAddressNote, Context>, Context>,\n        shared_secrets: Map<AztecAddress, PrivateImmutable<ValueNote, Context>, Context>,\n    }\n\n    #[private]\n    #[initializer]\n    fn constructor(admin: AztecAddress, group_members: [AztecAddress; 2]) {\n        // Setting the admin address note\n        let admin_keys = get_public_keys(admin);\n        let msg_sender_keys = get_public_keys(context.msg_sender());\n        let mut admin_address_note = AddressNote::new(admin, admin_keys.npk_m.hash());\n        storage.admin.initialize(&mut admin_address_note).emit(encode_and_encrypt_note_with_keys(&mut context, admin_keys.ovpk_m, admin_keys.ivpk_m, admin));\n\n\n    }\n\n    //make the public generator. for dh does this have to be prime\n    #[internal]\n    fn make_generator(seed: u8) -> pub Field {\n        let initial_seed = [seed ; 32];\n        let mut rng = CSPRNG::new(initial_seed);\n        let generator = rng.generate(0);\n        generator\n    }\n}"},"76":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/address-note/src/address_note.nr","source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext,\n    macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"},"81":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, notification_note_hash, nullifier_counter) == 0);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n\n"},"82":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"87":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"},"98":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"}}}